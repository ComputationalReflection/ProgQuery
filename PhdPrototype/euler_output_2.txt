
C:\Users\Oscar\Desktop\Oskar\Tesis\BigCodeProject\PhdPrototype>javac -cp C:\Users\Oscar\Desktop\java\lib\*;src;build\libs\neo4j\*; -Xplugin:WiggleIndexerPlugin -d bon  C:\Users\Oscar\Desktop\java\*.java 
Visiting class
EulerSolution
METHOD_INFO:

public String run();
AFTER ANALYZE
null
null
null
Visiting class
EulerTest
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

@Test()
public void testP001() {
    assertEquals("233168", new p001().run());
}
METHOD_INFO:

@Test()
public void testP002() {
    assertEquals("4613732", new p002().run());
}
METHOD_INFO:

@Test()
public void testP003() {
    assertEquals("6857", new p003().run());
}
METHOD_INFO:

@Test()
public void testP004() {
    assertEquals("906609", new p004().run());
}
METHOD_INFO:

@Test()
public void testP005() {
    assertEquals("232792560", new p005().run());
}
METHOD_INFO:

@Test()
public void testP006() {
    assertEquals("25164150", new p006().run());
}
METHOD_INFO:

@Test()
public void testP007() {
    assertEquals("104743", new p007().run());
}
METHOD_INFO:

@Test()
public void testP008() {
    assertEquals("23514624000", new p008().run());
}
METHOD_INFO:

@Test()
public void testP009() {
    assertEquals("31875000", new p009().run());
}
METHOD_INFO:

@Test()
public void testP010() {
    assertEquals("142913828922", new p010().run());
}
METHOD_INFO:

@Test()
public void testP011() {
    assertEquals("70600674", new p011().run());
}
METHOD_INFO:

@Test()
public void testP012() {
    assertEquals("76576500", new p012().run());
}
METHOD_INFO:

@Test()
public void testP013() {
    assertEquals("5537376230", new p013().run());
}
METHOD_INFO:

@Test()
public void testP014() {
    assertEquals("837799", new p014().run());
}
METHOD_INFO:

@Test()
public void testP015() {
    assertEquals("137846528820", new p015().run());
}
METHOD_INFO:

@Test()
public void testP016() {
    assertEquals("1366", new p016().run());
}
METHOD_INFO:

@Test()
public void testP017() {
    assertEquals("21124", new p017().run());
}
METHOD_INFO:

@Test()
public void testP018() {
    assertEquals("1074", new p018().run());
}
METHOD_INFO:

@Test()
public void testP019() {
    assertEquals("171", new p019().run());
}
METHOD_INFO:

@Test()
public void testP020() {
    assertEquals("648", new p020().run());
}
METHOD_INFO:

@Test()
public void testP021() {
    assertEquals("31626", new p021().run());
}
METHOD_INFO:

@Test()
public void testP022() {
    assertEquals("871198282", new p022().run());
}
METHOD_INFO:

@Test()
public void testP023() {
    assertEquals("4179871", new p023().run());
}
METHOD_INFO:

@Test()
public void testP024() {
    assertEquals("2783915460", new p024().run());
}
METHOD_INFO:

@Test()
public void testP025() {
    assertEquals("4782", new p025().run());
}
METHOD_INFO:

@Test()
public void testP026() {
    assertEquals("983", new p026().run());
}
METHOD_INFO:

@Test()
public void testP027() {
    assertEquals("-59231", new p027().run());
}
METHOD_INFO:

@Test()
public void testP028() {
    assertEquals("669171001", new p028().run());
}
METHOD_INFO:

@Test()
public void testP029() {
    assertEquals("9183", new p029().run());
}
METHOD_INFO:

@Test()
public void testP030() {
    assertEquals("443839", new p030().run());
}
METHOD_INFO:

@Test()
public void testP031() {
    assertEquals("73682", new p031().run());
}
METHOD_INFO:

@Test()
public void testP032() {
    assertEquals("45228", new p032().run());
}
METHOD_INFO:

@Test()
public void testP033() {
    assertEquals("100", new p033().run());
}
METHOD_INFO:

@Test()
public void testP034() {
    assertEquals("40730", new p034().run());
}
METHOD_INFO:

@Test()
public void testP035() {
    assertEquals("55", new p035().run());
}
METHOD_INFO:

@Test()
public void testP036() {
    assertEquals("872187", new p036().run());
}
METHOD_INFO:

@Test()
public void testP037() {
    assertEquals("748317", new p037().run());
}
METHOD_INFO:

@Test()
public void testP038() {
    assertEquals("932718654", new p038().run());
}
METHOD_INFO:

@Test()
public void testP039() {
    assertEquals("840", new p039().run());
}
METHOD_INFO:

@Test()
public void testP040() {
    assertEquals("210", new p040().run());
}
METHOD_INFO:

@Test()
public void testP041() {
    assertEquals("7652413", new p041().run());
}
METHOD_INFO:

@Test()
public void testP042() {
    assertEquals("162", new p042().run());
}
METHOD_INFO:

@Test()
public void testP043() {
    assertEquals("16695334890", new p043().run());
}
METHOD_INFO:

@Test()
public void testP044() {
    assertEquals("5482660", new p044().run());
}
METHOD_INFO:

@Test()
public void testP045() {
    assertEquals("1533776805", new p045().run());
}
METHOD_INFO:

@Test()
public void testP046() {
    assertEquals("5777", new p046().run());
}
METHOD_INFO:

@Test()
public void testP047() {
    assertEquals("134043", new p047().run());
}
METHOD_INFO:

@Test()
public void testP048() {
    assertEquals("9110846700", new p048().run());
}
METHOD_INFO:

@Test()
public void testP049() {
    assertEquals("296962999629", new p049().run());
}
METHOD_INFO:

@Test()
public void testP050() {
    assertEquals("997651", new p050().run());
}
METHOD_INFO:

@Test()
public void testP051() {
    assertEquals("121313", new p051().run());
}
METHOD_INFO:

@Test()
public void testP052() {
    assertEquals("142857", new p052().run());
}
METHOD_INFO:

@Test()
public void testP053() {
    assertEquals("4075", new p053().run());
}
METHOD_INFO:

@Test()
public void testP054() {
    assertEquals("376", new p054().run());
}
METHOD_INFO:

@Test()
public void testP055() {
    assertEquals("249", new p055().run());
}
METHOD_INFO:

@Test()
public void testP056() {
    assertEquals("972", new p056().run());
}
METHOD_INFO:

@Test()
public void testP057() {
    assertEquals("153", new p057().run());
}
METHOD_INFO:

@Test()
public void testP058() {
    assertEquals("26241", new p058().run());
}
METHOD_INFO:

@Test()
public void testP059() {
    assertEquals("107359", new p059().run());
}
METHOD_INFO:

@Test()
public void testP060() {
    assertEquals("26033", new p060().run());
}
METHOD_INFO:

@Test()
public void testP061() {
    assertEquals("28684", new p061().run());
}
METHOD_INFO:

@Test()
public void testP062() {
    assertEquals("127035954683", new p062().run());
}
METHOD_INFO:

@Test()
public void testP063() {
    assertEquals("49", new p063().run());
}
METHOD_INFO:

@Test()
public void testP064() {
    assertEquals("1322", new p064().run());
}
METHOD_INFO:

@Test()
public void testP065() {
    assertEquals("272", new p065().run());
}
METHOD_INFO:

@Test()
public void testP066() {
    assertEquals("661", new p066().run());
}
METHOD_INFO:

@Test()
public void testP067() {
    assertEquals("7273", new p067().run());
}
METHOD_INFO:

@Test()
public void testP068() {
    assertEquals("6531031914842725", new p068().run());
}
METHOD_INFO:

@Test()
public void testP069() {
    assertEquals("510510", new p069().run());
}
METHOD_INFO:

@Test()
public void testP070() {
    assertEquals("8319823", new p070().run());
}
METHOD_INFO:

@Test()
public void testP071() {
    assertEquals("428570", new p071().run());
}
METHOD_INFO:

@Test()
public void testP072() {
    assertEquals("303963552391", new p072().run());
}
METHOD_INFO:

@Test()
public void testP073() {
    assertEquals("7295372", new p073().run());
}
METHOD_INFO:

@Test()
public void testP074() {
    assertEquals("402", new p074().run());
}
METHOD_INFO:

@Test()
public void testP075() {
    assertEquals("161667", new p075().run());
}
METHOD_INFO:

@Test()
public void testP076() {
    assertEquals("190569291", new p076().run());
}
METHOD_INFO:

@Test()
public void testP077() {
    assertEquals("71", new p077().run());
}
METHOD_INFO:

@Test()
public void testP078() {
    assertEquals("55374", new p078().run());
}
METHOD_INFO:

@Test()
public void testP079() {
    assertEquals("73162890", new p079().run());
}
METHOD_INFO:

@Test()
public void testP080() {
    assertEquals("40886", new p080().run());
}
METHOD_INFO:

@Test()
public void testP081() {
    assertEquals("427337", new p081().run());
}
METHOD_INFO:

@Test()
public void testP082() {
    assertEquals("260324", new p082().run());
}
METHOD_INFO:

@Test()
public void testP083() {
    assertEquals("425185", new p083().run());
}
METHOD_INFO:

@Test()
public void testP084() {
    assertEquals("101524", new p084().run());
}
METHOD_INFO:

@Test()
public void testP085() {
    assertEquals("2772", new p085().run());
}
METHOD_INFO:

@Test()
public void testP086() {
    assertEquals("1818", new p086().run());
}
METHOD_INFO:

@Test()
public void testP087() {
    assertEquals("1097343", new p087().run());
}
METHOD_INFO:

@Test()
public void testP088() {
    assertEquals("7587457", new p088().run());
}
METHOD_INFO:

@Test()
public void testP089() {
    assertEquals("743", new p089().run());
}
METHOD_INFO:

@Test()
public void testP090() {
    assertEquals("1217", new p090().run());
}
METHOD_INFO:

@Test()
public void testP091() {
    assertEquals("14234", new p091().run());
}
METHOD_INFO:

@Test()
public void testP092() {
    assertEquals("8581146", new p092().run());
}
METHOD_INFO:

@Test()
public void testP093() {
    assertEquals("1258", new p093().run());
}
METHOD_INFO:

@Test()
public void testP094() {
    assertEquals("518408346", new p094().run());
}
METHOD_INFO:

@Test()
public void testP095() {
    assertEquals("14316", new p095().run());
}
METHOD_INFO:

@Test()
public void testP096() {
    assertEquals("24702", new p096().run());
}
METHOD_INFO:

@Test()
public void testP097() {
    assertEquals("8739992577", new p097().run());
}
METHOD_INFO:

@Test()
public void testP098() {
    assertEquals("18769", new p098().run());
}
METHOD_INFO:

@Test()
public void testP099() {
    assertEquals("709", new p099().run());
}
METHOD_INFO:

@Test()
public void testP100() {
    assertEquals("756872327473", new p100().run());
}
METHOD_INFO:

@Test()
public void testP101() {
    assertEquals("37076114526", new p101().run());
}
METHOD_INFO:

@Test()
public void testP102() {
    assertEquals("228", new p102().run());
}
METHOD_INFO:

@Test()
public void testP104() {
    assertEquals("329468", new p104().run());
}
METHOD_INFO:

@Test()
public void testP105() {
    assertEquals("73702", new p105().run());
}
METHOD_INFO:

@Test()
public void testP107() {
    assertEquals("259679", new p107().run());
}
METHOD_INFO:

@Test()
public void testP108() {
    assertEquals("180180", new p108().run());
}
METHOD_INFO:

@Test()
public void testP109() {
    assertEquals("38182", new p109().run());
}
METHOD_INFO:

@Test()
public void testP111() {
    assertEquals("612407567715", new p111().run());
}
METHOD_INFO:

@Test()
public void testP112() {
    assertEquals("1587000", new p112().run());
}
METHOD_INFO:

@Test()
public void testP113() {
    assertEquals("51161058134250", new p113().run());
}
METHOD_INFO:

@Test()
public void testP114() {
    assertEquals("16475640049", new p114().run());
}
METHOD_INFO:

@Test()
public void testP115() {
    assertEquals("168", new p115().run());
}
METHOD_INFO:

@Test()
public void testP116() {
    assertEquals("20492570929", new p116().run());
}
METHOD_INFO:

@Test()
public void testP117() {
    assertEquals("100808458960497", new p117().run());
}
METHOD_INFO:

@Test()
public void testP118() {
    assertEquals("44680", new p118().run());
}
METHOD_INFO:

@Test()
public void testP119() {
    assertEquals("248155780267521", new p119().run());
}
METHOD_INFO:

@Test()
public void testP120() {
    assertEquals("333082500", new p120().run());
}
METHOD_INFO:

@Test()
public void testP121() {
    assertEquals("2269", new p121().run());
}
METHOD_INFO:

@Test()
public void testP122() {
    assertEquals("1582", new p122().run());
}
METHOD_INFO:

@Test()
public void testP123() {
    assertEquals("21035", new p123().run());
}
METHOD_INFO:

@Test()
public void testP124() {
    assertEquals("21417", new p124().run());
}
METHOD_INFO:

@Test()
public void testP125() {
    assertEquals("2906969179", new p125().run());
}
METHOD_INFO:

@Test()
public void testP127() {
    assertEquals("18407904", new p127().run());
}
METHOD_INFO:

@Test()
public void testP128() {
    assertEquals("14516824220", new p128().run());
}
METHOD_INFO:

@Test()
public void testP129() {
    assertEquals("1000023", new p129().run());
}
METHOD_INFO:

@Test()
public void testP130() {
    assertEquals("149253", new p130().run());
}
METHOD_INFO:

@Test()
public void testP132() {
    assertEquals("843296", new p132().run());
}
METHOD_INFO:

@Test()
public void testP133() {
    assertEquals("453647705", new p133().run());
}
METHOD_INFO:

@Test()
public void testP134() {
    assertEquals("18613426663617118", new p134().run());
}
METHOD_INFO:

@Test()
public void testP135() {
    assertEquals("4989", new p135().run());
}
METHOD_INFO:

@Test()
public void testP139() {
    assertEquals("10057761", new p139().run());
}
METHOD_INFO:

@Test()
public void testP142() {
    assertEquals("1006193", new p142().run());
}
METHOD_INFO:

@Test()
public void testP145() {
    assertEquals("608720", new p145().run());
}
METHOD_INFO:

@Test()
public void testP146() {
    assertEquals("676333270", new p146().run());
}
METHOD_INFO:

@Test()
public void testP149() {
    assertEquals("52852124", new p149().run());
}
METHOD_INFO:

@Test()
public void testP150() {
    assertEquals("-271248680", new p150().run());
}
METHOD_INFO:

@Test()
public void testP151() {
    assertEquals("0.464399", new p151().run());
}
METHOD_INFO:

@Test()
public void testP155() {
    assertEquals("3857447", new p155().run());
}
METHOD_INFO:

@Test()
public void testP160() {
    assertEquals("16576", new p160().run());
}
METHOD_INFO:

@Test()
public void testP162() {
    assertEquals("3D58725572C62302", new p162().run());
}
METHOD_INFO:

@Test()
public void testP164() {
    assertEquals("378158756814587", new p164().run());
}
METHOD_INFO:

@Test()
public void testP166() {
    assertEquals("7130034", new p166().run());
}
METHOD_INFO:

@Test()
public void testP169() {
    assertEquals("178653872807", new p169().run());
}
METHOD_INFO:

@Test()
public void testP171() {
    assertEquals("142989277", new p171().run());
}
METHOD_INFO:

@Test()
public void testP172() {
    assertEquals("227485267000992000", new p172().run());
}
METHOD_INFO:

@Test()
public void testP173() {
    assertEquals("1572729", new p173().run());
}
METHOD_INFO:

@Test()
public void testP174() {
    assertEquals("209566", new p174().run());
}
METHOD_INFO:

@Test()
public void testP178() {
    assertEquals("126461847755", new p178().run());
}
METHOD_INFO:

@Test()
public void testP179() {
    assertEquals("986262", new p179().run());
}
METHOD_INFO:

@Test()
public void testP182() {
    assertEquals("399788195976", new p182().run());
}
METHOD_INFO:

@Test()
public void testP186() {
    assertEquals("2325629", new p186().run());
}
METHOD_INFO:

@Test()
public void testP187() {
    assertEquals("17427258", new p187().run());
}
METHOD_INFO:

@Test()
public void testP188() {
    assertEquals("95962097", new p188().run());
}
METHOD_INFO:

@Test()
public void testP191() {
    assertEquals("1918080160", new p191().run());
}
METHOD_INFO:

@Test()
public void testP197() {
    assertEquals("1.710637717", new p197().run());
}
METHOD_INFO:

@Test()
public void testP203() {
    assertEquals("34029210557338", new p203().run());
}
METHOD_INFO:

@Test()
public void testP204() {
    assertEquals("2944730", new p204().run());
}
METHOD_INFO:

@Test()
public void testP205() {
    assertEquals("0.5731441", new p205().run());
}
METHOD_INFO:

@Test()
public void testP206() {
    assertEquals("1389019170", new p206().run());
}
METHOD_INFO:

@Test()
public void testP208() {
    assertEquals("331951449665644800", new p208().run());
}
METHOD_INFO:

@Test()
public void testP211() {
    assertEquals("1922364685", new p211().run());
}
METHOD_INFO:

@Test()
public void testP214() {
    assertEquals("1677366278943", new p214().run());
}
METHOD_INFO:

@Test()
public void testP215() {
    assertEquals("806844323190414", new p215().run());
}
METHOD_INFO:

@Test()
public void testP216() {
    assertEquals("5437849", new p216().run());
}
METHOD_INFO:

@Test()
public void testP218() {
    assertEquals("0", new p218().run());
}
METHOD_INFO:

@Test()
public void testP222() {
    assertEquals("1590933", new p222().run());
}
METHOD_INFO:

@Test()
public void testP225() {
    assertEquals("2009", new p225().run());
}
METHOD_INFO:

@Test()
public void testP231() {
    assertEquals("7526965179680", new p231().run());
}
METHOD_INFO:

@Test()
public void testP243() {
    assertEquals("892371480", new p243().run());
}
METHOD_INFO:

@Test()
public void testP249() {
    assertEquals("9275262564250418", new p249().run());
}
METHOD_INFO:

@Test()
public void testP250() {
    assertEquals("1425480602091519", new p250().run());
}
METHOD_INFO:

@Test()
public void testP265() {
    assertEquals("209110240768", new p265().run());
}
METHOD_INFO:

@Test()
public void testP267() {
    assertEquals("0.999992836187", new p267().run());
}
METHOD_INFO:

@Test()
public void testP271() {
    assertEquals("4617456485273129588", new p271().run());
}
METHOD_INFO:

@Test()
public void testP280() {
    assertEquals("430.088247", new p280().run());
}
METHOD_INFO:

@Test()
public void testP301() {
    assertEquals("2178309", new p301().run());
}
METHOD_INFO:

@Test()
public void testP303() {
    assertEquals("1111981904675169", new p303().run());
}
METHOD_INFO:

@Test()
public void testP304() {
    assertEquals("283988410192", new p304().run());
}
METHOD_INFO:

@Test()
public void testP315() {
    assertEquals("13625242", new p315().run());
}
METHOD_INFO:

@Test()
public void testP323() {
    assertEquals("6.3551758451", new p323().run());
}
METHOD_INFO:

@Test()
public void testP329() {
    assertEquals("199740353/29386561536000", new p329().run());
}
METHOD_INFO:

@Test()
public void testP345() {
    assertEquals("13938", new p345().run());
}
METHOD_INFO:

@Test()
public void testP346() {
    assertEquals("336108797689259276", new p346().run());
}
METHOD_INFO:

@Test()
public void testP347() {
    assertEquals("11109800204052", new p347().run());
}
METHOD_INFO:

@Test()
public void testP348() {
    assertEquals("1004195061", new p348().run());
}
METHOD_INFO:

@Test()
public void testP357() {
    assertEquals("1739023853137", new p357().run());
}
METHOD_INFO:

@Test()
public void testP381() {
    assertEquals("139602943319822", new p381().run());
}
METHOD_INFO:

@Test()
public void testP387() {
    assertEquals("696067597313468", new p387().run());
}
METHOD_INFO:

@Test()
public void testP401() {
    assertEquals("281632621", new p401().run());
}
METHOD_INFO:

@Test()
public void testP407() {
    assertEquals("39782849136421", new p407().run());
}
METHOD_INFO:

@Test()
public void testP417() {
    assertEquals("446572970925740", new p417().run());
}
METHOD_INFO:

@Test()
public void testP425() {
    assertEquals("46479497324", new p425().run());
}
METHOD_INFO:

@Test()
public void testP429() {
    assertEquals("98792821", new p429().run());
}
METHOD_INFO:

@Test()
public void testP431() {
    assertEquals("23.386029052", new p431().run());
}
METHOD_INFO:

@Test()
public void testP433() {
    assertEquals("326624372659664", new p433().run());
}
METHOD_INFO:

@Test()
public void testP451() {
    assertEquals("153651073760956", new p451().run());
}
METHOD_INFO:

@Test()
public void testP493() {
    assertEquals("6.818741802", new p493().run());
}
METHOD_INFO:

@Test()
public void testP500() {
    assertEquals("35407281", new p500().run());
}
METHOD_INFO:

@Test()
public void testP518() {
    assertEquals("100315739184392", new p518().run());
}
METHOD_INFO:

@Test()
public void testP549() {
    assertEquals("476001479068717", new p549().run());
}
METHOD_INFO:

@Test()
public void testP587() {
    assertEquals("2240", new p587().run());
}
AFTER ANALYZE
null
null
null
Visiting class
Fraction
METHOD_INFO:

public <init>(BigInteger numer) {
    super();
    numerator = numer;
    denominator = BigInteger.ONE;
}
METHOD_INFO:

public <init>(BigInteger numer, BigInteger denom) {
    super();
    if (denom.signum() == 0) throw new ArithmeticException("Division by zero");
    if (denom.signum() == -1) {
        numer = numer.negate();
        denom = denom.negate();
    }
    BigInteger gcd = numer.gcd(denom);
    if (!gcd.equals(BigInteger.ONE)) {
        numer = numer.divide(gcd);
        denom = denom.divide(gcd);
    }
    numerator = numer;
    denominator = denom;
}
METHOD_INFO:

public Fraction add(Fraction other) {
    return new Fraction(numerator.multiply(other.denominator).add(other.numerator.multiply(denominator)), denominator.multiply(other.denominator));
}
METHOD_INFO:

public Fraction subtract(Fraction other) {
    return new Fraction(numerator.multiply(other.denominator).subtract(other.numerator.multiply(denominator)), denominator.multiply(other.denominator));
}
METHOD_INFO:

public Fraction multiply(Fraction other) {
    return new Fraction(numerator.multiply(other.numerator), denominator.multiply(other.denominator));
}
METHOD_INFO:

public Fraction divide(Fraction other) {
    return new Fraction(numerator.multiply(other.denominator), denominator.multiply(other.numerator));
}
METHOD_INFO:

public boolean equals(Object obj) {
    if (!(obj instanceof Fraction)) return false;
    Fraction other = (Fraction)obj;
    return numerator.equals(other.numerator) && denominator.equals(other.denominator);
}
METHOD_INFO:

public int compareTo(Fraction other) {
    return numerator.multiply(other.denominator).compareTo(other.numerator.multiply(denominator));
}
METHOD_INFO:

public int hashCode() {
    return numerator.hashCode() + denominator.hashCode();
}
METHOD_INFO:

public String toString() {
    return numerator + "/" + denominator;
}
Visiting class
D
METHOD_INFO:

<init>() {
    super();
}
Visiting class
F
METHOD_INFO:

private <init>() {
    super();
}
Visiting class
Library
METHOD_INFO:

<init>() {
    super();
}
METHOD_INFO:

public static String reverse(String s) {
    return new StringBuilder(s).reverse().toString();
}
METHOD_INFO:

public static boolean isPalindrome(String s) {
    return s.equals(reverse(s));
}
METHOD_INFO:

public static boolean isPalindrome(int x) {
    return isPalindrome(Integer.toString(x));
}
METHOD_INFO:

public static int sqrt(int x) {
    if (x < 0) throw new IllegalArgumentException("Square root of negative number");
    int y = 0;
    for (int i = 1 << 15; i != 0; i >>>= 1) {
        y |= i;
        if (y > 46340 || y * y > x) y ^= i;
    }
    return y;
}
METHOD_INFO:

public static long sqrt(long x) {
    if (x < 0) throw new IllegalArgumentException("Square root of negative number");
    long y = 0;
    for (long i = 1L << 31; i != 0; i >>>= 1) {
        y |= i;
        if (y > 3037000499L || y * y > x) y ^= i;
    }
    return y;
}
METHOD_INFO:

public static BigInteger sqrt(BigInteger x) {
    if (x.signum() == -1) throw new IllegalArgumentException("Square root of negative number");
    BigInteger y = BigInteger.ZERO;
    for (int i = (x.bitLength() - 1) / 2; i >= 0; i--) {
        y = y.setBit(i);
        if (y.multiply(y).compareTo(x) > 0) y = y.clearBit(i);
    }
    return y;
}
METHOD_INFO:

public static boolean isSquare(int x) {
    if (x < 0) return false;
    int y = Library.sqrt(x);
    return y * y == x;
}
METHOD_INFO:

public static int pow(int x, int y) {
    if (x < 0) throw new IllegalArgumentException("Negative base not supported");
    if (y < 0) throw new IllegalArgumentException("Negative exponent");
    int z = 1;
    for (int i = 0; i < y; i++) {
        if (Integer.MAX_VALUE / z < x) throw new ArithmeticException("Overflow");
        z *= x;
    }
    return z;
}
METHOD_INFO:

public static int powMod(int x, int y, int m) {
    if (x < 0) throw new IllegalArgumentException("Negative base not supported");
    if (y < 0) throw new IllegalArgumentException("Modular reciprocal not supported");
    if (m <= 0) throw new IllegalArgumentException("Modulus must be positive");
    if (m == 1) return 0;
    int z = 1;
    for (; y != 0; y >>>= 1) {
        if ((y & 1) != 0) z = (int)((long)z * x % m);
        x = (int)((long)x * x % m);
    }
    return z;
}
METHOD_INFO:

public static int reciprocalMod(int x, int m) {
    if (!(0 <= x && x < m)) throw new IllegalArgumentException();
    int y = x;
    x = m;
    int a = 0;
    int b = 1;
    while (y != 0) {
        int z = x % y;
        int c = a - x / y * b;
        x = y;
        y = z;
        a = b;
        b = c;
    }
    if (x == 1) return a >= 0 ? a : a + m; else throw new IllegalArgumentException("Reciprocal does not exist");
}
METHOD_INFO:

public static BigInteger factorial(int n) {
    if (n < 0) throw new IllegalArgumentException("Factorial of negative number");
    BigInteger prod = BigInteger.ONE;
    for (int i = 2; i <= n; i++) prod = prod.multiply(BigInteger.valueOf(i));
    return prod;
}
METHOD_INFO:

public static BigInteger binomial(int n, int k) {
    if (k < 0 || k > n) throw new IllegalArgumentException();
    BigInteger product = BigInteger.ONE;
    for (int i = 0; i < k; i++) product = product.multiply(BigInteger.valueOf(n - i));
    return product.divide(factorial(k));
}
METHOD_INFO:

public static int gcd(int x, int y) {
    if (x < 0 || y < 0) throw new IllegalArgumentException("Negative number");
    while (y != 0) {
        int z = x % y;
        x = y;
        y = z;
    }
    return x;
}
METHOD_INFO:

public static boolean isPrime(int x) {
    if (x < 0) throw new IllegalArgumentException("Negative number");
    if (x == 0 || x == 1) return false; else if (x == 2) return true; else {
        if (x % 2 == 0) return false;
        for (int i = 3, end = sqrt(x); i <= end; i += 2) {
            if (x % i == 0) return false;
        }
        return true;
    }
}
METHOD_INFO:

public static boolean[] listPrimality(int n) {
    if (n < 0) throw new IllegalArgumentException("Negative array size");
    boolean[] result = new boolean[n + 1];
    if (n >= 2) result[2] = true;
    for (int i = 3; i <= n; i += 2) result[i] = true;
    for (int i = 3, end = sqrt(n); i <= end; i += 2) {
        if (result[i]) {
            for (int j = i * i, inc = i * 2; j <= n; j += inc) result[j] = false;
        }
    }
    return result;
}
METHOD_INFO:

public static int[] listPrimes(int n) {
    boolean[] isPrime = listPrimality(n);
    int count = 0;
    for (boolean b : isPrime) {
        if (b) count++;
    }
    int[] result = new int[count];
    for (int i = 0, j = 0; i < isPrime.length; i++) {
        if (isPrime[i]) {
            result[j] = i;
            j++;
        }
    }
    return result;
}
Adding methodTree -->:

public static int[] listPrimes(int n) {
    boolean[] isPrime = listPrimality(n);
    int count = 0;
    for (boolean b : isPrime) {
        if (b) count++;
    }
    int[] result = new int[count];
    for (int i = 0, j = 0; i < isPrime.length; i++) {
        if (isPrime[i]) {
            result[j] = i;
            j++;
        }
    }
    return result;
}
METHOD_INFO:

public static int[] listSmallestPrimeFactors(int n) {
    int[] result = new int[n + 1];
    int limit = sqrt(n);
    for (int i = 2; i < result.length; i++) {
        if (result[i] == 0) {
            result[i] = i;
            if (i <= limit) {
                for (int j = i * i; j <= n; j += i) {
                    if (result[j] == 0) result[j] = i;
                }
            }
        }
    }
    return result;
}
METHOD_INFO:

public static int totient(int n) {
    if (n <= 0) throw new IllegalArgumentException("Totient of non-positive integer");
    int p = 1;
    for (int i = 2, end = Library.sqrt(n); i <= end; i++) {
        if (n % i == 0) {
            p *= i - 1;
            n /= i;
            while (n % i == 0) {
                p *= i;
                n /= i;
            }
            end = Library.sqrt(n);
        }
    }
    if (n != 1) p *= n - 1;
    return p;
}
METHOD_INFO:

public static int[] listTotients(int n) {
    if (n < 0) throw new IllegalArgumentException("Negative array size");
    int[] result = new int[n + 1];
    for (int i = 0; i <= n; i++) result[i] = i;
    for (int i = 2; i <= n; i++) {
        if (result[i] == i) {
            for (int j = i; j <= n; j += i) result[j] -= result[j] / i;
        }
    }
    return result;
}
METHOD_INFO:

public static boolean nextPermutation(int[] arr) {
    int i = arr.length - 1;
    for (; i > 0 && arr[i - 1] >= arr[i]; i--) ;
    if (i <= 0) return false;
    {
        int j = arr.length - 1;
        for (; arr[j] <= arr[i - 1]; j--) ;
        int temp = arr[i - 1];
        arr[i - 1] = arr[j];
        arr[j] = temp;
    }
    for (int j = arr.length - 1; i < j; i++, j--) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    return true;
}
Visiting class
C
METHOD_INFO:

<init>() {
    super();
}
AFTER ANALYZE
null
null
null
Visiting class
LibraryTest
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

@Test()
public void testReverse() {
    assertEquals("", Library.reverse(""));
    assertEquals("a", Library.reverse("a"));
    assertEquals("ba", Library.reverse("ab"));
    assertEquals("001", Library.reverse("100"));
    assertEquals("a0a", Library.reverse("a0a"));
}
METHOD_INFO:

@Test()
public void testIsPalindromeString() {
    assertTrue(Library.isPalindrome(""));
    assertTrue(Library.isPalindrome("a"));
    assertTrue(Library.isPalindrome("aa"));
    assertTrue(Library.isPalindrome("aaa"));
    assertTrue(Library.isPalindrome("aaaa"));
    assertTrue(Library.isPalindrome("aba"));
    assertTrue(Library.isPalindrome("abba"));
    assertTrue(Library.isPalindrome("abbba"));
    assertTrue(Library.isPalindrome("acbca"));
    assertFalse(Library.isPalindrome("ab"));
    assertFalse(Library.isPalindrome("ba"));
    assertFalse(Library.isPalindrome("aaba"));
    assertFalse(Library.isPalindrome("abcd"));
}
METHOD_INFO:

@Test()
public void testIsPalindromeInt() {
    assertTrue(Library.isPalindrome(0));
    assertTrue(Library.isPalindrome(1));
    assertTrue(Library.isPalindrome(5));
    assertTrue(Library.isPalindrome(11));
    assertTrue(Library.isPalindrome(33));
    assertTrue(Library.isPalindrome(101));
    assertTrue(Library.isPalindrome(151));
    assertTrue(Library.isPalindrome(737));
    assertTrue(Library.isPalindrome(2222));
    assertTrue(Library.isPalindrome(5665));
    assertTrue(Library.isPalindrome(2147447412));
    assertFalse(Library.isPalindrome(12));
    assertFalse(Library.isPalindrome(43));
    assertFalse(Library.isPalindrome(220));
    assertFalse(Library.isPalindrome(1010));
    assertFalse(Library.isPalindrome(2147483647));
}
METHOD_INFO:

@Test()
public void testSqrtInt() {
    assertEquals(0, Library.sqrt(0));
    assertEquals(1, Library.sqrt(1));
    assertEquals(1, Library.sqrt(2));
    assertEquals(1, Library.sqrt(3));
    assertEquals(2, Library.sqrt(4));
    assertEquals(2, Library.sqrt(5));
    assertEquals(2, Library.sqrt(8));
    assertEquals(3, Library.sqrt(9));
    assertEquals(3, Library.sqrt(10));
    assertEquals(18, Library.sqrt(360));
    assertEquals(19, Library.sqrt(361));
    assertEquals(19, Library.sqrt(362));
    assertEquals(256, Library.sqrt(65536));
    assertEquals(32768, Library.sqrt(1073741824));
    assertEquals(46340, Library.sqrt(2147483647));
}
METHOD_INFO:

@Test()
public void testSqrtIntRandomly() {
    final int trials = 1000000;
    for (int i = 0; i < trials; i++) {
        int x = rand.nextInt() >>> 1;
        int y = Library.sqrt(x);
        assertTrue(0 <= y && y <= x);
        assertTrue((long)y * y <= x && x < (y + 1L) * (y + 1L));
    }
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testSqrtIntInvalid0() {
    Library.sqrt(-1);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testSqrtIntInvalid1() {
    Library.sqrt(-300000);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testSqrtIntInvalid2() {
    Library.sqrt(Integer.MIN_VALUE);
}
METHOD_INFO:

@Test()
public void testSqrtLong() {
    assertEquals(0L, Library.sqrt(0L));
    assertEquals(1L, Library.sqrt(1L));
    assertEquals(1L, Library.sqrt(2L));
    assertEquals(1L, Library.sqrt(3L));
    assertEquals(2L, Library.sqrt(4L));
    assertEquals(2L, Library.sqrt(5L));
    assertEquals(2L, Library.sqrt(8L));
    assertEquals(3L, Library.sqrt(9L));
    assertEquals(3L, Library.sqrt(10L));
    assertEquals(18L, Library.sqrt(360L));
    assertEquals(19L, Library.sqrt(361L));
    assertEquals(19L, Library.sqrt(362L));
    assertEquals(256L, Library.sqrt(65536L));
    assertEquals(32768L, Library.sqrt(1073741824L));
    assertEquals(46340L, Library.sqrt(2147483648L));
    assertEquals(2645751L, Library.sqrt(7000000000000L));
    assertEquals(3037000499L, Library.sqrt(9223372036854775807L));
}
METHOD_INFO:

@Test()
public void testSqrtLongRandomly() {
    final int trials = 1000000;
    for (int i = 0; i < trials; i++) {
        long x = rand.nextLong() >>> 1;
        long y = Library.sqrt(x);
        assertTrue(0 <= y && y <= x);
        if (x > 0) assertTrue(y <= x / y && x / (y + 1) < y + 1);
    }
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testSqrtLongInvalid0() {
    Library.sqrt(-1);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testSqrtLongInvalid1() {
    Library.sqrt(-3000000000L);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testSqrtLongInvalid2() {
    Library.sqrt(Long.MIN_VALUE);
}
METHOD_INFO:

@Test()
public void testIsSquare() {
    assertTrue(Library.isSquare(0));
    assertTrue(Library.isSquare(1));
    assertTrue(Library.isSquare(4));
    assertTrue(Library.isSquare(9));
    assertTrue(Library.isSquare(16));
    assertTrue(Library.isSquare(25));
    assertTrue(Library.isSquare(36));
    assertTrue(Library.isSquare(100));
    assertTrue(Library.isSquare(65536));
    assertTrue(Library.isSquare(2147302921));
    assertTrue(Library.isSquare(2147395600));
    assertFalse(Library.isSquare(Integer.MIN_VALUE));
    assertFalse(Library.isSquare(Integer.MIN_VALUE + 1));
    assertFalse(Library.isSquare(-8654038));
    assertFalse(Library.isSquare(-300));
    assertFalse(Library.isSquare(-4));
    assertFalse(Library.isSquare(-1));
    assertFalse(Library.isSquare(2));
    assertFalse(Library.isSquare(3));
    assertFalse(Library.isSquare(5));
    assertFalse(Library.isSquare(6));
    assertFalse(Library.isSquare(7));
    assertFalse(Library.isSquare(8));
    assertFalse(Library.isSquare(120));
    assertFalse(Library.isSquare(9999));
    assertFalse(Library.isSquare(Integer.MAX_VALUE - 1));
    assertFalse(Library.isSquare(Integer.MAX_VALUE));
}
METHOD_INFO:

@Test()
public void testPowMod() {
    assertEquals(0, Library.powMod(0, 0, 1));
    assertEquals(0, Library.powMod(1, 0, 1));
    assertEquals(0, Library.powMod(0, 1, 1));
    assertEquals(0, Library.powMod(1, 1, 1));
    assertEquals(0, Library.powMod(2, 3, 1));
    assertEquals(1, Library.powMod(0, 0, 2));
    assertEquals(1, Library.powMod(1, 0, 2));
    assertEquals(1, Library.powMod(2, 0, 2));
    assertEquals(0, Library.powMod(0, 1, 2));
    assertEquals(1, Library.powMod(1, 1, 2));
    assertEquals(0, Library.powMod(2, 1, 2));
    assertEquals(0, Library.powMod(0, 2, 2));
    assertEquals(1, Library.powMod(1, 2, 2));
    assertEquals(0, Library.powMod(2, 2, 2));
    assertEquals(1, Library.powMod(2, 2, 3));
    assertEquals(4, Library.powMod(4, 3, 5));
    assertEquals(3, Library.powMod(7, 7, 10));
    assertEquals(326216098, Library.powMod(78051657, 234602, 456087413));
    assertEquals(1488576545, Library.powMod(2147480000, 2147483645, 2147483647));
}
METHOD_INFO:

@Test()
public void testReciprocalMod() {
    int[][] goodCases = {{1, 2, 1}, {1, 3, 1}, {2, 3, 2}, {1, 4, 1}, {3, 4, 3}, {1, 5, 1}, {2, 5, 3}, {3, 5, 2}, {4, 5, 4}, {2, 7, 4}, {3, 7, 5}, {4, 7, 2}, {5, 7, 3}, {6, 7, 6}, {18585, 26128, 5705}, {4352341, 7559949, 3054661}, {290514683, 936234758, 903930729}, {735803087, 1384775511, 1321131185}, {1, 2147483647, 1}, {2, 2147483647, 1073741824}, {188080773, 2147483647, 1201032874}, {527995520, 2147483647, 1215591224}, {1154582780, 2147483647, 193267031}, {1321286464, 2147483647, 95844396}, {2147483645, 2147483647, 1073741823}, {2147483646, 2147483647, 2147483646}};
    for (int[] cs : goodCases) assertEquals(cs[2], Library.reciprocalMod(cs[0], cs[1]));
    int[][] badCases = {{Integer.MIN_VALUE, Integer.MIN_VALUE}, {-1, -1}, {0, -1}, {-1, 0}, {0, 0}, {1, 1}, {3, 2}, {Integer.MAX_VALUE, 1}, {2, 4}, {2, 6}, {3, 6}, {44100, 48000}, {77, 2147483646}, {30783, 2147483646}};
    for (int[] cs : badCases) {
        try {
            Library.reciprocalMod(cs[0], cs[1]);
            Assert.fail();
        } catch (IllegalArgumentException e) {
        }
    }
}
METHOD_INFO:

@Test()
public void testReciprocalModRandomly() {
    final int trials = 100000;
    for (int i = 0; i < trials; i++) {
        int mod = rand.nextInt() >>> 1;
        if (mod < 2) continue;
        int x = rand.nextInt(mod);
        if (Library.gcd(x, mod) == 1) {
            int y = Library.reciprocalMod(x, mod);
            assertTrue(1 <= y && y < mod);
            assertEquals(1, (long)x * y % mod);
            assertEquals(x, Library.reciprocalMod(y, mod));
        } else {
            try {
                Library.reciprocalMod(x, mod);
                Assert.fail();
            } catch (IllegalArgumentException e) {
            }
        }
    }
}
METHOD_INFO:

@Test()
public void testFactorial() {
    assertEquals(new BigInteger("1"), Library.factorial(0));
    assertEquals(new BigInteger("1"), Library.factorial(1));
    assertEquals(new BigInteger("2"), Library.factorial(2));
    assertEquals(new BigInteger("6"), Library.factorial(3));
    assertEquals(new BigInteger("24"), Library.factorial(4));
    assertEquals(new BigInteger("120"), Library.factorial(5));
    assertEquals(new BigInteger("720"), Library.factorial(6));
    assertEquals(new BigInteger("6227020800"), Library.factorial(13));
    assertEquals(new BigInteger("51090942171709440000"), Library.factorial(21));
    assertEquals(new BigInteger("265252859812191058636308480000000"), Library.factorial(30));
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testFactorialInvalid0() {
    Library.factorial(-1);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testFactorialInvalid1() {
    Library.factorial(-563);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testFactorialInvalid2() {
    Library.factorial(Integer.MIN_VALUE);
}
METHOD_INFO:

@Test()
public void testBinomial() {
    assertEquals(new BigInteger("1"), Library.binomial(0, 0));
    assertEquals(new BigInteger("1"), Library.binomial(1, 0));
    assertEquals(new BigInteger("1"), Library.binomial(1, 1));
    assertEquals(new BigInteger("1"), Library.binomial(2, 0));
    assertEquals(new BigInteger("2"), Library.binomial(2, 1));
    assertEquals(new BigInteger("1"), Library.binomial(2, 2));
    assertEquals(new BigInteger("1"), Library.binomial(3, 0));
    assertEquals(new BigInteger("3"), Library.binomial(3, 1));
    assertEquals(new BigInteger("3"), Library.binomial(3, 2));
    assertEquals(new BigInteger("1"), Library.binomial(3, 3));
    assertEquals(new BigInteger("35"), Library.binomial(7, 4));
    assertEquals(new BigInteger("120"), Library.binomial(10, 7));
    assertEquals(new BigInteger("21"), Library.binomial(21, 20));
    assertEquals(new BigInteger("88749815264600"), Library.binomial(50, 28));
}
METHOD_INFO:

@Test()
public void testGcd() {
    assertEquals(0, Library.gcd(0, 0));
    assertEquals(1, Library.gcd(0, 1));
    assertEquals(1, Library.gcd(1, 0));
    assertEquals(6, Library.gcd(0, 6));
    assertEquals(6, Library.gcd(6, 0));
    assertEquals(1, Library.gcd(1, 1));
    assertEquals(2, Library.gcd(2, 2));
    assertEquals(1, Library.gcd(2, 3));
    assertEquals(1, Library.gcd(10, 3));
    assertEquals(3, Library.gcd(9, 3));
    assertEquals(2, Library.gcd(6, 4));
    assertEquals(2, Library.gcd(18, 14));
    assertEquals(300, Library.gcd(44100, 48000));
    assertEquals(2147483647, Library.gcd(0, 2147483647));
    assertEquals(2147483647, Library.gcd(2147483647, 2147483647));
    assertEquals(1, Library.gcd(2147483646, 2147483647));
}
METHOD_INFO:

@Test()
public void testGcdRandomly() {
    final int trials = 1000000;
    for (int i = 0; i < trials; i++) {
        int x = rand.nextInt() >>> 1;
        int y = rand.nextInt() >>> 1;
        int z = Library.gcd(x, y);
        if (x == 0) assertEquals(y, z); else if (y == 0) assertEquals(x, z); else assertTrue(0 < z && z <= x && z <= y && x % z == 0 && y % z == 0);
    }
}
METHOD_INFO:

@Test()
public void testIsPrime() {
    assertFalse(Library.isPrime(0));
    assertFalse(Library.isPrime(1));
    assertTrue(Library.isPrime(2));
    assertTrue(Library.isPrime(3));
    assertFalse(Library.isPrime(4));
    assertTrue(Library.isPrime(5));
    assertFalse(Library.isPrime(6));
    assertTrue(Library.isPrime(7));
    assertFalse(Library.isPrime(8));
    assertFalse(Library.isPrime(9));
    assertFalse(Library.isPrime(10));
    assertTrue(Library.isPrime(11));
    assertFalse(Library.isPrime(12));
    assertTrue(Library.isPrime(13));
    assertFalse(Library.isPrime(14));
    assertFalse(Library.isPrime(15));
    assertFalse(Library.isPrime(16));
    assertTrue(Library.isPrime(17));
    assertFalse(Library.isPrime(18));
    assertTrue(Library.isPrime(19));
    assertFalse(Library.isPrime(20));
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testIsPrimeInvalid0() {
    Library.isPrime(-1);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testIsPrimeInvalid1() {
    Library.isPrime(-3000);
}
METHOD_INFO:

@Test()
public void testListPrimality() {
    boolean[] isPrime = Library.listPrimality(1000);
    for (int i = 0; i < isPrime.length; i++) assertEquals(Library.isPrime(i), isPrime[i]);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testListPrimalityInvalid0() {
    Library.listPrimality(-1);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testListPrimalityInvalid1() {
    Library.listPrimality(-3000);
}
METHOD_INFO:

@Test()
public void testListPrimes() {
    int limit = 1000;
    int[] primes = Library.listPrimes(limit);
    for (int i = 0; i < primes.length - 1; i++) assertTrue(primes[i] < primes[i + 1]);
    for (int i = 0; i <= limit; i++) assertEquals(Library.isPrime(i), Arrays.binarySearch(primes, i) >= 0);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testListPrimesInvalid0() {
    Library.listPrimes(-1);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testListPrimesInvalid1() {
    Library.listPrimes(-3000);
}
METHOD_INFO:

@Test()
public void testTotient() {
    assertEquals(1, Library.totient(1));
    assertEquals(1, Library.totient(2));
    assertEquals(2, Library.totient(3));
    assertEquals(2, Library.totient(4));
    assertEquals(4, Library.totient(5));
    assertEquals(2, Library.totient(6));
    assertEquals(6, Library.totient(7));
    assertEquals(4, Library.totient(8));
    assertEquals(6, Library.totient(9));
    assertEquals(4, Library.totient(10));
    assertEquals(10, Library.totient(11));
    assertEquals(4, Library.totient(12));
    assertEquals(12, Library.totient(13));
    assertEquals(6, Library.totient(14));
    assertEquals(8, Library.totient(15));
    assertEquals(8, Library.totient(16));
    assertEquals(16, Library.totient(17));
    assertEquals(6, Library.totient(18));
    assertEquals(18, Library.totient(19));
    assertEquals(8, Library.totient(20));
}
METHOD_INFO:

@Test()
public void testTotientRandomly() {
    final int trials = 100;
    for (int i = 0; i < trials; i++) {
        int n = rand.nextInt(100000) + 1;
        int tot = 0;
        for (int j = 1; j <= n; j++) {
            if (Library.gcd(j, n) == 1) tot++;
        }
        assertEquals(tot, Library.totient(n));
    }
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testTotientInvalid0() {
    Library.totient(-1);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testTotientInvalid1() {
    Library.totient(-3000);
}
METHOD_INFO:

@Test()
public void testListTotients() {
    int[] totients = Library.listTotients(1000);
    for (int i = 1; i < totients.length; i++) assertEquals(Library.totient(i), totients[i]);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testListTotientsInvalid0() {
    Library.listTotients(-1);
}
METHOD_INFO:

@Test(expected = IllegalArgumentException.class)
public void testListTotientsInvalid1() {
    Library.listTotients(-3000);
}
METHOD_INFO:

@Test()
public void testNextPermutation() {
    int[] arr;
    assertFalse(Library.nextPermutation(new int[0]));
    arr = new int[]{0, 0, 1};
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{0, 1, 0}, arr);
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 0, 0}, arr);
    assertFalse(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 0, 0}, arr);
    arr = new int[]{1, 2, 3, 5, 9};
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 2, 3, 9, 5}, arr);
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 2, 5, 3, 9}, arr);
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 2, 5, 9, 3}, arr);
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 2, 9, 3, 5}, arr);
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 2, 9, 5, 3}, arr);
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 3, 2, 5, 9}, arr);
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 3, 2, 9, 5}, arr);
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 3, 5, 2, 9}, arr);
    assertTrue(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{1, 3, 5, 9, 2}, arr);
    for (int i = 0; i < 110; i++) assertTrue(Library.nextPermutation(arr));
    assertFalse(Library.nextPermutation(arr));
    assertArrayEquals(new int[]{9, 5, 3, 2, 1}, arr);
}
AFTER ANALYZE
null
null
null
Visiting class
p001
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p001().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (int i = 0; i < 1000; i++) {
        if (i % 3 == 0 || i % 5 == 0) sum += i;
    }
    return Integer.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p002
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p002().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    int x = 1;
    int y = 2;
    while (x <= 4000000) {
        if (x % 2 == 0) sum += x;
        int z = x + y;
        x = y;
        y = z;
    }
    return Integer.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p003
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p003().run());
}
METHOD_INFO:

public String run() {
    long n = 600851475143L;
    while (true) {
        long p = smallestFactor(n);
        if (p < n) n /= p; else return Long.toString(n);
    }
}
METHOD_INFO:

private static long smallestFactor(long n) {
    if (n <= 1) throw new IllegalArgumentException();
    for (long i = 2, end = Library.sqrt(n); i <= end; i++) {
        if (n % i == 0) return i;
    }
    return n;
}
AFTER ANALYZE
null
null
null
Visiting class
p004
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p004().run());
}
METHOD_INFO:

public String run() {
    int maxPalin = -1;
    for (int i = 100; i < 1000; i++) {
        for (int j = 100; j < 1000; j++) {
            int prod = i * j;
            if (Library.isPalindrome(prod) && prod > maxPalin) maxPalin = prod;
        }
    }
    return Integer.toString(maxPalin);
}
AFTER ANALYZE
null
null
null
Visiting class
p005
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p005().run());
}
METHOD_INFO:

public String run() {
    BigInteger allLcm = BigInteger.ONE;
    for (int i = 1; i <= 20; i++) allLcm = lcm(BigInteger.valueOf(i), allLcm);
    return allLcm.toString();
}
METHOD_INFO:

private static BigInteger lcm(BigInteger x, BigInteger y) {
    return x.divide(x.gcd(y)).multiply(y);
}
AFTER ANALYZE
null
null
null
Visiting class
p006
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p006().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    int sum2 = 0;
    for (int i = 1; i <= N; i++) {
        sum += i;
        sum2 += i * i;
    }
    return Integer.toString(sum * sum - sum2);
}
AFTER ANALYZE
null
null
null
Visiting class
p007
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p007().run());
}
METHOD_INFO:

public String run() {
    for (int i = 2, count = 0; ; i++) {
        if (Library.isPrime(i)) {
            count++;
            if (count == 10001) return Integer.toString(i);
        }
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p008
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p008().run());
}
METHOD_INFO:

public String run() {
    long maxProd = -1;
    for (int i = 0; i + ADJACENT <= NUMBER.length(); i++) {
        long prod = 1;
        for (int j = 0; j < ADJACENT; j++) prod *= NUMBER.charAt(i + j) - '0';
        maxProd = Math.max(prod, maxProd);
    }
    return Long.toString(maxProd);
}
AFTER ANALYZE
null
null
null
Visiting class
p009
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p009().run());
}
METHOD_INFO:

public String run() {
    for (int a = 1; a < PERIMETER; a++) {
        for (int b = a + 1; b < PERIMETER; b++) {
            int c = PERIMETER - a - b;
            if (a * a + b * b == c * c) {
                return Integer.toString(a * b * c);
            }
        }
    }
    throw new AssertionError("Not found");
}
AFTER ANALYZE
null
null
null
Visiting class
p010
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p010().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    for (int p : Library.listPrimes(LIMIT - 1)) sum += p;
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p011
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p011().run());
}
METHOD_INFO:

public String run() {
    int max = -1;
    for (int y = 0; y < SQUARE.length; y++) {
        for (int x = 0; x < SQUARE[y].length; x++) {
            max = Math.max(product(x, y, 1, 0, CONSECUTIVE), max);
            max = Math.max(product(x, y, 0, 1, CONSECUTIVE), max);
            max = Math.max(product(x, y, 1, 1, CONSECUTIVE), max);
            max = Math.max(product(x, y, 1, -1, CONSECUTIVE), max);
        }
    }
    return Integer.toString(max);
}
METHOD_INFO:

private static int product(int x, int y, int dx, int dy, int n) {
    if (!isInBounds(x + (n - 1) * dx, y + (n - 1) * dy)) return -1;
    int prod = 1;
    for (int i = 0; i < n; i++, x += dx, y += dy) prod *= SQUARE[y][x];
    return prod;
}
METHOD_INFO:

private static boolean isInBounds(int x, int y) {
    return 0 <= y && y < SQUARE.length && 0 <= x && x < SQUARE[y].length;
}
AFTER ANALYZE
null
null
null
Visiting class
p012
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p012().run());
}
METHOD_INFO:

public String run() {
    int triangle = 0;
    for (int i = 1; ; i++) {
        if (Integer.MAX_VALUE - triangle < i) throw new ArithmeticException("Overflow");
        triangle += i;
        if (countDivisors(triangle) > 500) return Integer.toString(triangle);
    }
}
METHOD_INFO:

private static int countDivisors(int n) {
    int count = 0;
    int end = Library.sqrt(n);
    for (int i = 1; i < end; i++) {
        if (n % i == 0) count += 2;
    }
    if (end * end == n) count++;
    return count;
}
AFTER ANALYZE
null
null
null
Visiting class
p013
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p013().run());
}
METHOD_INFO:

public String run() {
    BigInteger sum = BigInteger.ZERO;
    for (String num : NUMBERS) sum = sum.add(new BigInteger(num));
    return sum.toString().substring(0, 10);
}
AFTER ANALYZE
null
null
null
Visiting class
p014
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p014().run());
}
METHOD_INFO:

public String run() {
    int maxArg = -1;
    int maxChain = 0;
    for (int i = 1; i < LIMIT; i++) {
        int chainLen = collatzChainLength(BigInteger.valueOf(i));
        if (chainLen > maxChain) {
            maxArg = i;
            maxChain = chainLen;
        }
    }
    return Integer.toString(maxArg);
}
METHOD_INFO:

private int collatzChainLength(BigInteger n) {
    if (n.signum() < 0) throw new IllegalArgumentException();
    if (n.compareTo(CACHE_SIZE) >= 0) return collatzChainLengthDirect(n);
    int index = n.intValue();
    if (collatzChainLength[index] == 0) collatzChainLength[index] = collatzChainLengthDirect(n);
    return collatzChainLength[index];
}
METHOD_INFO:

private int collatzChainLengthDirect(BigInteger n) {
    if (n.equals(BigInteger.ONE)) return 1; else if (!n.testBit(0)) return collatzChainLength(n.shiftRight(1)) + 1; else return collatzChainLength(n.multiply(BigInteger.valueOf(3)).add(BigInteger.ONE)) + 1;
}
AFTER ANALYZE
null
null
null
Visiting class
p015
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p015().run());
}
METHOD_INFO:

public String run() {
    return Library.binomial(40, 20).toString();
}
AFTER ANALYZE
null
null
null
Visiting class
p016
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p016().run());
}
METHOD_INFO:

public String run() {
    String temp = BigInteger.ONE.shiftLeft(1000).toString();
    int sum = 0;
    for (int i = 0; i < temp.length(); i++) sum += temp.charAt(i) - '0';
    return Integer.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p017
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p017().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (int i = 1; i <= 1000; i++) sum += toEnglish(i).length();
    return Integer.toString(sum);
}
METHOD_INFO:

private static String toEnglish(int n) {
    if (0 <= n && n < 20) return ONES[n]; else if (20 <= n && n < 100) return TENS[n / 10] + (n % 10 != 0 ? ONES[n % 10] : ""); else if (100 <= n && n < 1000) return ONES[n / 100] + "hundred" + (n % 100 != 0 ? "and" + toEnglish(n % 100) : ""); else if (1000 <= n && n < 1000000) return toEnglish(n / 1000) + "thousand" + (n % 1000 != 0 ? toEnglish(n % 1000) : ""); else throw new IllegalArgumentException();
}
AFTER ANALYZE
null
null
null
Visiting class
p018
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p018().run());
}
METHOD_INFO:

public String run() {
    for (int i = triangle.length - 2; i >= 0; i--) {
        for (int j = 0; j < triangle[i].length; j++) triangle[i][j] += Math.max(triangle[i + 1][j], triangle[i + 1][j + 1]);
    }
    return Integer.toString(triangle[0][0]);
}
AFTER ANALYZE
null
null
null
Visiting class
p019
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p019().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int y = 1901; y <= 2000; y++) {
        for (int m = 1; m <= 12; m++) {
            if (dayOfWeek(y, m, 1) == 0) count++;
        }
    }
    return Integer.toString(count);
}
METHOD_INFO:

private static int dayOfWeek(int year, int month, int day) {
    if (year < 0 || year > 10000 || month < 1 || month > 12 || day < 1 || day > 31) throw new IllegalArgumentException();
    int m = (month - 3 + 4800) % 4800;
    int y = (year + m / 12) % 400;
    m %= 12;
    return (y + y / 4 - y / 100 + (13 * m + 2) / 5 + day + 2) % 7;
}
AFTER ANALYZE
null
null
null
Visiting class
p020
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p020().run());
}
METHOD_INFO:

public String run() {
    String temp = Library.factorial(100).toString();
    int sum = 0;
    for (int i = 0; i < temp.length(); i++) sum += temp.charAt(i) - '0';
    return Integer.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p021
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p021().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (int i = 1; i < 10000; i++) {
        if (isAmicable(i)) sum += i;
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static boolean isAmicable(int n) {
    int m = divisorSum(n);
    return m != n && divisorSum(m) == n;
}
METHOD_INFO:

private static int divisorSum(int n) {
    int sum = 0;
    for (int i = 1; i < n; i++) {
        if (n % i == 0) sum += i;
    }
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p022
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p022().run());
}
METHOD_INFO:

public String run() {
    Arrays.sort(names);
    long sum = 0;
    for (int i = 0; i < names.length; i++) {
        int value = 0;
        for (int j = 0; j < names[i].length(); j++) value += names[i].charAt(j) - 'A' + 1;
        sum += value * (i + 1);
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p023
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p023().run());
}
METHOD_INFO:

public String run() {
    for (int i = 1; i < isAbundant.length; i++) isAbundant[i] = isAbundant(i);
    int sum = 0;
    for (int i = 1; i <= LIMIT; i++) {
        if (!isSumOf2Abundants(i)) sum += i;
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private boolean isSumOf2Abundants(int n) {
    for (int i = 0; i <= n; i++) {
        if (isAbundant[i] && isAbundant[n - i]) return true;
    }
    return false;
}
METHOD_INFO:

private static boolean isAbundant(int n) {
    if (n < 1) throw new IllegalArgumentException();
    int sum = 1;
    int end = Library.sqrt(n);
    for (int i = 2; i <= end; i++) {
        if (n % i == 0) sum += i + n / i;
    }
    if (end * end == n) sum -= end;
    return sum > n;
}
AFTER ANALYZE
null
null
null
Visiting class
p024
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p024().run());
}
METHOD_INFO:

public String run() {
    int[] array = new int[10];
    for (int i = 0; i < array.length; i++) array[i] = i;
    for (int i = 0; i < 999999; i++) {
        if (!Library.nextPermutation(array)) throw new AssertionError();
    }
    String ans = "";
    for (int i = 0; i < array.length; i++) ans += array[i];
    return ans;
}
AFTER ANALYZE
null
null
null
Visiting class
p025
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p025().run());
}
METHOD_INFO:

public String run() {
    BigInteger lowerThres = BigInteger.TEN.pow(DIGITS - 1);
    BigInteger upperThres = BigInteger.TEN.pow(DIGITS);
    BigInteger prev = BigInteger.ONE;
    BigInteger cur = BigInteger.ZERO;
    for (int i = 0; ; i++) {
        if (cur.compareTo(upperThres) >= 0) throw new RuntimeException("Not found"); else if (cur.compareTo(lowerThres) >= 0) return Integer.toString(i);
        BigInteger temp = cur.add(prev);
        prev = cur;
        cur = temp;
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p026
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p026().run());
}
METHOD_INFO:

public String run() {
    int bestNumber = 0;
    int bestLength = 0;
    for (int i = 1; i <= 1000; i++) {
        int len = getCycleLength(i);
        if (len > bestLength) {
            bestNumber = i;
            bestLength = len;
        }
    }
    return Integer.toString(bestNumber);
}
METHOD_INFO:

private static int getCycleLength(int n) {
    Map<Integer, Integer> stateToIter = new HashMap<>();
    int state = 1;
    for (int iter = 0; ; iter++) {
        if (stateToIter.containsKey(state)) return iter - stateToIter.get(state); else {
            stateToIter.put(state, iter);
            state = state * 10 % n;
        }
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p027
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p027().run());
}
METHOD_INFO:

public String run() {
    int bestNum = 0;
    int bestA = 0;
    int bestB = 0;
    for (int a = -1000; a <= 1000; a++) {
        for (int b = -1000; b <= 1000; b++) {
            int num = numberOfConsecutivePrimesGenerated(a, b);
            if (num > bestNum) {
                bestNum = num;
                bestA = a;
                bestB = b;
            }
        }
    }
    return Integer.toString(bestA * bestB);
}
METHOD_INFO:

private static int numberOfConsecutivePrimesGenerated(int a, int b) {
    for (int i = 0; ; i++) {
        int n = i * i + i * a + b;
        if (n < 0 || !Library.isPrime(n)) return i;
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p028
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p028().run());
}
METHOD_INFO:

public String run() {
    long sum = 1;
    for (int n = 3; n <= SIZE; n += 2) sum += 4 * n * n - 6 * (n - 1);
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p029
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p029().run());
}
METHOD_INFO:

public String run() {
    Set<BigInteger> generated = new HashSet<>();
    for (int a = 2; a <= 100; a++) {
        for (int b = 2; b <= 100; b++) generated.add(BigInteger.valueOf(a).pow(b));
    }
    return Integer.toString(generated.size());
}
AFTER ANALYZE
null
null
null
Visiting class
p030
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p030().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (int i = 2; i < 1000000; i++) {
        if (i == fifthPowerDigitSum(i)) sum += i;
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static int fifthPowerDigitSum(int x) {
    int sum = 0;
    while (x != 0) {
        int y = x % 10;
        sum += y * y * y * y * y;
        x /= 10;
    }
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p031
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p031().run());
}
METHOD_INFO:

public String run() {
    int[][] ways = new int[COINS.length + 1][TOTAL + 1];
    ways[0][0] = 1;
    for (int i = 0; i < COINS.length; i++) {
        int coin = COINS[i];
        for (int j = 0; j <= TOTAL; j++) ways[i + 1][j] = ways[i][j] + (j >= coin ? ways[i + 1][j - coin] : 0);
    }
    return Integer.toString(ways[COINS.length][TOTAL]);
}
AFTER ANALYZE
null
null
null
Visiting class
p032
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p032().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (int i = 1; i < 10000; i++) {
        if (hasPandigitalProduct(i)) sum += i;
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static boolean hasPandigitalProduct(int n) {
    for (int i = 1; i <= n; i++) {
        if (n % i == 0 && isPandigital("" + n + i + n / i)) return true;
    }
    return false;
}
METHOD_INFO:

private static boolean isPandigital(String s) {
    if (s.length() != 9) return false;
    char[] temp = s.toCharArray();
    Arrays.sort(temp);
    return new String(temp).equals("123456789");
}
AFTER ANALYZE
null
null
null
Visiting class
p033
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p033().run());
}
METHOD_INFO:

public String run() {
    int numer = 1;
    int denom = 1;
    for (int d = 10; d < 100; d++) {
        for (int n = 10; n < d; n++) {
            int n0 = n % 10;
            int n1 = n / 10;
            int d0 = d % 10;
            int d1 = d / 10;
            if (n1 == d0 && n0 * d == n * d1 || n0 == d1 && n1 * d == n * d0) {
                numer *= n;
                denom *= d;
            }
        }
    }
    return Integer.toString(denom / Library.gcd(numer, denom));
}
AFTER ANALYZE
null
null
null
Visiting class
p034
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p034().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (int i = 3; i < 10000000; i++) {
        if (i == factorialDigitSum(i)) sum += i;
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static int factorialDigitSum(int x) {
    int sum = 0;
    while (x != 0) {
        sum += FACTORIAL[x % 10];
        x /= 10;
    }
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p035
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p035().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int i = 0; i < isPrime.length; i++) {
        if (isCircularPrime(i)) count++;
    }
    return Integer.toString(count);
}
METHOD_INFO:

private boolean isCircularPrime(int n) {
    String s = Integer.toString(n);
    for (int i = 0; i < s.length(); i++) {
        if (!isPrime[Integer.parseInt(s.substring(i) + s.substring(0, i))]) return false;
    }
    return true;
}
AFTER ANALYZE
null
null
null
Visiting class
p036
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p036().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    for (int i = 1; i < 1000000; i++) {
        if (Library.isPalindrome(Integer.toString(i, 10)) && Library.isPalindrome(Integer.toString(i, 2))) sum += i;
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p037
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p037().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    for (int count = 0, n = 10; count < 11; n++) {
        if (isTruncatablePrime(n)) {
            sum += n;
            count++;
        }
    }
    return Long.toString(sum);
}
METHOD_INFO:

private static boolean isTruncatablePrime(int n) {
    for (long i = 10; i <= n; i *= 10) {
        if (!Library.isPrime(n % (int)i)) return false;
    }
    for (; n != 0; n /= 10) {
        if (!Library.isPrime(n)) return false;
    }
    return true;
}
AFTER ANALYZE
null
null
null
Visiting class
p038
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p038().run());
}
METHOD_INFO:

public String run() {
    int max = -1;
    for (int n = 2; n <= 9; n++) {
        for (int i = 1; i < Library.pow(10, 9 / n); i++) {
            String concat = "";
            for (int j = 1; j <= n; j++) concat += i * j;
            if (isPandigital(concat)) max = Math.max(Integer.parseInt(concat), max);
        }
    }
    return Integer.toString(max);
}
METHOD_INFO:

private static boolean isPandigital(String s) {
    if (s.length() != 9) return false;
    char[] temp = s.toCharArray();
    Arrays.sort(temp);
    return new String(temp).equals("123456789");
}
AFTER ANALYZE
null
null
null
Visiting class
p039
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p039().run());
}
METHOD_INFO:

public String run() {
    int maxPerimeter = 0;
    int maxTriangles = 0;
    for (int p = 1; p <= 1000; p++) {
        int triangles = countSolutions(p);
        if (triangles > maxTriangles) {
            maxTriangles = triangles;
            maxPerimeter = p;
        }
    }
    return Integer.toString(maxPerimeter);
}
METHOD_INFO:

private static int countSolutions(int p) {
    int count = 0;
    for (int a = 1; a <= p; a++) {
        for (int b = a; b <= p; b++) {
            int c = p - a - b;
            if (b <= c && a * a + b * b == c * c) count++;
        }
    }
    return count;
}
AFTER ANALYZE
null
null
null
Visiting class
p040
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p040().run());
}
METHOD_INFO:

public String run() {
    StringBuilder sb = new StringBuilder();
    for (int i = 1; i < 1000000; i++) sb.append(i);
    int prod = 1;
    for (int i = 0; i <= 6; i++) prod *= sb.charAt(Library.pow(10, i) - 1) - '0';
    return Integer.toString(prod);
}
AFTER ANALYZE
null
null
null
Visiting class
p041
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p041().run());
}
METHOD_INFO:

public String run() {
    for (int n = 9; n >= 1; n--) {
        int[] digits = new int[n];
        for (int i = 0; i < digits.length; i++) digits[i] = i + 1;
        int result = -1;
        do {
            if (Library.isPrime(toInteger(digits))) result = toInteger(digits);
        }         while (Library.nextPermutation(digits));
        if (result != -1) return Integer.toString(result);
    }
    throw new RuntimeException("Not found");
}
METHOD_INFO:

private static int toInteger(int[] digits) {
    int result = 0;
    for (int x : digits) result = result * 10 + x;
    return result;
}
AFTER ANALYZE
null
null
null
Visiting class
p042
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p042().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (String word : WORDS) {
        if (isTriangularNumber(wordValue(word))) count++;
    }
    return Integer.toString(count);
}
METHOD_INFO:

private static boolean isTriangularNumber(int x) {
    for (int i = 1; ; i++) {
        int t = i * (i + 1) / 2;
        if (t == x) return true;
        if (t > x) return false;
    }
}
METHOD_INFO:

private static int wordValue(String s) {
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c < 'A' || c > 'Z') throw new IllegalArgumentException();
        sum += c - 'A' + 1;
    }
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p043
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p043().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    int[] digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    outer: do {
        for (int i = 0; i < DIVISIBILITY_TESTS.length; i++) {
            if (toInteger(digits, i + 1, 3) % DIVISIBILITY_TESTS[i] != 0) continue outer;
        }
        sum += toInteger(digits, 0, digits.length);
    }     while (Library.nextPermutation(digits));
    return Long.toString(sum);
}
METHOD_INFO:

private static long toInteger(int[] digits, int off, int len) {
    long result = 0;
    for (int i = off; i < off + len; i++) result = result * 10 + digits[i];
    return result;
}
AFTER ANALYZE
null
null
null
Visiting class
p044
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p044().run());
}
METHOD_INFO:

public String run() {
    long minD = -1;
    for (int i = 2; ; i++) {
        long pentI = pentagonalNumber(i);
        if (minD != -1 && pentI - pentagonalNumber(i - 1) >= minD) break;
        for (int j = i - 1; j >= 1; j--) {
            long pentJ = pentagonalNumber(j);
            long diff = pentI - pentJ;
            if (minD != -1 && diff >= minD) break; else if (isPentagonalNumber(pentI + pentJ) && isPentagonalNumber(diff)) minD = diff;
        }
    }
    return Long.toString(minD);
}
METHOD_INFO:

private static long pentagonalNumber(int x) {
    if (x <= 0) throw new IllegalArgumentException();
    return (long)x * (x * 3 - 1) >>> 1;
}
METHOD_INFO:

private static boolean isPentagonalNumber(long y) {
    if (y <= 0) return false;
    long temp = y * 24 + 1;
    long sqrt = Library.sqrt(temp);
    return sqrt * sqrt == temp && sqrt % 6 == 5;
}
AFTER ANALYZE
null
null
null
Visiting class
p045
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p045().run());
}
METHOD_INFO:

public String run() {
    int i = 286;
    int j = 166;
    int k = 144;
    while (true) {
        long triangle = (long)i * (i + 1) / 2;
        long pentagon = (long)j * (j * 3 - 1) / 2;
        long hexagon = (long)k * (k * 2 - 1);
        long min = Math.min(Math.min(triangle, pentagon), hexagon);
        if (min == triangle && min == pentagon && min == hexagon) return Long.toString(min);
        if (min == triangle) i++;
        if (min == pentagon) j++;
        if (min == hexagon) k++;
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p046
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p046().run());
}
METHOD_INFO:

public String run() {
    for (int i = 9; ; i += 2) {
        if (!satisfiesConjecture(i)) return Integer.toString(i);
    }
}
METHOD_INFO:

private static boolean satisfiesConjecture(int n) {
    if (n % 2 == 0 || Library.isPrime(n)) return true;
    for (int i = 1; i * i * 2 <= n; i++) {
        if (Library.isPrime(n - i * i * 2)) return true;
    }
    return false;
}
AFTER ANALYZE
null
null
null
Visiting class
p047
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p047().run());
}
METHOD_INFO:

public String run() {
    for (int i = 2; ; i++) {
        if (has4PrimeFactors(i + 0) && has4PrimeFactors(i + 1) && has4PrimeFactors(i + 2) && has4PrimeFactors(i + 3)) return Integer.toString(i);
    }
}
METHOD_INFO:

private static boolean has4PrimeFactors(int n) {
    return countDistinctPrimeFactors(n) == 4;
}
METHOD_INFO:

private static int countDistinctPrimeFactors(int n) {
    int count = 0;
    for (int i = 2, end = Library.sqrt(n); i <= end; i++) {
        if (n % i == 0) {
            do n /= i;             while (n % i == 0);
            count++;
            end = Library.sqrt(n);
        }
    }
    if (n > 1) count++;
    return count;
}
AFTER ANALYZE
null
null
null
Visiting class
p048
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p048().run());
}
METHOD_INFO:

public String run() {
    BigInteger modulus = BigInteger.TEN.pow(10);
    BigInteger sum = BigInteger.ZERO;
    for (int i = 1; i <= 1000; i++) sum = sum.add(BigInteger.valueOf(i).modPow(BigInteger.valueOf(i), modulus));
    return sum.mod(modulus).toString();
}
AFTER ANALYZE
null
null
null
Visiting class
p049
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p049().run());
}
METHOD_INFO:

public String run() {
    boolean[] isPrime = Library.listPrimality(LIMIT - 1);
    for (int base = 1000; base < LIMIT; base++) {
        if (isPrime[base]) {
            for (int step = 1; step < LIMIT; step++) {
                int a = base + step;
                int b = a + step;
                if (a < LIMIT && isPrime[a] && hasSameDigits(a, base) && b < LIMIT && isPrime[b] && hasSameDigits(b, base) && (base != 1487 || a != 4817)) return "" + base + a + b;
            }
        }
    }
    throw new RuntimeException("Not found");
}
METHOD_INFO:

private static boolean hasSameDigits(int x, int y) {
    char[] xdigits = Integer.toString(x).toCharArray();
    char[] ydigits = Integer.toString(y).toCharArray();
    Arrays.sort(xdigits);
    Arrays.sort(ydigits);
    return Arrays.equals(xdigits, ydigits);
}
AFTER ANALYZE
null
null
null
Visiting class
p050
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p050().run());
}
METHOD_INFO:

public String run() {
    boolean[] isPrime = Library.listPrimality(LIMIT);
    int[] primes = Library.listPrimes(LIMIT);
    long maxSum = 0;
    int maxRun = -1;
    for (int i = 0; i < primes.length; i++) {
        int sum = 0;
        for (int j = i; j < primes.length; j++) {
            sum += primes[j];
            if (sum > LIMIT) break; else if (j - i > maxRun && sum > maxSum && isPrime[sum]) {
                maxSum = sum;
                maxRun = j - i;
            }
        }
    }
    return Long.toString(maxSum);
}
AFTER ANALYZE
null
null
null
Visiting class
p051
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p051().run());
}
METHOD_INFO:

public String run() {
    boolean[] isPrime = Library.listPrimality(1000000);
    for (int i = 0; i < isPrime.length; i++) {
        if (!isPrime[i]) continue;
        int[] n = toDigits(i);
        for (int mask = 0; mask < (1 << n.length); mask++) {
            int[] digits = doMask(n, mask);
            int count = 0;
            for (int j = 0; j < 10; j++) {
                if (digits[0] != 0 && isPrime[toNumber(digits)]) count++;
                digits = addMask(digits, mask);
            }
            if (count == 8) {
                digits = doMask(n, mask);
                for (int j = 0; j < 10; j++) {
                    if (digits[0] != 0 && isPrime[toNumber(digits)]) return Integer.toString(toNumber(digits));
                    digits = addMask(digits, mask);
                }
            }
        }
    }
    throw new RuntimeException("Not found");
}
METHOD_INFO:

private static int[] toDigits(int n) {
    int[] buf = new int[10];
    int i = buf.length;
    do {
        i--;
        buf[i] = n % 10;
        n /= 10;
    }     while (n != 0);
    return Arrays.copyOfRange(buf, i, buf.length);
}
METHOD_INFO:

private static int[] doMask(int[] digits, int mask) {
    int[] result = new int[digits.length];
    for (int i = 0; i < digits.length; i++) result[i] = digits[i] * (~mask >>> i & 1);
    return result;
}
METHOD_INFO:

private static int[] addMask(int[] digits, int mask) {
    int[] result = new int[digits.length];
    for (int i = 0; i < digits.length; i++) result[i] = digits[i] + (mask >>> i & 1);
    return result;
}
METHOD_INFO:

private static int toNumber(int[] digits) {
    int result = 0;
    for (int x : digits) result = result * 10 + x;
    return result;
}
AFTER ANALYZE
null
null
null
Visiting class
p052
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p052().run());
}
METHOD_INFO:

public String run() {
    outer: for (int i = 1; ; i++) {
        for (int j = 2; j < 6; j++) {
            if (!hasSameDigits(i * j, i * (j + 1))) continue outer;
        }
        return Integer.toString(i);
    }
}
METHOD_INFO:

private static boolean hasSameDigits(int x, int y) {
    char[] xdigits = Integer.toString(x).toCharArray();
    char[] ydigits = Integer.toString(y).toCharArray();
    Arrays.sort(xdigits);
    Arrays.sort(ydigits);
    return Arrays.equals(xdigits, ydigits);
}
AFTER ANALYZE
null
null
null
Visiting class
p053
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p053().run());
}
METHOD_INFO:

public String run() {
    BigInteger MILLION = BigInteger.TEN.pow(6);
    int count = 0;
    for (int n = 1; n <= 100; n++) {
        for (int r = 0; r <= n; r++) {
            if (Library.binomial(n, r).compareTo(MILLION) > 0) count++;
        }
    }
    return Integer.toString(count);
}
AFTER ANALYZE
null
null
null
Visiting class
p054
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p054().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (String hand : HANDS) {
        String[] cards = hand.split(" ");
        if (cards.length != 10) throw new AssertionError();
        Card[] player1 = new Card[5];
        Card[] player2 = new Card[5];
        for (int i = 0; i < 5; i++) {
            player1[i] = new Card(cards[i + 0]);
            player2[i] = new Card(cards[i + 5]);
        }
        if (getScore(player1) > getScore(player2)) count++;
    }
    return Integer.toString(count);
}
METHOD_INFO:

private static int getScore(Card[] hand) {
    if (hand.length != 5) throw new IllegalArgumentException();
    int[] rankCounts = new int[13];
    int flushSuit = hand[0].suit;
    for (Card card : hand) {
        rankCounts[card.rank]++;
        if (card.suit != flushSuit) flushSuit = -1;
    }
    int[] rankCountHist = new int[6];
    for (int count : rankCounts) rankCountHist[count]++;
    int bestCards = get5FrequentHighestCards(rankCounts, rankCountHist);
    int straightHighRank = getStraightHighRank(rankCounts);
    if (straightHighRank != -1 && flushSuit != -1) return 8 << 20 | straightHighRank; else if (rankCountHist[4] == 1) return 7 << 20 | bestCards; else if (rankCountHist[3] == 1 && rankCountHist[2] == 1) return 6 << 20 | bestCards; else if (flushSuit != -1) return 5 << 20 | bestCards; else if (straightHighRank != -1) return 4 << 20 | straightHighRank; else if (rankCountHist[3] == 1) return 3 << 20 | bestCards; else if (rankCountHist[2] == 2) return 2 << 20 | bestCards; else if (rankCountHist[2] == 1) return 1 << 20 | bestCards; else return 0 << 20 | bestCards;
}
METHOD_INFO:

private static int get5FrequentHighestCards(int[] ranks, int[] ranksHist) {
    int result = 0;
    int count = 0;
    for (int i = ranksHist.length - 1; i >= 0; i--) {
        for (int j = ranks.length - 1; j >= 0; j--) {
            if (ranks[j] == i) {
                for (int k = 0; k < i && count < 5; k++, count++) result = result << 4 | j;
            }
        }
    }
    if (count != 5) throw new IllegalArgumentException();
    return result;
}
METHOD_INFO:

private static int getStraightHighRank(int[] ranks) {
    outer: for (int i = ranks.length - 1; i >= 3; i--) {
        for (int j = 0; j < 5; j++) {
            if (ranks[(i - j + 13) % 13] == 0) continue outer;
        }
        return i;
    }
    return -1;
}
Visiting class
Card
METHOD_INFO:

public <init>(int rank, int suit) {
    super();
    if (rank < 0 || rank >= 13 || suit < 0 || suit >= 4) throw new IllegalArgumentException();
    this.rank = rank;
    this.suit = suit;
}
METHOD_INFO:

public <init>(String str) {
    this("23456789TJQKA".indexOf(str.charAt(0)), "SHCD".indexOf(str.charAt(1)));
}
METHOD_INFO:

public boolean equals(Object obj) {
    if (!(obj instanceof Card)) return false;
    Card other = (Card)obj;
    return rank == other.rank && suit == other.suit;
}
METHOD_INFO:

public int hashCode() {
    return rank * 4 + suit;
}
AFTER ANALYZE
null
null
null
Visiting class
p055
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p055().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int i = 0; i < 10000; i++) {
        if (isLychrel(i)) count++;
    }
    return Integer.toString(count);
}
METHOD_INFO:

private static boolean isLychrel(int n) {
    BigInteger temp = BigInteger.valueOf(n);
    for (int i = 0; i < 49; i++) {
        temp = temp.add(new BigInteger(Library.reverse(temp.toString())));
        if (Library.isPalindrome(temp.toString())) return false;
    }
    return true;
}
AFTER ANALYZE
null
null
null
Visiting class
p056
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p056().run());
}
METHOD_INFO:

public String run() {
    int max = 0;
    for (int a = 1; a < 100; a++) {
        for (int b = 1; b < 100; b++) {
            BigInteger pow = BigInteger.valueOf(a).pow(b);
            max = Math.max(digitSum(pow), max);
        }
    }
    return Integer.toString(max);
}
METHOD_INFO:

private static int digitSum(BigInteger n) {
    int sum = 0;
    String s = n.toString();
    for (int i = 0; i < s.length(); i++) sum += s.charAt(i) - '0';
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p057
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p057().run());
}
METHOD_INFO:

public String run() {
    BigInteger n = BigInteger.ZERO;
    BigInteger d = BigInteger.ONE;
    int count = 0;
    for (int i = 0; i < 1000; i++) {
        BigInteger temp = d.multiply(BigInteger.valueOf(2)).add(n);
        n = d;
        d = temp;
        if (n.add(d).toString().length() > d.toString().length()) count++;
    }
    return Integer.toString(count);
}
AFTER ANALYZE
null
null
null
Visiting class
p058
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p058().run());
}
METHOD_INFO:

public String run() {
    int numPrimes = 0;
    for (int n = 1; ; n += 2) {
        for (int i = 0; i < 4; i++) {
            if (Library.isPrime(n * n - i * (n - 1))) numPrimes++;
        }
        if (n > 1 && numPrimes * 10 < n * 2 - 1) return Integer.toString(n);
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p059
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p059().run());
}
METHOD_INFO:

public String run() {
    byte[] bestKey = null;
    byte[] bestDecrypted = null;
    double bestScore = Double.NaN;
    for (byte x = 'a'; x <= 'z'; x++) {
        for (byte y = 'a'; y <= 'z'; y++) {
            for (byte z = 'a'; z <= 'z'; z++) {
                byte[] key = {x, y, z};
                byte[] decrypted = decrypt(CIPHERTEXT, key);
                double score = score(decrypted);
                if (bestKey == null || score > bestScore) {
                    bestKey = key;
                    bestDecrypted = decrypted;
                    bestScore = score;
                }
            }
        }
    }
    int sum = 0;
    for (int i = 0; i < bestDecrypted.length; i++) sum += bestDecrypted[i];
    return Integer.toString(sum);
}
METHOD_INFO:

private static double score(byte[] b) {
    double sum = 0;
    for (int i = 0; i < b.length; i++) {
        char c = (char)b[i];
        if (c >= 'A' && c <= 'Z') sum += 1; else if (c >= 'a' && c <= 'z') sum += 2; else if (c < 32 || c == 127) sum -= 10;
    }
    return sum;
}
METHOD_INFO:

private static byte[] decrypt(byte[] ciphertext, byte[] key) {
    byte[] plaintext = new byte[ciphertext.length];
    for (int i = 0; i < ciphertext.length; i++) plaintext[i] = (byte)(ciphertext[i] ^ key[i % key.length]);
    return plaintext;
}
AFTER ANALYZE
null
null
null
Visiting class
p060
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p060().run());
}
METHOD_INFO:

public String run() {
    isConcatPrimeKnown = new BitSet(primes.length * primes.length);
    isConcatPrime = new BitSet(primes.length * primes.length);
    int sumLimit = PRIME_LIMIT;
    while (true) {
        int sum = findSetSum(new int[]{}, 5, sumLimit - 1);
        if (sum == -1) return Integer.toString(sumLimit);
        sumLimit = sum;
    }
}
METHOD_INFO:

private int findSetSum(int[] prefix, int targetSize, int sumLimit) {
    if (prefix.length == targetSize) {
        int sum = 0;
        for (int i : prefix) sum += primes[i];
        return sum;
    } else {
        int i;
        if (prefix.length == 0) i = 0; else i = prefix[prefix.length - 1] + 1;
        outer: for (; i < primes.length && primes[i] <= sumLimit; i++) {
            for (int j : prefix) {
                if (!isConcatPrime(i, j) || !isConcatPrime(j, i)) continue outer;
            }
            int[] appended = Arrays.copyOf(prefix, prefix.length + 1);
            appended[appended.length - 1] = i;
            int sum = findSetSum(appended, targetSize, sumLimit - primes[i]);
            if (sum != -1) return sum;
        }
        return -1;
    }
}
METHOD_INFO:

private boolean isConcatPrime(int x, int y) {
    int index = x * primes.length + y;
    if (isConcatPrimeKnown.get(index)) return isConcatPrime.get(index);
    x = primes[x];
    y = primes[y];
    int mult = 1;
    for (int temp = y; temp != 0; temp /= 10) mult *= 10;
    boolean result = isPrime((long)x * mult + y);
    isConcatPrimeKnown.set(index);
    isConcatPrime.set(index, result);
    return result;
}
METHOD_INFO:

private boolean isPrime(long x) {
    if (x < 0) throw new IllegalArgumentException(); else if (x == 0 || x == 1) return false; else {
        long end = Library.sqrt(x);
        for (int p : primes) {
            if (p > end) break;
            if (x % p == 0) return false;
        }
        for (long i = primes[primes.length - 1] + 2; i <= end; i += 2) {
            if (x % i == 0) return false;
        }
        return true;
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p061
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p061().run());
}
METHOD_INFO:

@SuppressWarnings(value = "unchecked")
public String run() {
    numbers = new Set[9][100];
    for (int i = 0; i < numbers.length; i++) {
        for (int j = 0; j < numbers[i].length; j++) numbers[i][j] = new HashSet<>();
    }
    for (int sides = 3; sides <= 8; sides++) {
        for (int n = 1; ; n++) {
            int num = figurateNumber(sides, n);
            if (num >= 10000) break;
            if (num >= 1000) numbers[sides][num / 100].add(num);
        }
    }
    for (int i = 10; i < 100; i++) {
        for (int num : numbers[3][i]) {
            int temp = findSolutionSum(num, num, 1 << 3, num);
            if (temp != -1) return Integer.toString(temp);
        }
    }
    throw new AssertionError("No solution");
}
METHOD_INFO:

private int findSolutionSum(int begin, int current, int sidesUsed, int sum) {
    if (sidesUsed == 504) {
        if (current % 100 == begin / 100) return sum;
    } else {
        for (int sides = 4; sides <= 8; sides++) {
            if (((sidesUsed >>> sides) & 1) != 0) continue;
            for (int num : numbers[sides][current % 100]) {
                int temp = findSolutionSum(begin, num, sidesUsed | (1 << sides), sum + num);
                if (temp != -1) return temp;
            }
        }
    }
    return -1;
}
METHOD_INFO:

private static int figurateNumber(int sides, int n) {
    return n * ((sides - 2) * n - (sides - 4)) / 2;
}
AFTER ANALYZE
null
null
null
Visiting class
p062
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p062().run());
}
METHOD_INFO:

public String run() {
    int numDigits = 0;
    Map<String, Integer> lowest = new HashMap<>();
    Map<String, Integer> counts = new HashMap<>();
    for (int i = 0; ; i++) {
        String numClass = getCubeNumberClass(i);
        if (numClass.length() > numDigits) {
            int min = Integer.MAX_VALUE;
            for (String nc : counts.keySet()) {
                if (counts.get(nc) == 5) min = Math.min(lowest.get(nc), min);
            }
            if (min != Integer.MAX_VALUE) return cube(min).toString();
            lowest.clear();
            counts.clear();
            numDigits = numClass.length();
        }
        if (!lowest.containsKey(numClass)) {
            lowest.put(numClass, i);
            counts.put(numClass, 0);
        }
        counts.put(numClass, counts.get(numClass) + 1);
    }
}
METHOD_INFO:

private static String getCubeNumberClass(int x) {
    char[] digits = cube(x).toString().toCharArray();
    Arrays.sort(digits);
    return new String(digits);
}
METHOD_INFO:

private static BigInteger cube(int x) {
    return BigInteger.valueOf(x).pow(3);
}
AFTER ANALYZE
null
null
null
Visiting class
p063
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p063().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int n = 1; n <= 9; n++) {
        for (int k = 1; k <= 21; k++) {
            if (BigInteger.valueOf(n).pow(k).toString().length() == k) count++;
        }
    }
    return Integer.toString(count);
}
AFTER ANALYZE
null
null
null
Visiting class
p064
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p064().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int i = 1; i <= 10000; i++) {
        if (!Library.isSquare(i) && getSqrtContinuedFractionPeriod(i) % 2 == 1) count++;
    }
    return Integer.toString(count);
}
METHOD_INFO:

private static int getSqrtContinuedFractionPeriod(int n) {
    Map<QuadraticSurd, Integer> seen = new HashMap<>();
    QuadraticSurd val = new QuadraticSurd(BigInteger.ZERO, BigInteger.ONE, BigInteger.ONE, BigInteger.valueOf(n));
    do {
        seen.put(val, seen.size());
        val = val.subtract(new QuadraticSurd(val.floor(), BigInteger.ZERO, BigInteger.ONE, val.d)).reciprocal();
    }     while (!seen.containsKey(val));
    return seen.size() - seen.get(val);
}
Visiting class
QuadraticSurd
METHOD_INFO:

public <init>(BigInteger a, BigInteger b, BigInteger c, BigInteger d) {
    super();
    if (c.signum() == 0) throw new IllegalArgumentException();
    if (c.signum() == -1) {
        a = a.negate();
        b = b.negate();
        c = c.negate();
    }
    BigInteger gcd = a.gcd(b).gcd(c);
    if (!gcd.equals(BigInteger.ONE)) {
        a = a.divide(gcd);
        b = b.divide(gcd);
        c = c.divide(gcd);
    }
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}
METHOD_INFO:

public QuadraticSurd subtract(QuadraticSurd other) {
    if (!d.equals(other.d)) throw new IllegalArgumentException();
    return new QuadraticSurd(a.multiply(other.c).subtract(other.a.multiply(c)), b.multiply(other.c).subtract(other.b.multiply(c)), c.multiply(other.c), d);
}
METHOD_INFO:

public QuadraticSurd reciprocal() {
    return new QuadraticSurd(a.multiply(c).negate(), b.multiply(c), b.multiply(b).multiply(d).subtract(a.multiply(a)), d);
}
METHOD_INFO:

public BigInteger floor() {
    BigInteger temp = Library.sqrt(b.multiply(b).multiply(d));
    if (b.signum() == -1) temp = temp.add(BigInteger.ONE).negate();
    temp = temp.add(a);
    if (temp.signum() == -1) temp = temp.subtract(c.subtract(BigInteger.ONE));
    return temp.divide(c);
}
METHOD_INFO:

public boolean equals(Object obj) {
    if (!(obj instanceof QuadraticSurd)) return false; else {
        QuadraticSurd other = (QuadraticSurd)obj;
        return a.equals(other.a) && b.equals(other.b) && c.equals(other.c) && d.equals(other.d);
    }
}
METHOD_INFO:

public int hashCode() {
    return a.hashCode() + b.hashCode() + c.hashCode() + d.hashCode();
}
METHOD_INFO:

public String toString() {
    return String.format("(%d + %d*sqrt(%d)) / %d", a, b, d, c);
}
AFTER ANALYZE
null
null
null
Visiting class
p065
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p065().run());
}
METHOD_INFO:

public String run() {
    BigInteger n = BigInteger.ONE;
    BigInteger d = BigInteger.ZERO;
    for (int i = 99; i >= 0; i--) {
        BigInteger temp = BigInteger.valueOf(continuedFractionTerm(i)).multiply(n).add(d);
        d = n;
        n = temp;
    }
    int sum = 0;
    while (!n.equals(BigInteger.ZERO)) {
        BigInteger[] divrem = n.divideAndRemainder(BigInteger.TEN);
        sum += divrem[1].intValue();
        n = divrem[0];
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static int continuedFractionTerm(int i) {
    if (i == 0) return 2; else if (i % 3 == 2) return i / 3 * 2 + 2; else return 1;
}
AFTER ANALYZE
null
null
null
Visiting class
p066
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p066().run());
}
METHOD_INFO:

public String run() {
    int minN = -1;
    BigInteger maxX = BigInteger.ZERO;
    for (int n = 2; n <= 1000; n++) {
        if (Library.isSquare(n)) continue;
        BigInteger x = smallestSolutionX(n);
        if (x.compareTo(maxX) > 0) {
            minN = n;
            maxX = x;
        }
    }
    return Integer.toString(minN);
}
METHOD_INFO:

private static BigInteger smallestSolutionX(int n) {
    List<BigInteger>[] contFrac = sqrtToContinuedFraction(n);
    List<BigInteger> temp = new ArrayList<>();
    temp.addAll(contFrac[0]);
    temp.addAll(contFrac[1].subList(0, contFrac[1].size() - 1));
    Fraction val = new Fraction(temp.get(temp.size() - 1));
    for (int i = temp.size() - 2; i >= 0; i--) val = new Fraction(val.denominator, val.numerator).add(new Fraction(temp.get(i)));
    if (contFrac[1].size() % 2 == 0) return val.numerator; else return val.numerator.pow(2).add(val.denominator.pow(2).multiply(BigInteger.valueOf(n)));
}
METHOD_INFO:

@SuppressWarnings(value = "unchecked")
private static List<BigInteger>[] sqrtToContinuedFraction(int n) {
    List<BigInteger> terms = new ArrayList<>();
    Map<QuadraticSurd, Integer> seen = new HashMap<>();
    QuadraticSurd val = new QuadraticSurd(BigInteger.ZERO, BigInteger.ONE, BigInteger.ONE, BigInteger.valueOf(n));
    do {
        seen.put(val, seen.size());
        BigInteger flr = val.floor();
        terms.add(flr);
        val = val.subtract(new QuadraticSurd(flr, BigInteger.ZERO, BigInteger.ONE, val.d)).reciprocal();
    }     while (!seen.containsKey(val));
    return new List[]{terms.subList(0, seen.get(val)), terms.subList(seen.get(val), terms.size())};
}
Visiting class
QuadraticSurd
METHOD_INFO:

public <init>(BigInteger a, BigInteger b, BigInteger c, BigInteger d) {
    super();
    if (c.signum() == 0) throw new IllegalArgumentException();
    if (c.signum() == -1) {
        a = a.negate();
        b = b.negate();
        c = c.negate();
    }
    BigInteger gcd = a.gcd(b).gcd(c);
    if (!gcd.equals(BigInteger.ONE)) {
        a = a.divide(gcd);
        b = b.divide(gcd);
        c = c.divide(gcd);
    }
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}
METHOD_INFO:

public QuadraticSurd subtract(QuadraticSurd other) {
    if (!d.equals(other.d)) throw new IllegalArgumentException();
    return new QuadraticSurd(a.multiply(other.c).subtract(other.a.multiply(c)), b.multiply(other.c).subtract(other.b.multiply(c)), c.multiply(other.c), d);
}
METHOD_INFO:

public QuadraticSurd reciprocal() {
    return new QuadraticSurd(a.multiply(c).negate(), b.multiply(c), b.multiply(b).multiply(d).subtract(a.multiply(a)), d);
}
METHOD_INFO:

public BigInteger floor() {
    BigInteger temp = Library.sqrt(b.multiply(b).multiply(d));
    if (b.signum() == -1) temp = temp.add(BigInteger.ONE).negate();
    temp = temp.add(a);
    if (temp.signum() == -1) temp = temp.subtract(c.subtract(BigInteger.ONE));
    return temp.divide(c);
}
METHOD_INFO:

public boolean equals(Object obj) {
    if (!(obj instanceof QuadraticSurd)) return false; else {
        QuadraticSurd other = (QuadraticSurd)obj;
        return a.equals(other.a) && b.equals(other.b) && c.equals(other.c) && d.equals(other.d);
    }
}
METHOD_INFO:

public int hashCode() {
    return a.hashCode() + b.hashCode() + c.hashCode() + d.hashCode();
}
METHOD_INFO:

public String toString() {
    return String.format("(%d + %d*sqrt(%d)) / %d", a, b, d, c);
}
AFTER ANALYZE
null
null
null
Visiting class
p067
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p067().run());
}
METHOD_INFO:

public String run() {
    for (int i = triangle.length - 2; i >= 0; i--) {
        for (int j = 0; j < triangle[i].length; j++) triangle[i][j] += Math.max(triangle[i + 1][j], triangle[i + 1][j + 1]);
    }
    return Integer.toString(triangle[0][0]);
}
AFTER ANALYZE
null
null
null
Visiting class
p068
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p068().run());
}
METHOD_INFO:

public String run() {
    int[] state = new int[10];
    for (int i = 0; i < state.length; i++) state[i] = i + 1;
    String max = null;
    do {
        int sum = state[0] + state[5] + state[6];
        if (state[1] + state[6] + state[7] != sum || state[2] + state[7] + state[8] != sum || state[3] + state[8] + state[9] != sum || state[4] + state[9] + state[5] != sum) continue;
        int minOuterIndex = -1;
        int minOuter = Integer.MAX_VALUE;
        for (int i = 0; i < 5; i++) {
            if (state[i] < minOuter) {
                minOuterIndex = i;
                minOuter = state[i];
            }
        }
        String s = "";
        for (int i = 0; i < 5; i++) s += "" + state[(minOuterIndex + i) % 5] + state[(minOuterIndex + i) % 5 + 5] + state[(minOuterIndex + i + 1) % 5 + 5];
        if (s.length() == 16 && (max == null || s.compareTo(max) > 0)) max = s;
    }     while (Library.nextPermutation(state));
    if (max == null) throw new AssertionError();
    return max;
}
AFTER ANALYZE
null
null
null
Visiting class
p069
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p069().run());
}
METHOD_INFO:

public String run() {
    int maxNumer = 0;
    int maxDenom = 1;
    int[] totients = Library.listTotients(LIMIT);
    for (int n = 1; n < totients.length; n++) {
        if ((long)n * maxDenom > (long)maxNumer * totients[n]) {
            maxNumer = n;
            maxDenom = totients[n];
        }
    }
    return Integer.toString(maxNumer);
}
AFTER ANALYZE
null
null
null
Visiting class
p070
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p070().run());
}
METHOD_INFO:

public String run() {
    int minNumer = 1;
    int minDenom = 0;
    int[] totients = Library.listTotients(LIMIT - 1);
    for (int n = 2; n < totients.length; n++) {
        int tot = totients[n];
        if ((long)n * minDenom < (long)minNumer * tot && hasSameDigits(n, tot)) {
            minNumer = n;
            minDenom = tot;
        }
    }
    if (minDenom == 0) throw new RuntimeException("Not found");
    return Integer.toString(minNumer);
}
METHOD_INFO:

private static boolean hasSameDigits(int x, int y) {
    char[] xdigits = Integer.toString(x).toCharArray();
    char[] ydigits = Integer.toString(y).toCharArray();
    Arrays.sort(xdigits);
    Arrays.sort(ydigits);
    return Arrays.equals(xdigits, ydigits);
}
AFTER ANALYZE
null
null
null
Visiting class
p071
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p071().run());
}
METHOD_INFO:

public String run() {
    int maxN = 0;
    int maxD = 1;
    for (int d = 2; d <= 1000000; d++) {
        int n = d * 3 / 7;
        if (d % 7 == 0) n--;
        if ((long)n * maxD > (long)maxN * d) {
            maxN = n;
            maxD = d;
        }
    }
    return Integer.toString(maxN);
}
AFTER ANALYZE
null
null
null
Visiting class
p072
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p072().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    int[] totients = Library.listTotients(LIMIT);
    for (int i = 2; i < totients.length; i++) sum += totients[i];
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p073
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p073().run());
}
METHOD_INFO:

public String run() {
    return Integer.toString(sternBrocotCount(1, 3, 1, 2));
}
METHOD_INFO:

private static int sternBrocotCount(int leftN, int leftD, int rightN, int rightD) {
    int n = leftN + rightN;
    int d = leftD + rightD;
    if (d > 12000) return 0; else return 1 + sternBrocotCount(leftN, leftD, n, d) + sternBrocotCount(n, d, rightN, rightD);
}
AFTER ANALYZE
null
null
null
Visiting class
p074
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p074().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int i = 0; i < LIMIT; i++) {
        if (getChainLength(i) == 60) count++;
    }
    return Integer.toString(count);
}
METHOD_INFO:

private static int getChainLength(int n) {
    Set<Integer> seen = new HashSet<>();
    while (true) {
        if (!seen.add(n)) return seen.size();
        n = factorialize(n);
    }
}
METHOD_INFO:

private static int factorialize(int n) {
    int sum = 0;
    for (; n != 0; n /= 10) sum += FACTORIAL[n % 10];
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p075
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p075().run());
}
METHOD_INFO:

public String run() {
    Set<IntTriple> triples = new HashSet<>();
    for (int s = 3; s * s <= LIMIT; s += 2) {
        for (int t = s - 2; t > 0; t -= 2) {
            if (Library.gcd(s, t) == 1) {
                int a = s * t;
                int b = (s * s - t * t) / 2;
                int c = (s * s + t * t) / 2;
                if (a + b + c <= LIMIT) triples.add(new IntTriple(a, b, c));
            }
        }
    }
    byte[] ways = new byte[LIMIT + 1];
    for (IntTriple triple : triples) {
        int sum = triple.a + triple.b + triple.c;
        for (int i = sum; i < ways.length; i += sum) ways[i] = (byte)Math.min(ways[i] + 1, 2);
    }
    int count = 0;
    for (int x : ways) {
        if (x == 1) count++;
    }
    return Integer.toString(count);
}
Visiting class
IntTriple
METHOD_INFO:

public <init>(int a, int b, int c) {
    super();
    this.a = a;
    this.b = b;
    this.c = c;
}
METHOD_INFO:

public boolean equals(Object obj) {
    if (!(obj instanceof IntTriple)) return false; else {
        IntTriple other = (IntTriple)obj;
        return a == other.a && b == other.b && c == other.c;
    }
}
METHOD_INFO:

public int hashCode() {
    return a + b + c;
}
AFTER ANALYZE
null
null
null
Visiting class
p076
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p076().run());
}
METHOD_INFO:

public String run() {
    return partitions(100, 1).subtract(BigInteger.ONE).toString();
}
METHOD_INFO:

private static BigInteger partitions(int n, int k) {
    BigInteger[][] table = new BigInteger[n + 1][n + 1];
    for (int i = 0; i <= n; i++) {
        for (int j = n; j >= 0; j--) {
            if (j == i) table[i][j] = BigInteger.ONE; else if (j > i) table[i][j] = BigInteger.ZERO; else if (j == 0) table[i][j] = table[i][j + 1]; else table[i][j] = table[i][j + 1].add(table[i - j][j]);
        }
    }
    return table[n][k];
}
AFTER ANALYZE
null
null
null
Visiting class
p077
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p077().run());
}
METHOD_INFO:

public String run() {
    for (int limit = 1; ; limit *= 2) {
        int result = search(limit, TARGET);
        if (result != -1) return Integer.toString(result);
    }
}
METHOD_INFO:

private static int search(int limit, int target) {
    int[] partitions = new int[limit];
    partitions[0] = 1;
    for (int i = 0; i < partitions.length; i++) {
        if (!Library.isPrime(i)) continue;
        for (int j = i; j < partitions.length; j++) partitions[j] += partitions[j - i];
    }
    for (int i = 0; i < limit; i++) {
        if (partitions[i] > target) return i;
    }
    return -1;
}
AFTER ANALYZE
null
null
null
Visiting class
p078
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p078().run());
}
METHOD_INFO:

public String run() {
    for (int limit = 1; ; limit *= 2) {
        int result = search(limit);
        if (result != -1) return Integer.toString(result);
    }
}
METHOD_INFO:

private static int search(int limit) {
    int[] partitions = new int[limit];
    partitions[0] = 1;
    for (int i = 1; i < limit; i++) {
        for (int j = i; j < limit; j++) partitions[j] = (partitions[j] + partitions[j - i]) % MODULUS;
    }
    for (int i = 0; i < limit; i++) {
        if (partitions[i] == 0) return i;
    }
    return -1;
}
AFTER ANALYZE
null
null
null
Visiting class
p079
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p079().run());
}
METHOD_INFO:

public String run() {
    packedSubseqs = new char[SUBSEQS.length * 3];
    for (int i = 0; i < packedSubseqs.length; i++) packedSubseqs[i] = SUBSEQS[i / 3].charAt(i % 3);
    for (int len = 3; len <= 10; len++) {
        int end = Library.pow(10, len);
        for (int guess = 0; guess < end; guess++) {
            char[] guessChars = toChars(guess, len);
            if (isConsistent(guessChars)) return new String(guessChars);
        }
    }
    throw new RuntimeException("Not found");
}
METHOD_INFO:

private boolean isConsistent(char[] guess) {
    for (int i = 0; i < packedSubseqs.length; i += 3) {
        int j = 0;
        for (int k = 0; k < guess.length && j < 3; k++) {
            if (guess[k] == packedSubseqs[i + j]) j++;
        }
        if (j < 3) return false;
    }
    return true;
}
METHOD_INFO:

private static char[] toChars(int n, int len) {
    char[] result = new char[len];
    int i = 0;
    for (; i < result.length; i++, n /= 10) result[i] = (char)('0' + (n % 10));
    if (n != 0) throw new IllegalArgumentException();
    for (; i < result.length; i++) result[i] = '0';
    return result;
}
AFTER ANALYZE
null
null
null
Visiting class
p080
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p080().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (int i = 1; i <= 100; i++) {
        BigInteger x = BigInteger.valueOf(i);
        x = x.multiply(BigInteger.TEN.pow(100 * 2));
        BigInteger y = sqrt(x);
        if (!y.multiply(y).equals(x)) {
            String s = y.toString().substring(0, 100);
            for (int j = 0; j < s.length(); j++) sum += s.charAt(j) - '0';
        }
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static BigInteger sqrt(BigInteger x) {
    int i = 0;
    while (BigInteger.TEN.pow(i * 2).compareTo(x) <= 0) i++;
    BigInteger y = BigInteger.ZERO;
    for (; i >= 0; i--) {
        int j;
        BigInteger delta = null;
        for (j = 9; j >= 0; j--) {
            BigInteger temp = BigInteger.valueOf(j).multiply(BigInteger.TEN.pow(i));
            delta = y.shiftLeft(1).add(temp).multiply(temp);
            if (delta.compareTo(x) <= 0) break;
        }
        if (j < 0) throw new AssertionError();
        x = x.subtract(delta);
        y = y.add(BigInteger.valueOf(j).multiply(BigInteger.TEN.pow(i)));
    }
    return y;
}
AFTER ANALYZE
null
null
null
Visiting class
p081
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p081().run());
}
METHOD_INFO:

public String run() {
    for (int i = grid.length - 1; i >= 0; i--) {
        for (int j = grid[i].length - 1; j >= 0; j--) {
            int temp;
            if (i + 1 < grid.length && j + 1 < grid[i].length) temp = Math.min(grid[i + 1][j], grid[i][j + 1]); else if (i + 1 < grid.length) temp = grid[i + 1][j]; else if (j + 1 < grid[i].length) temp = grid[i][j + 1]; else temp = 0;
            grid[i][j] += temp;
        }
    }
    return Integer.toString(grid[0][0]);
}
AFTER ANALYZE
null
null
null
Visiting class
p082
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p082().run());
}
METHOD_INFO:

public String run() {
    int h = GRID.length;
    int w = GRID[0].length;
    distance = new int[h][w];
    for (int x = 0; x < w; x++) {
        for (int y = 0; y < h; y++) distance[y][x] = GRID[y][x] + Math.min(getValue(x - 1, y), getValue(x, y - 1));
        for (int y = h - 1; y >= 0; y--) distance[y][x] = Math.min(GRID[y][x] + getValue(x, y + 1), distance[y][x]);
    }
    int min = INFINITY;
    for (int y = 0; y < h; y++) min = Math.min(distance[y][w - 1], min);
    return Integer.toString(min);
}
METHOD_INFO:

private int getValue(int x, int y) {
    if (x < 0) return 0; else if (y < 0 || y >= distance.length || x >= distance[y].length) return INFINITY; else return distance[y][x];
}
AFTER ANALYZE
null
null
null
Visiting class
p083
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p083().run());
}
METHOD_INFO:

public String run() {
    int h = GRID.length;
    int w = GRID[0].length;
    distance = new int[h][w];
    for (int[] row : distance) Arrays.fill(row, INFINITY);
    distance[0][0] = GRID[0][0];
    for (int i = 0; i < w * h; i++) {
        for (int y = 0; y < h; y++) {
            for (int x = 0; x < w; x++) {
                int temp = INFINITY;
                temp = Math.min(getDistance(x - 1, y), temp);
                temp = Math.min(getDistance(x + 1, y), temp);
                temp = Math.min(getDistance(x, y - 1), temp);
                temp = Math.min(getDistance(x, y + 1), temp);
                distance[y][x] = Math.min(GRID[y][x] + temp, distance[y][x]);
            }
        }
    }
    return Integer.toString(distance[h - 1][w - 1]);
}
METHOD_INFO:

private int getDistance(int x, int y) {
    if (y < 0 || y >= distance.length || x < 0 || x >= distance[y].length) return INFINITY; else return distance[y][x];
}
AFTER ANALYZE
null
null
null
Visiting class
p084
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p084().run());
}
METHOD_INFO:

public String run() {
    final int[] visitCounts = new int[40];
    CardDeck chance = new CardDeck(16);
    CardDeck communityChest = new CardDeck(16);
    int consecutiveDoubles = 0;
    int location = 0;
    for (int i = 0; i < 100000000; i++) {
        int die0 = random.nextInt(4) + 1;
        int die1 = random.nextInt(4) + 1;
        if (die0 == die1) consecutiveDoubles++; else consecutiveDoubles = 0;
        if (consecutiveDoubles < 3) location = (location + die0 + die1) % 40; else {
            location = 30;
            consecutiveDoubles = 0;
        }
        switch (location) {
        case 7: 
        
        case 22: 
        
        case 36: 
            switch (chance.nextCard()) {
            case 0: 
                location = 0;
                break;
            
            case 1: 
                location = 10;
                break;
            
            case 2: 
                location = 11;
                break;
            
            case 3: 
                location = 24;
                break;
            
            case 4: 
                location = 39;
                break;
            
            case 5: 
                location = 5;
                break;
            
            case 6: 
            
            case 7: 
                location = (location + 5) / 10 % 4 * 10 + 5;
                break;
            
            case 8: 
                location = location > 12 && location < 28 ? 28 : 12;
                break;
            
            case 9: 
                location -= 3;
                break;
            
            default: 
                break;
            
            }
            break;
        
        case 30: 
            location = 10;
            break;
        
        default: 
            break;
        
        }
        switch (location) {
        case 2: 
        
        case 17: 
        
        case 33: 
            switch (communityChest.nextCard()) {
            case 0: 
                location = 0;
                break;
            
            case 1: 
                location = 10;
                break;
            
            default: 
                break;
            
            }
            break;
        
        default: 
            break;
        
        }
        visitCounts[location]++;
    }
    for (int i = 0; i < visitCounts.length; i++) visitCounts[i] = ~visitCounts[i] << 6 | i;
    Arrays.sort(visitCounts);
    String result = "";
    for (int i = 0; i < 3; i++) result += String.format("%02d", visitCounts[i] & 63);
    return result;
}
Visiting class
CardDeck
METHOD_INFO:

public <init>(int size) {
    super();
    cards = new int[size];
    for (int i = 0; i < cards.length; i++) cards[i] = i;
    index = size;
}
METHOD_INFO:

public int nextCard() {
    if (index == cards.length) {
        for (int i = cards.length - 1; i >= 0; i--) {
            int j = random.nextInt(i + 1);
            int temp = cards[i];
            cards[i] = cards[j];
            cards[j] = temp;
        }
        index = 0;
    }
    int result = cards[index];
    index++;
    return result;
}
AFTER ANALYZE
null
null
null
Visiting class
p085
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p085().run());
}
METHOD_INFO:

public String run() {
    int bestDiff = Integer.MAX_VALUE;
    int bestArea = -1;
    int sqrt = Library.sqrt(TARGET);
    for (int w = 1; w <= sqrt; w++) {
        for (int h = 1; h <= sqrt; h++) {
            int diff = Math.abs(numberOfRectangles(w, h) - TARGET);
            if (diff < bestDiff) {
                bestDiff = diff;
                bestArea = w * h;
            }
        }
    }
    return Integer.toString(bestArea);
}
METHOD_INFO:

private static int numberOfRectangles(int m, int n) {
    return (m + 1) * m * (n + 1) * n / 4;
}
AFTER ANALYZE
null
null
null
Visiting class
p086
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p086().run());
}
METHOD_INFO:

public String run() {
    cumulativeSolutions.add(0);
    int limit = 1;
    while (true) {
        while (solutions.size() < limit) solutions.add(new HashSet<List<Integer>>());
        generateSolutions(limit);
        for (int i = cumulativeSolutions.size(); i < limit; i++) {
            int sum = cumulativeSolutions.get(i - 1) + solutions.get(i).size();
            cumulativeSolutions.add(sum);
            if (sum > 1000000) return Integer.toString(i);
        }
        limit *= 2;
    }
}
METHOD_INFO:

private void generateSolutions(int limit) {
    outer: for (int s = 3; ; s += 2) {
        for (int t = s - 2; t > 0; t -= 2) {
            if (s * s / 2 >= limit * 3) break outer;
            if (Library.gcd(s, t) == 1) {
                for (int k = 1; ; k++) {
                    int a = s * t * k;
                    int b = (s * s - t * t) / 2 * k;
                    int c = (s * s + t * t) / 2 * k;
                    if (a >= limit && b >= limit) break;
                    findSplits(a, b, c, limit);
                    findSplits(b, a, c, limit);
                }
            }
        }
    }
}
METHOD_INFO:

private void findSplits(int a, int b, int c, int limit) {
    int z = b;
    for (int x = 1; x < a; x++) {
        int y = a - x;
        if (y < x) break;
        if (Math.min(Math.min((x + y) * (x + y) + z * z, (y + z) * (y + z) + x * x), (z + x) * (z + x) + y * y) == c * c) {
            int max = Math.max(Math.max(x, y), z);
            if (max < limit) {
                List<Integer> soln = new ArrayList<>();
                Collections.addAll(soln, x, y, z);
                Collections.sort(soln);
                solutions.get(max).add(soln);
            }
        }
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p087
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p087().run());
}
METHOD_INFO:

public String run() {
    int[] primes = Library.listPrimes(Library.sqrt(LIMIT));
    Set<Integer> sums = new HashSet<>();
    sums.add(0);
    for (int i = 2; i <= 4; i++) {
        Set<Integer> newsums = new HashSet<>();
        for (int p : primes) {
            long q = 1;
            for (int j = 0; j < i; j++) q *= p;
            if (q > LIMIT) break;
            int r = (int)q;
            for (int x : sums) {
                if (x + r <= LIMIT) newsums.add(x + r);
            }
        }
        sums = newsums;
    }
    return Integer.toString(sums.size());
}
AFTER ANALYZE
null
null
null
Visiting class
p088
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p088().run());
}
METHOD_INFO:

public String run() {
    minSumProduct = new int[LIMIT + 1];
    Arrays.fill(minSumProduct, Integer.MAX_VALUE);
    for (int i = 2; i <= LIMIT * 2; i++) factorize(i, i, i, 0, 0);
    Set<Integer> items = new HashSet<>();
    for (int i = 2; i < minSumProduct.length; i++) items.add(minSumProduct[i]);
    int sum = 0;
    for (int n : items) sum += n;
    return Integer.toString(sum);
}
METHOD_INFO:

private void factorize(int n, int remain, int maxFactor, int sum, int terms) {
    if (remain == 1) {
        if (sum > n) throw new AssertionError();
        terms += n - sum;
        if (terms <= LIMIT && n < minSumProduct[terms]) minSumProduct[terms] = n;
    } else {
        for (int i = 2; i <= maxFactor; i++) {
            if (remain % i == 0) {
                int factor = i;
                factorize(n, remain / factor, Math.min(factor, maxFactor), sum + factor, terms + 1);
            }
        }
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p089
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p089().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (String s : TO_SIMPLIFY) sum += s.length() - romanNumeralLength(parseRomanNumeral(s));
    return Integer.toString(sum);
}
METHOD_INFO:

private static int parseRomanNumeral(String s) {
    int result = 0;
    outer: while (s.length() > 0) {
        for (Object[] prefix : PREFIXES) {
            if (s.startsWith((String)prefix[0])) {
                result += (Integer)prefix[1];
                s = s.substring(((String)prefix[0]).length());
                continue outer;
            }
        }
        throw new IllegalArgumentException("Cannot parse Roman numeral");
    }
    return result;
}
METHOD_INFO:

private static int romanNumeralLength(int n) {
    if (n <= 0 || n >= 5000) throw new IllegalArgumentException();
    int count = 0;
    if (n >= 4000) count += 2;
    for (; n != 0; n /= 10) count += DIGIT_LENGTHS[n % 10];
    return count;
}
AFTER ANALYZE
null
null
null
Visiting class
p090
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p090().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int i = 0; i < (1 << 10); i++) {
        for (int j = i; j < (1 << 10); j++) {
            if (Integer.bitCount(i) == 6 && Integer.bitCount(j) == 6 && isArrangementValid(i, j)) count++;
        }
    }
    return Integer.toString(count);
}
METHOD_INFO:

private static boolean isArrangementValid(int a, int b) {
    if (testBit(a, 6) || testBit(a, 9)) a |= (1 << 6) | (1 << 9);
    if (testBit(b, 6) || testBit(b, 9)) b |= (1 << 6) | (1 << 9);
    for (int[] sqr : SQUARES) {
        if (!(testBit(a, sqr[0]) && testBit(b, sqr[1]) || testBit(a, sqr[1]) && testBit(b, sqr[0]))) return false;
    }
    return true;
}
METHOD_INFO:

private static boolean testBit(int x, int i) {
    return ((x >>> i) & 1) != 0;
}
AFTER ANALYZE
null
null
null
Visiting class
p091
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p091().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int x1 = 0; x1 <= LIMIT; x1++) {
        for (int y1 = 0; y1 <= LIMIT; y1++) {
            for (int x2 = 0; x2 <= LIMIT; x2++) {
                for (int y2 = 0; y2 <= LIMIT; y2++) {
                    if (y2 * x1 < y1 * x2 && isRightTriangle(x1, y1, x2, y2)) count++;
                }
            }
        }
    }
    return Integer.toString(count);
}
METHOD_INFO:

private static boolean isRightTriangle(int x1, int y1, int x2, int y2) {
    int a = x1 * x1 + y1 * y1;
    int b = x2 * x2 + y2 * y2;
    int c = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    return a + b == c || b + c == a || c + a == b;
}
AFTER ANALYZE
null
null
null
Visiting class
p092
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p092().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int i = 1; i < LIMIT; i++) {
        if (isClass89(i)) count++;
    }
    return Integer.toString(count);
}
METHOD_INFO:

private static boolean isClass89(int x) {
    while (true) {
        switch (x) {
        case 1: 
            return false;
        
        case 89: 
            return true;
        
        default: 
            x = nextNumber(x);
        
        }
    }
}
METHOD_INFO:

private static int nextNumber(int x) {
    int sum = 0;
    while (x != 0) {
        sum += (x % 10) * (x % 10);
        x /= 10;
    }
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p093
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p093().run());
}
METHOD_INFO:

public String run() {
    int longest = 0;
    int abcd = -1;
    for (int a = 1; a <= 9; a++) {
        for (int b = a + 1; b <= 9; b++) {
            for (int c = b + 1; c <= 9; c++) {
                for (int d = c + 1; d <= 9; d++) {
                    int consec = longestConsecutive(a, b, c, d);
                    if (consec > longest) {
                        longest = consec;
                        abcd = a * 1000 + b * 100 + c * 10 + d;
                    }
                }
            }
        }
    }
    return Integer.toString(abcd);
}
METHOD_INFO:

private static int longestConsecutive(int a, int b, int c, int d) {
    Set<Integer> expressible = new HashSet<>();
    int[] ops = {0, 0, 0, a, b, c, d};
    outer: do {
        inner: for (int i = 0; i < 64; i++) {
            Stack<Fraction> stack = new Stack<>();
            int j = 0;
            for (int op : ops) {
                if (1 <= op && op <= 9) {
                    stack.push(new Fraction(BigInteger.valueOf(op)));
                } else if (op == 0) {
                    if (stack.size() < 2) continue outer;
                    Fraction right = stack.pop();
                    Fraction left = stack.pop();
                    switch ((i >>> (j * 2)) & 3) {
                    case 0: 
                        stack.push(left.add(right));
                        break;
                    
                    case 1: 
                        stack.push(left.subtract(right));
                        break;
                    
                    case 2: 
                        stack.push(left.multiply(right));
                        break;
                    
                    case 3: 
                        if (right.numerator.signum() == 0) continue inner;
                        stack.push(left.divide(right));
                        break;
                    
                    default: 
                        throw new AssertionError();
                    
                    }
                    j++;
                } else throw new AssertionError();
            }
            if (stack.size() != 1) throw new AssertionError();
            Fraction result = stack.pop();
            if (result.denominator.equals(BigInteger.ONE)) expressible.add(result.numerator.intValue());
        }
    }     while (Library.nextPermutation(ops));
    for (int i = 0; ; i++) {
        if (!expressible.contains(i + 1)) return i;
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p094
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p094().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    for (int s = 1; s * s <= (LIMIT + 1) / 3; s += 2) {
        for (int t = s - 2; t > 0; t -= 2) {
            if (Library.gcd(s, t) == 1) {
                int a = s * t;
                int b = (s * s - t * t) / 2;
                int c = (s * s + t * t) / 2;
                if (a * 2 == c - 1) {
                    int p = c * 3 - 1;
                    if (p <= LIMIT) sum += p;
                }
                if (a * 2 == c + 1) {
                    int p = c * 3 + 1;
                    if (p <= LIMIT) sum += p;
                }
                if (b * 2 == c - 1) {
                    int p = c * 3 - 1;
                    if (p <= LIMIT) sum += p;
                }
                if (b * 2 == c + 1) {
                    int p = c * 3 + 1;
                    if (p <= LIMIT) sum += p;
                }
            }
        }
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p095
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p095().run());
}
METHOD_INFO:

public String run() {
    int[] divisorSum = new int[LIMIT + 1];
    for (int i = 1; i <= LIMIT; i++) {
        for (int j = i * 2; j <= LIMIT; j += i) divisorSum[j] += i;
    }
    int maxChainLen = 0;
    int minChainElem = -1;
    for (int i = 0; i <= LIMIT; i++) {
        Set<Integer> visited = new HashSet<>();
        for (int count = 1, cur = i; ; count++) {
            visited.add(cur);
            int next = divisorSum[cur];
            if (next == i) {
                if (count > maxChainLen) {
                    minChainElem = i;
                    maxChainLen = count;
                }
                break;
            } else if (next > LIMIT || visited.contains(next)) break; else cur = next;
        }
    }
    return Integer.toString(minChainElem);
}
AFTER ANALYZE
null
null
null
Visiting class
p096
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p096().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (String puz : PUZZLES) {
        if (puz.length() != 81) throw new IllegalArgumentException();
        char[] board = puz.toCharArray();
        if (!solveSudoku(board, 0)) throw new IllegalArgumentException("Unsolvable");
        sum += Integer.parseInt("" + board[0] + board[1] + board[2]);
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static boolean solveSudoku(char[] board, int index) {
    if (index == board.length) return true; else if (board[index] != '0') return solveSudoku(board, index + 1); else {
        outer: for (char digit = '1'; digit <= '9'; digit++) {
            int x = index % 9;
            int y = index / 9;
            int b = y / 3 * 27 + x / 3 * 3;
            for (int i = 0; i < 9; i++) {
                if (board[y * 9 + i] == digit) continue outer;
                if (board[i * 9 + x] == digit) continue outer;
                if (board[b + i / 3 * 9 + i % 3] == digit) continue outer;
            }
            board[index] = digit;
            if (solveSudoku(board, index + 1)) return true;
        }
        board[index] = '0';
        return false;
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p097
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p097().run());
}
METHOD_INFO:

public String run() {
    BigInteger modulus = BigInteger.TEN.pow(10);
    BigInteger n = BigInteger.valueOf(2).modPow(BigInteger.valueOf(7830457), modulus);
    n = n.multiply(BigInteger.valueOf(28433)).mod(modulus);
    n = n.add(BigInteger.ONE).mod(modulus);
    return String.format("%010d", n);
}
AFTER ANALYZE
null
null
null
Visiting class
p098
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p098().run());
}
METHOD_INFO:

public String run() {
    Map<String, List<String>> anagrams = new HashMap<>();
    for (String word : WORDS) {
        String key = canonicalize(word);
        if (!anagrams.containsKey(key)) anagrams.put(key, new ArrayList<String>());
        anagrams.get(key).add(word);
    }
    int max = 0;
    for (String key : anagrams.keySet()) {
        List<String> words = anagrams.get(key);
        for (int i = 0; i < words.size(); i++) {
            for (int j = i + 1; j < words.size(); j++) {
                int[] assignments = new int['Z' + 1];
                Arrays.fill(assignments, -1);
                max = Math.max(maxSquarePair(words.get(i), words.get(j), 0, assignments, new boolean[10]), max);
            }
        }
    }
    return Integer.toString(max);
}
METHOD_INFO:

private static int maxSquarePair(String a, String b, int index, int[] assignments, boolean[] isDigitUsed) {
    if (index == a.length()) {
        if (assignments[a.charAt(0)] == 0 || assignments[b.charAt(0)] == 0) return 0;
        int aNum = 0;
        int bNum = 0;
        for (int i = 0; i < a.length(); i++) {
            aNum = aNum * 10 + assignments[a.charAt(i)];
            bNum = bNum * 10 + assignments[b.charAt(i)];
        }
        if (Library.isSquare(aNum) && Library.isSquare(bNum)) return Math.max(aNum, bNum); else return 0;
    } else if (assignments[a.charAt(index)] != -1) {
        return maxSquarePair(a, b, index + 1, assignments, isDigitUsed);
    } else {
        int max = 0;
        for (int i = 0; i < 10; i++) {
            if (!isDigitUsed[i]) {
                isDigitUsed[i] = true;
                assignments[a.charAt(index)] = i;
                max = Math.max(maxSquarePair(a, b, index + 1, assignments, isDigitUsed), max);
                isDigitUsed[i] = false;
                assignments[a.charAt(index)] = -1;
            }
        }
        return max;
    }
}
METHOD_INFO:

private static String canonicalize(String s) {
    char[] c = s.toCharArray();
    Arrays.sort(c);
    return new String(c);
}
AFTER ANALYZE
null
null
null
Visiting class
p099
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p099().run());
}
METHOD_INFO:

public String run() {
    int[] maxVal = DATA[0];
    int maxIndex = 0;
    for (int i = 1; i < DATA.length; i++) {
        if (comparePowers(DATA[i][0], DATA[i][1], maxVal[0], maxVal[1]) > 0) {
            maxVal = DATA[i];
            maxIndex = i;
        }
    }
    return Integer.toString(maxIndex + 1);
}
METHOD_INFO:

private static int comparePowers(int xBase, int xExp, int yBase, int yExp) {
    for (int precision = 16; precision <= 1024; precision *= 2) {
        BigFloat xLow = new BigFloat(xBase).power(xExp, precision, false);
        BigFloat xHigh = new BigFloat(xBase).power(xExp, precision, true);
        BigFloat yLow = new BigFloat(yBase).power(yExp, precision, false);
        BigFloat yHigh = new BigFloat(yBase).power(yExp, precision, true);
        if (xHigh.compareTo(yLow) < 0) return -1; else if (xLow.compareTo(yHigh) > 0) return +1;
    }
    BigInteger xPow = BigInteger.valueOf(xBase).pow(xExp);
    BigInteger yPow = BigInteger.valueOf(yBase).pow(yExp);
    return xPow.compareTo(yPow);
}
Visiting class
BigFloat
METHOD_INFO:

public <init>(int n) {
    super();
    if (n <= 0) throw new IllegalArgumentException();
    mantissa = BigInteger.valueOf(n);
    exponent = 0;
}
METHOD_INFO:

private <init>(BigInteger man, int exp) {
    super();
    mantissa = man;
    exponent = exp;
}
METHOD_INFO:

public int compareTo(BigFloat other) {
    int minExp = Math.min(exponent, other.exponent);
    BigInteger tempx = mantissa.shiftLeft(exponent - minExp);
    BigInteger tempy = other.mantissa.shiftLeft(other.exponent - minExp);
    return tempx.compareTo(tempy);
}
METHOD_INFO:

public String toString() {
    return mantissa + "<<" + exponent;
}
METHOD_INFO:

public BigFloat multiply(BigFloat other, int precision, boolean roundUp) {
    BigInteger man = mantissa.multiply(other.mantissa);
    int exp = exponent + other.exponent;
    int excess = man.bitLength() - precision;
    if (excess > 0) {
        if (roundUp) {
            BigInteger mask = BigInteger.ONE.shiftLeft(excess).subtract(BigInteger.ONE);
            if (!mask.and(man).equals(BigInteger.ZERO)) man = man.add(BigInteger.ONE.shiftLeft(excess));
            excess = man.bitLength() - precision;
        }
        man = man.shiftRight(excess);
        exp += excess;
    }
    return new BigFloat(man, exp);
}
METHOD_INFO:

public BigFloat power(int y, int precision, boolean roundUp) {
    if (y < 0 || precision <= 0) throw new IllegalArgumentException();
    BigFloat x = this;
    BigFloat z = new BigFloat(1);
    for (; y != 0; y >>>= 1) {
        if ((y & 1) != 0) z = z.multiply(x, precision, roundUp);
        x = x.multiply(x, precision, roundUp);
    }
    return z;
}
AFTER ANALYZE
null
null
null
Visiting class
p100
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p100().run());
}
METHOD_INFO:

public String run() {
    BigInteger x0 = BigInteger.valueOf(3);
    BigInteger y0 = BigInteger.valueOf(1);
    BigInteger x = BigInteger.valueOf(3);
    BigInteger y = BigInteger.valueOf(1);
    while (true) {
        BigInteger sqrt = Library.sqrt(y.multiply(y).multiply(BigInteger.valueOf(8)).add(BigInteger.ONE));
        if (sqrt.testBit(0)) {
            BigInteger blue = sqrt.add(BigInteger.ONE).divide(BigInteger.valueOf(2)).add(y);
            if (blue.add(y).compareTo(BigInteger.TEN.pow(12)) > 0) return blue.toString();
        }
        BigInteger nextx = x.multiply(x0).add(y.multiply(y0).multiply(BigInteger.valueOf(8)));
        BigInteger nexty = x.multiply(y0).add(y.multiply(x0));
        x = nextx;
        y = nexty;
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p101
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p101().run());
}
METHOD_INFO:

public String run() {
    Fraction sum = Fraction.ZERO;
    for (int k = 1; k <= DEGREE; k++) {
        for (int n = k + 1; ; n++) {
            if (n == DEGREE + 2) throw new AssertionError();
            Fraction reference = new Fraction(generatingFunction(n));
            Fraction term = optimumPolynomial(k, n);
            if (!term.equals(reference)) {
                sum = sum.add(term);
                break;
            }
        }
    }
    if (sum.denominator.equals(BigInteger.ONE)) return sum.numerator.toString(); else return sum.toString();
}
METHOD_INFO:

private static Fraction optimumPolynomial(int k, int n) {
    Fraction sum = Fraction.ZERO;
    for (int i = 1; i <= k; i++) {
        Fraction product = new Fraction(generatingFunction(i));
        for (int j = 1; j <= k; j++) {
            if (j != i) product = product.multiply(new Fraction(BigInteger.valueOf(n - j), BigInteger.valueOf(i - j)));
        }
        sum = sum.add(product);
    }
    return sum;
}
METHOD_INFO:

private static BigInteger generatingFunction(int n) {
    BigInteger sum = BigInteger.ZERO;
    BigInteger biN = BigInteger.valueOf(-n);
    for (int i = 0; i <= DEGREE; i++) sum = sum.add(biN.pow(i));
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p102
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p102().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int[] t : TRIANGLES) {
        if (isInTriangle(t, 0, 0)) count++;
    }
    return Integer.toString(count);
}
METHOD_INFO:

private static boolean isInTriangle(int[] t, int x, int y) {
    int a = Integer.signum((t[0] - t[2]) * (y - t[1]) - (t[1] - t[3]) * (x - t[0]));
    int b = Integer.signum((t[2] - t[4]) * (y - t[3]) - (t[3] - t[5]) * (x - t[2]));
    int c = Integer.signum((t[4] - t[0]) * (y - t[5]) - (t[5] - t[1]) * (x - t[4]));
    return a == 0 || b == 0 || c == 0 || (a == b && b == c);
}
AFTER ANALYZE
null
null
null
Visiting class
p104
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p104().run());
}
METHOD_INFO:

public String run() {
    int i = 0;
    int a = 0;
    int b = 1;
    while (!isFound(i, a)) {
        int c = (a + b) % 1000000000;
        a = b;
        b = c;
        i++;
    }
    return Integer.toString(i);
}
METHOD_INFO:

private static boolean isFound(int n, int fibMod) {
    if (!isPandigital(Integer.toString(fibMod))) return false;
    BigInteger fib = fibonacci(n)[0];
    if (fib.mod(BigInteger.valueOf(1000000000)).intValue() != fibMod) throw new AssertionError();
    return isPandigital(leading9Digits(fib));
}
METHOD_INFO:

private static String leading9Digits(BigInteger x) {
    int log10 = (x.bitLength() - 1) * 3 / 10;
    x = x.divide(BigInteger.TEN.pow(Math.max(log10 + 1 - 9, 0)));
    return x.toString().substring(0, 9);
}
METHOD_INFO:

private static boolean isPandigital(String s) {
    if (s.length() != 9) return false;
    char[] temp = s.toCharArray();
    Arrays.sort(temp);
    return new String(temp).equals("123456789");
}
METHOD_INFO:

private static BigInteger[] fibonacci(int n) {
    if (n < 0) throw new IllegalArgumentException(); else if (n == 0) return new BigInteger[]{BigInteger.ZERO, BigInteger.ONE}; else {
        BigInteger[] ab = fibonacci(n / 2);
        BigInteger a = ab[0];
        BigInteger b = ab[1];
        BigInteger c = a.multiply(b.shiftLeft(1).subtract(a));
        BigInteger d = a.multiply(a).add(b.multiply(b));
        if (n % 2 == 0) return new BigInteger[]{c, d}; else return new BigInteger[]{d, c.add(d)};
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p105
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p105().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (int[] set : SETS) {
        if (isSpecialSumSet(set)) {
            for (int x : set) sum += x;
        }
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static boolean isSpecialSumSet(int[] set) {
    Set<Integer> sumsSeen = new HashSet<>();
    int[] minSum = new int[set.length + 1];
    int[] maxSum = new int[set.length + 1];
    Arrays.fill(minSum, Integer.MAX_VALUE);
    for (int i = 0; i < (1 << set.length); i++) {
        int size = Integer.bitCount(i);
        int sum = 0;
        for (int j = 0; j < set.length; j++) {
            if (((i >>> j) & 1) != 0) sum += set[j];
        }
        if (!sumsSeen.add(sum)) return false;
        minSum[size] = Math.min(sum, minSum[size]);
        maxSum[size] = Math.max(sum, maxSum[size]);
    }
    for (int i = 0; i < set.length; i++) {
        if (maxSum[i] >= minSum[i + 1]) return false;
    }
    return true;
}
AFTER ANALYZE
null
null
null
Visiting class
p107
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p107().run());
}
METHOD_INFO:

public String run() {
    int vertices = WEIGHTS.length;
    for (int i = 0; i < vertices; i++) {
        if (WEIGHTS[i].length != vertices) throw new AssertionError("Matrix not square");
    }
    int oldWeight = 0;
    for (int i = 0; i < vertices; i++) {
        if (WEIGHTS[i][i] != -1) throw new AssertionError("Self edge");
        for (int j = i + 1; j < vertices; j++) {
            if (WEIGHTS[i][j] != WEIGHTS[j][i]) throw new AssertionError("Matrix not symmetric");
            if (WEIGHTS[i][j] != -1) oldWeight += WEIGHTS[i][j];
        }
    }
    boolean[] reachable = new boolean[vertices];
    reachable[0] = true;
    int newWeight = 0;
    for (int i = 1; i < vertices; i++) {
        int lowestWeight = -1;
        int target = -1;
        for (int j = 0; j < vertices; j++) {
            if (reachable[j]) {
                for (int k = 0; k < vertices; k++) {
                    if (!reachable[k] && WEIGHTS[j][k] != -1 && (lowestWeight == -1 || WEIGHTS[j][k] < lowestWeight)) {
                        lowestWeight = WEIGHTS[j][k];
                        target = k;
                    }
                }
            }
        }
        if (lowestWeight == -1) throw new AssertionError("No spanning tree exists");
        reachable[target] = true;
        newWeight += lowestWeight;
    }
    return Integer.toString(oldWeight - newWeight);
}
AFTER ANALYZE
null
null
null
Visiting class
p108
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p108().run());
}
METHOD_INFO:

public String run() {
    for (int n = 1; ; n++) {
        if ((countDivisorsSquared(n) + 1) / 2 > 1000) return Integer.toString(n);
    }
}
METHOD_INFO:

private static int countDivisorsSquared(int n) {
    int count = 1;
    for (int i = 2, end = Library.sqrt(n); i <= end; i++) {
        if (n % i == 0) {
            int j = 0;
            do {
                n /= i;
                j++;
            }             while (n % i == 0);
            count *= j * 2 + 1;
            end = Library.sqrt(n);
        }
    }
    if (n != 1) count *= 3;
    return count;
}
AFTER ANALYZE
null
null
null
Visiting class
p109
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p109().run());
}
METHOD_INFO:

public String run() {
    points = new ArrayList<>();
    for (int i = 1; i <= 20; i++) {
        for (int j = 1; j <= 3; j++) points.add(i * j);
    }
    points.add(25);
    points.add(50);
    List<Integer> doublePoints = new ArrayList<>();
    for (int i = 1; i <= 20; i++) doublePoints.add(i * 2);
    doublePoints.add(25 * 2);
    ways = new int[3][101][points.size()];
    for (int[][] x : ways) {
        for (int[] y : x) Arrays.fill(y, -1);
    }
    int checkouts = 0;
    for (int remainingPoints = 1; remainingPoints < 100; remainingPoints++) {
        for (int throwz = 0; throwz <= 2; throwz++) {
            for (int p : doublePoints) {
                if (p <= remainingPoints) checkouts += ways(throwz, remainingPoints - p, points.size() - 1);
            }
        }
    }
    return Integer.toString(checkouts);
}
METHOD_INFO:

private int ways(int throwz, int total, int maxIndex) {
    if (ways[throwz][total][maxIndex] == -1) {
        int result;
        if (throwz == 0) result = total == 0 ? 1 : 0; else {
            result = 0;
            if (maxIndex > 0) result += ways(throwz, total, maxIndex - 1);
            if (points.get(maxIndex) <= total) result += ways(throwz - 1, total - points.get(maxIndex), maxIndex);
        }
        ways[throwz][total][maxIndex] = result;
    }
    return ways[throwz][total][maxIndex];
}
AFTER ANALYZE
null
null
null
Visiting class
p111
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p111().run());
}
METHOD_INFO:

public String run() {
    primes = Library.listPrimes((int)Library.sqrt(pow(10, DIGITS)));
    long total = 0;
    for (int digit = 0; digit < 10; digit++) {
        for (int rep = DIGITS; rep >= 0; rep--) {
            long sum = 0;
            int[] digits = new int[DIGITS];
            long count = pow(9, DIGITS - rep);
            level2: for (long i = 0; i < count; i++) {
                Arrays.fill(digits, 0, rep, digit);
                long temp = i;
                for (int j = 0; j < DIGITS - rep; j++) {
                    int d = (int)(temp % 9);
                    if (d >= digit) d++;
                    if (j > 0 && d > digits[DIGITS - j]) continue level2;
                    digits[DIGITS - 1 - j] = d;
                    temp /= 9;
                }
                Arrays.sort(digits);
                do {
                    if (digits[0] > 0) {
                        long num = toInteger(digits);
                        if (isPrime(num)) sum += num;
                    }
                }                 while (Library.nextPermutation(digits));
            }
            if (sum > 0) {
                total += sum;
                break;
            }
        }
    }
    return Long.toString(total);
}
METHOD_INFO:

private boolean isPrime(long n) {
    for (int p : primes) {
        if (n % p == 0) return false;
    }
    return true;
}
METHOD_INFO:

private static long toInteger(int[] digits) {
    long result = 0;
    for (int x : digits) result = result * 10 + x;
    return result;
}
METHOD_INFO:

private static long pow(int x, int y) {
    long z = 1;
    for (int i = 0; i < y; i++) z *= x;
    return z;
}
AFTER ANALYZE
null
null
null
Visiting class
p112
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p112().run());
}
METHOD_INFO:

public String run() {
    int bouncy = 0;
    for (int i = 1; ; i++) {
        if (isBouncy(i)) bouncy++;
        if (bouncy * 100 == i * 99) return Integer.toString(i);
    }
}
METHOD_INFO:

private static boolean isBouncy(int x) {
    if (x < 100) return false; else {
        boolean nonincreasing = true;
        boolean nondecreasing = true;
        int lastDigit = x % 10;
        x /= 10;
        while (x != 0) {
            int digit = x % 10;
            if (digit > lastDigit) nondecreasing = false; else if (digit < lastDigit) nonincreasing = false;
            lastDigit = digit;
            x /= 10;
        }
        return !nonincreasing && !nondecreasing;
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p113
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p113().run());
}
METHOD_INFO:

public String run() {
    BigInteger increasing = Library.binomial(DIGITS + 9, 9).subtract(BigInteger.ONE);
    BigInteger decreasing = Library.binomial(DIGITS + 10, 10).subtract(BigInteger.valueOf(DIGITS + 1));
    BigInteger flat = BigInteger.valueOf(DIGITS * 9);
    return increasing.add(decreasing).subtract(flat).toString();
}
AFTER ANALYZE
null
null
null
Visiting class
p114
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p114().run());
}
METHOD_INFO:

public String run() {
    long[] ways = new long[LENGTH + 1];
    ways[0] = 1;
    ways[1] = 1;
    ways[2] = 1;
    for (int n = 3; n <= LENGTH; n++) {
        long sum = ways[n - 1] + 1;
        for (int k = 3; k < n; k++) sum += ways[n - k - 1];
        ways[n] = sum;
    }
    return Long.toString(ways[LENGTH]);
}
AFTER ANALYZE
null
null
null
Visiting class
p115
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p115().run());
}
METHOD_INFO:

public String run() {
    List<Long> ways = new ArrayList<>();
    ways.add(1L);
    for (int n = 1; ; n++) {
        long sum = ways.get(n - 1);
        for (int k = M; k < n; k++) sum += ways.get(n - k - 1);
        if (n >= M) sum++;
        ways.add(sum);
        if (sum > 1000000) return Long.toString(n);
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p116
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p116().run());
}
METHOD_INFO:

public String run() {
    return Long.toString(countWays(LENGTH, 2) + countWays(LENGTH, 3) + countWays(LENGTH, 4));
}
METHOD_INFO:

private static long countWays(int length, int m) {
    long[] ways = new long[length + 1];
    ways[0] = 1;
    for (int n = 1; n <= length; n++) {
        ways[n] += ways[n - 1];
        if (n >= m) ways[n] += ways[n - m];
    }
    return ways[length] - 1;
}
AFTER ANALYZE
null
null
null
Visiting class
p117
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p117().run());
}
METHOD_INFO:

public String run() {
    long[] ways = new long[LENGTH + 1];
    ways[0] = 1;
    for (int n = 1; n <= LENGTH; n++) {
        for (int k = 1; k <= 4 && k <= n; k++) ways[n] += ways[n - k];
    }
    return Long.toString(ways[LENGTH]);
}
AFTER ANALYZE
null
null
null
Visiting class
p118
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p118().run());
}
METHOD_INFO:

public String run() {
    isPrime = Library.listPrimality(10000);
    count = 0;
    int[] digits = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    do countPrimeSets(digits, 0, 0);     while (Library.nextPermutation(digits));
    return Integer.toString(count);
}
METHOD_INFO:

private void countPrimeSets(int[] digits, int startIndex, int prevNum) {
    if (startIndex == digits.length) count++; else {
        for (int split = startIndex + 1; split <= digits.length; split++) {
            int num = toInteger(digits, startIndex, split);
            if (num > prevNum && isPrime(num)) countPrimeSets(digits, split, num);
        }
    }
}
METHOD_INFO:

private boolean isPrime(int n) {
    if (n < isPrime.length) return isPrime[n]; else return Library.isPrime(n);
}
METHOD_INFO:

private static int toInteger(int[] digits, int start, int end) {
    int result = 0;
    for (int i = start; i < end; i++) result = result * 10 + digits[i];
    return result;
}
AFTER ANALYZE
null
null
null
Visiting class
p119
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p119().run());
}
METHOD_INFO:

public String run() {
    for (BigInteger limit = BigInteger.ONE; ; limit = limit.shiftLeft(8)) {
        SortedSet<BigInteger> candidates = new TreeSet<>();
        for (int k = 2; BigInteger.valueOf(1).shiftLeft(k).compareTo(limit) < 0; k++) {
            for (int n = 2; ; n++) {
                BigInteger pow = BigInteger.valueOf(n).pow(k);
                if (pow.compareTo(limit) >= 0 && pow.toString().length() * 9 < n) break;
                if (pow.compareTo(BigInteger.TEN) >= 0 && isDigitSumPower(pow)) candidates.add(pow);
            }
        }
        if (candidates.size() >= INDEX) return new ArrayList<>(candidates).get(INDEX - 1).toString();
    }
}
METHOD_INFO:

private static boolean isDigitSumPower(BigInteger x) {
    int digitSum = digitSum(x);
    if (digitSum == 1) return false;
    BigInteger base = BigInteger.valueOf(digitSum);
    BigInteger pow = base;
    while (pow.compareTo(x) < 0) pow = pow.multiply(base);
    return pow.equals(x);
}
METHOD_INFO:

private static int digitSum(BigInteger x) {
    if (x.signum() < 1) throw new IllegalArgumentException("Only for positive integers");
    int sum = 0;
    for (char c : x.toString().toCharArray()) sum += c - '0';
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p120
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p120().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (int a = 3; a <= 1000; a++) sum += a * (a - (a % 2 == 0 ? 2 : 1));
    return Integer.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p121
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p121().run());
}
METHOD_INFO:

public String run() {
    BigInteger[][] ways = new BigInteger[TURNS + 1][];
    ways[0] = new BigInteger[]{BigInteger.ONE};
    for (int i = 1; i <= TURNS; i++) {
        ways[i] = new BigInteger[i + 1];
        for (int j = 0; j <= i; j++) {
            BigInteger temp = BigInteger.ZERO;
            if (j < i) temp = ways[i - 1][j].multiply(BigInteger.valueOf(i));
            if (j > 0) temp = temp.add(ways[i - 1][j - 1]);
            ways[i][j] = temp;
        }
    }
    BigInteger numer = BigInteger.ZERO;
    for (int i = TURNS / 2 + 1; i <= TURNS; i++) numer = numer.add(ways[TURNS][i]);
    BigInteger denom = Library.factorial(TURNS + 1);
    return denom.divide(numer).toString();
}
AFTER ANALYZE
null
null
null
Visiting class
p122
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p122().run());
}
METHOD_INFO:

public String run() {
    minOperations = new int[LIMIT + 1];
    Arrays.fill(minOperations, -1);
    minOperations[0] = 0;
    minOperations[1] = 0;
    numUnknown = LIMIT - 1;
    for (int ops = 1; numUnknown > 0; ops++) {
        IntStack chain = new IntStack(ops + 1);
        chain.push(1);
        exploreChains(chain, ops);
    }
    int sum = 0;
    for (int x : minOperations) sum += x;
    return Integer.toString(sum);
}
METHOD_INFO:

private void exploreChains(IntStack chain, int maxOps) {
    if (chain.size > maxOps || numUnknown == 0) return;
    int max = chain.values[chain.size - 1];
    for (int i = chain.size - 1; i >= 0; i--) {
        for (int j = i; j >= 0; j--) {
            int x = chain.values[i] + chain.values[j];
            if (x <= max) break;
            if (x <= LIMIT) {
                chain.push(x);
                if (minOperations[x] == -1) {
                    minOperations[x] = chain.size - 1;
                    numUnknown--;
                }
                exploreChains(chain, maxOps);
                chain.pop();
            }
        }
    }
}
Visiting class
IntStack
METHOD_INFO:

public <init>(int capacity) {
    super();
    values = new int[capacity];
    size = 0;
}
METHOD_INFO:

public void push(int x) {
    if (size >= values.length) throw new IllegalStateException();
    values[size] = x;
    size++;
}
METHOD_INFO:

public int pop() {
    if (size <= 0) throw new IllegalStateException();
    size--;
    return values[size];
}
AFTER ANALYZE
null
null
null
Visiting class
p123
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p123().run());
}
METHOD_INFO:

public String run() {
    int[] primes = Library.listPrimes(PRIME_LIMIT);
    for (int n = 5; n <= primes.length; n += 2) {
        long rem = (long)n * primes[n - 1] * 2;
        if (rem > THRESHOLD) return Integer.toString(n);
    }
    throw new AssertionError("Not found");
}
AFTER ANALYZE
null
null
null
Visiting class
p124
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p124().run());
}
METHOD_INFO:

public String run() {
    int[] rads = new int[LIMIT + 1];
    Arrays.fill(rads, 1, rads.length, 1);
    for (int i = 2; i < rads.length; i++) {
        if (rads[i] == 1) {
            for (int j = i; j < rads.length; j += i) rads[j] *= i;
        }
    }
    IntPair[] data = new IntPair[LIMIT];
    for (int i = 0; i < data.length; i++) data[i] = new IntPair(rads[i + 1], i + 1);
    Arrays.sort(data);
    return Integer.toString(data[10000 - 1].b);
}
Visiting class
IntPair
METHOD_INFO:

public <init>(int a, int b) {
    super();
    this.a = a;
    this.b = b;
}
METHOD_INFO:

public int compareTo(IntPair other) {
    if (a != other.a) return Integer.compare(a, other.a); else return Integer.compare(b, other.b);
}
AFTER ANALYZE
null
null
null
Visiting class
p125
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p125().run());
}
METHOD_INFO:

public String run() {
    Set<Integer> nums = new HashSet<>();
    for (int i = 1; i <= 10000; i++) {
        int sum = i * i;
        for (int j = i + 1; ; j++) {
            sum += j * j;
            if (sum >= 100000000) break;
            if (Library.isPalindrome(sum)) nums.add(sum);
        }
    }
    long sum = 0;
    for (int x : nums) sum += x;
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p127
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p127().run());
}
ADDING ASSERT:
assert a < b;
a < b
605943721
Node[6261334]
METHOD_INFO:

public String run() {
    int[] rads = new int[LIMIT];
    Arrays.fill(rads, 1, rads.length, 1);
    for (int i = 2; i < rads.length; i++) {
        if (rads[i] == 1) {
            for (int j = i; j < rads.length; j += i) rads[j] *= i;
        }
    }
    long sum = 0;
    for (int c = 2; c < LIMIT; c++) {
        if (rads[c] == c) continue;
        for (int a = 1, end = (c - 1) / 2; a <= end; a++) {
            int b = c - a;
            assert a < b;
            if ((long)rads[a] * rads[b] * rads[c] < c && Library.gcd(a, b) == 1) sum += c;
        }
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p128
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p128().run());
}
METHOD_INFO:

public String run() {
    int count = 2;
    for (int ring = 2; ; ring++) {
        if ((long)ring * 12 + 5 > Integer.MAX_VALUE) throw new ArithmeticException();
        if (Library.isPrime(ring * 6 - 1) && Library.isPrime(ring * 6 + 1) && Library.isPrime(ring * 12 + 5)) {
            count++;
            if (count == TARGET) return Long.toString((long)ring * (ring - 1) * 3 + 2);
        }
        if (Library.isPrime(ring * 6 - 1) && Library.isPrime(ring * 6 + 5) && Library.isPrime(ring * 12 - 7)) {
            count++;
            if (count == TARGET) return Long.toString((long)ring * (ring + 1) * 3 + 1);
        }
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p129
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p129().run());
}
METHOD_INFO:

public String run() {
    for (int n = LIMIT; ; n++) {
        if (findLeastDivisibleRepunit(n) > LIMIT) return Integer.toString(n);
    }
}
METHOD_INFO:

private static int findLeastDivisibleRepunit(int n) {
    if (n % 2 == 0 || n % 5 == 0) return 0;
    if (n > Integer.MAX_VALUE / 10) throw new IllegalArgumentException("Arithmetic overflow");
    int sum = 1;
    int pow = 1;
    int k = 1;
    while (sum % n != 0) {
        k++;
        pow = pow * 10 % n;
        sum = (sum + pow) % n;
    }
    return k;
}
AFTER ANALYZE
null
null
null
Visiting class
p130
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p130().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    int found = 0;
    for (int i = 7; found < 25; i += 2) {
        if (i % 5 != 0 && !Library.isPrime(i) && (i - 1) % findLeastDivisibleRepunit(i) == 0) {
            sum += i;
            found++;
        }
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static int findLeastDivisibleRepunit(int n) {
    if (n % 2 == 0 || n % 5 == 0) return 0;
    if (n > Integer.MAX_VALUE / 10) throw new IllegalArgumentException("Arithmetic overflow");
    int sum = 1;
    int pow = 1;
    int k = 1;
    while (sum % n != 0) {
        k++;
        pow = pow * 10 % n;
        sum = (sum + pow) % n;
    }
    return k;
}
AFTER ANALYZE
null
null
null
Visiting class
p132
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p132().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    int count = 0;
    for (int i = 2; count < 40; i++) {
        if (Library.isPrime(i) && repunitMod(1000000000, i) == 0) {
            sum += i;
            count++;
        }
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static int repunitMod(int k, int m) {
    return (Library.powMod(10, k, m * 9) - 1) / 9;
}
AFTER ANALYZE
null
null
null
Visiting class
p133
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p133().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    for (int p : Library.listPrimes(100000)) {
        if (p == 2 || p == 5 || !hasDivisibleRepunit(p)) sum += p;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private static boolean hasDivisibleRepunit(int p) {
    return (BigInteger.TEN.modPow(EXPONENT, BigInteger.valueOf(p * 9)).intValue() - 1) / 9 % p == 0;
}
AFTER ANALYZE
null
null
null
Visiting class
p134
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p134().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    int[] primes = Library.listPrimes(2000000);
    for (int i = 2; primes[i] <= 1000000; i++) {
        int p = primes[i];
        int q = primes[i + 1];
        int k = 1;
        while (k < p) k *= 10;
        long m = (long)(q - p) * Library.reciprocalMod(k % q, q) % q;
        sum += m * k + p;
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p135
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p135().run());
}
METHOD_INFO:

public String run() {
    int[] solutions = new int[LIMIT];
    for (int m = 1; m < LIMIT * 2; m++) {
        for (int k = m / 5 + 1; k * 2 < m; k++) {
            long temp = (long)(m - k) * (k * 5 - m);
            if (temp >= solutions.length) break;
            solutions[(int)temp]++;
        }
    }
    int count = 0;
    for (int x : solutions) {
        if (x == 10) count++;
    }
    return Integer.toString(count);
}
AFTER ANALYZE
null
null
null
Visiting class
p139
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p139().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int s = 3; s * s / 2 < LIMIT; s += 2) {
        for (int t = 1; t < s; t += 2) {
            int a = s * t;
            int b = (s * s - t * t) / 2;
            int c = (s * s + t * t) / 2;
            int p = a + b + c;
            if (p >= LIMIT) break;
            if (c % (a - b) == 0 && Library.gcd(s, t) == 1) count += (LIMIT - 1) / p;
        }
    }
    return Integer.toString(count);
}
AFTER ANALYZE
null
null
null
Visiting class
p142
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p142().run());
}
METHOD_INFO:

public String run() {
    int sumLimit = 10;
    while (true) {
        isSquare = new boolean[sumLimit];
        for (int i = 0; i * i < sumLimit; i++) isSquare[i * i] = true;
        int sum = findSum(sumLimit);
        if (sum != -1) {
            sum = sumLimit;
            break;
        }
        sumLimit *= 10;
    }
    while (true) {
        int sum = findSum(sumLimit);
        if (sum == -1) return Integer.toString(sumLimit);
        sumLimit = sum;
    }
}
METHOD_INFO:

private int findSum(int limit) {
    for (int a = 1; a * a < limit; a++) {
        for (int b = a - 1; b > 0; b--) {
            if ((a + b) % 2 != 0) continue;
            int x = (a * a + b * b) / 2;
            int y = (a * a - b * b) / 2;
            if (x + y + 1 >= limit) continue;
            int zlimit = Math.min(y, limit - x - y);
            for (int c = Library.sqrt(y) + 1; c * c - y < zlimit; c++) {
                int z = c * c - y;
                if (isSquare[x + z] && isSquare[x - z] && isSquare[y - z]) return x + y + z;
            }
        }
    }
    return -1;
}
AFTER ANALYZE
null
null
null
Visiting class
p145
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p145().run());
}
METHOD_INFO:

public String run() {
    int sum = 0;
    for (int digits = 1; digits <= 9; digits++) {
        if (digits % 2 == 0) sum += 20 * Library.pow(30, digits / 2 - 1); else if (digits % 4 == 3) sum += 100 * Library.pow(500, (digits - 3) / 4); else if (digits % 4 == 1) sum += 0; else throw new AssertionError();
    }
    return Integer.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p146
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p146().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    for (int n = 0; n < LIMIT; n += 10) {
        if (hasConsecutivePrimes(n)) sum += n;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private static boolean hasConsecutivePrimes(int n) {
    long n2 = (long)n * n;
    long[] temp = new long[INCREMENTS.length];
    for (int i = 0; i < INCREMENTS.length; i++) temp[i] = n2 + INCREMENTS[i];
    for (int p : primes) {
        for (long x : temp) {
            if (x != p && x % p == 0) return false;
        }
    }
    for (int i = 1; i < INCREMENTS[INCREMENTS.length - 1]; i++) {
        if (Arrays.binarySearch(INCREMENTS, i) < 0 && isPrime(n2 + i)) return false;
    }
    return true;
}
METHOD_INFO:

private static boolean isPrime(long n) {
    int end = (int)Library.sqrt(n);
    for (int p : primes) {
        if (p > end) break;
        if (n != p && n % p == 0) return false;
    }
    return true;
}
AFTER ANALYZE
null
null
null
Visiting class
p149
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p149().run());
}
METHOD_INFO:

public String run() {
    grid = new int[SIZE][SIZE];
    LfgRandom rand = new LfgRandom();
    for (int y = 0; y < grid.length; y++) {
        for (int x = 0; x < grid[y].length; x++) grid[y][x] = rand.next();
    }
    int max = 0;
    for (int i = 0; i < SIZE; i++) {
        max = Math.max(getMaxSubstringSum(0, i, +1, 0), max);
        max = Math.max(getMaxSubstringSum(i, 0, 0, +1), max);
        max = Math.max(getMaxSubstringSum(0, i, +1, +1), max);
        max = Math.max(getMaxSubstringSum(i, 0, +1, +1), max);
        max = Math.max(getMaxSubstringSum(i, 0, -1, +1), max);
        max = Math.max(getMaxSubstringSum(SIZE - 1, i, -1, +1), max);
    }
    return Integer.toString(max);
}
METHOD_INFO:

private int getMaxSubstringSum(int x, int y, int dx, int dy) {
    int max = 0;
    for (int cur = 0; 0 <= x && x < SIZE && 0 <= y && y < SIZE; x += dx, y += dy) {
        cur = Math.max(cur + grid[y][x], 0);
        max = Math.max(cur, max);
    }
    return max;
}
Visiting class
LfgRandom
METHOD_INFO:

public <init>() {
    super();
    k = 1;
    history = new int[55];
    index = 0;
}
METHOD_INFO:

public int next() {
    int result;
    if (k <= 55) {
        result = (int)((100003L - 200003L * k + 300007L * k * k * k) % 1000000) - 500000;
        k++;
    } else {
        result = (getHistory(24) + getHistory(55) + 1000000) % 1000000 - 500000;
    }
    history[index] = result;
    index = (index + 1) % history.length;
    return result;
}
METHOD_INFO:

private int getHistory(int n) {
    if (n <= 0 || n > history.length) throw new IllegalArgumentException();
    return history[(index - n + history.length) % history.length];
}
AFTER ANALYZE
null
null
null
Visiting class
p150
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p150().run());
}
METHOD_INFO:

public String run() {
    LcgRandom rand = new LcgRandom();
    int[][] triangle = new int[ROWS][];
    for (int i = 0; i < triangle.length; i++) {
        triangle[i] = new int[i + 1];
        for (int j = 0; j <= i; j++) triangle[i][j] = rand.next();
    }
    int[][] rowSums = new int[triangle.length][];
    for (int i = 0; i < rowSums.length; i++) {
        rowSums[i] = new int[triangle[i].length + 1];
        rowSums[i][0] = 0;
        for (int j = 0; j <= i; j++) rowSums[i][j + 1] = rowSums[i][j] + triangle[i][j];
    }
    long minSum = 0;
    for (int i = 0; i < triangle.length; i++) {
        for (int j = 0; j < triangle[i].length; j++) {
            long curSum = 0;
            for (int k = i; k < triangle.length; k++) {
                curSum += rowSums[k][k - i + 1 + j] - rowSums[k][j];
                minSum = Math.min(curSum, minSum);
            }
        }
    }
    return Long.toString(minSum);
}
Visiting class
LcgRandom
METHOD_INFO:

public <init>() {
    super();
    state = 0;
}
METHOD_INFO:

public int next() {
    state = (615949 * state + 797807) & ((1 << 20) - 1);
    return state - (1 << 19);
}
AFTER ANALYZE
null
null
null
Visiting class
p151
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p151().run());
}
METHOD_INFO:

public String run() {
    List<Integer> startState = Arrays.asList(1);
    return String.format("%.6f", getExpectedSingles(startState) - 2);
}
METHOD_INFO:

private double getExpectedSingles(List<Integer> state) {
    if (expectedSingles.containsKey(state)) return expectedSingles.get(state);
    double result = 0;
    if (!state.isEmpty()) {
        for (int i = 0; i < state.size(); i++) {
            List<Integer> newState = new ArrayList<>(state);
            int sheet = state.get(i);
            newState.remove(i);
            for (int j = sheet + 1; j <= 5; j++) newState.add(j);
            Collections.sort(newState);
            result += getExpectedSingles(newState);
        }
        result /= state.size();
        if (state.size() == 1) result++;
    }
    expectedSingles.put(state, result);
    return result;
}
AFTER ANALYZE
null
null
null
Visiting class
p155
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p155().run());
}
METHOD_INFO:

public String run() {
    @SuppressWarnings(value = "unchecked")
    Set<FastFraction>[] possible = new Set[SIZE + 1];
    Set<FastFraction> all = new HashSet<>();
    possible[0] = new HashSet<>();
    possible[1] = new HashSet<>();
    possible[1].add(new FastFraction(60, 1));
    all.addAll(possible[1]);
    for (int i = 2; i <= SIZE; i++) {
        Set<FastFraction> poss = new HashSet<>();
        for (int j = 1; j <= i - j; j++) {
            for (FastFraction a : possible[j]) {
                for (FastFraction b : possible[i - j]) {
                    poss.add(a.add(b));
                    poss.add(a.reciprocalAdd(b));
                }
            }
        }
        possible[i] = poss;
        all.addAll(poss);
    }
    return Integer.toString(all.size());
}
Visiting class
FastFraction
METHOD_INFO:

public <init>(long num, long den) {
    super();
    if (den <= 0) throw new IllegalArgumentException();
    int n = (int)num;
    int d = (int)den;
    if (n == num && d == den) {
        int gcd = Library.gcd(n, d);
        if (gcd > 1) {
            n /= gcd;
            d /= gcd;
        }
        numerator = n;
        denominator = d;
        bigFraction = null;
    } else {
        FastFraction temp = new FastFraction(new Fraction(BigInteger.valueOf(num), BigInteger.valueOf(den)));
        numerator = temp.numerator;
        denominator = temp.denominator;
        bigFraction = temp.bigFraction;
    }
}
METHOD_INFO:

public <init>(Fraction frac) {
    super();
    if (frac.numerator.bitLength() <= 31 && frac.denominator.bitLength() <= 31) {
        numerator = frac.numerator.intValue();
        denominator = frac.denominator.intValue();
        bigFraction = null;
    } else {
        numerator = 0;
        denominator = 0;
        bigFraction = frac;
    }
}
METHOD_INFO:

public Fraction toFraction() {
    if (bigFraction == null) return new Fraction(BigInteger.valueOf(numerator), BigInteger.valueOf(denominator)); else return bigFraction;
}
METHOD_INFO:

public FastFraction add(FastFraction other) {
    if (bigFraction == null && other.bigFraction == null) {
        long num = (long)numerator * other.denominator + (long)other.numerator * denominator;
        long den = (long)denominator * other.denominator;
        return new FastFraction(num, den);
    } else return new FastFraction(toFraction().add(other.toFraction()));
}
METHOD_INFO:

public FastFraction reciprocalAdd(FastFraction other) {
    if (bigFraction == null && other.bigFraction == null) {
        long num = (long)numerator * other.numerator;
        long den = (long)numerator * other.denominator + (long)other.numerator * denominator;
        return new FastFraction(num, den);
    } else {
        Fraction x = this.toFraction();
        Fraction y = other.toFraction();
        return new FastFraction(x.multiply(y).divide(x.add(y)));
    }
}
METHOD_INFO:

public boolean equals(Object obj) {
    if (!(obj instanceof FastFraction)) return false;
    FastFraction other = (FastFraction)obj;
    if (bigFraction == null && other.bigFraction == null) return numerator == other.numerator && denominator == other.denominator; else return toFraction().equals(other.toFraction());
}
METHOD_INFO:

public int hashCode() {
    if (bigFraction == null) return numerator + denominator * 1204805; else return bigFraction.hashCode();
}
AFTER ANALYZE
null
null
null
Visiting class
p160
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p160().run());
}
METHOD_INFO:

public String run() {
    return Long.toString(factorialSuffix(1000000000000L));
}
METHOD_INFO:

private static long factorialSuffix(long n) {
    long twos = countFactors(n, 2) - countFactors(n, 5);
    if (twos >= 2505) twos = (twos - 5) % 2500 + 5;
    return factorialish(n) * Library.powMod(2, (int)twos, 100000) % 100000;
}
METHOD_INFO:

private static long factorialish(long n) {
    return evenFactorialish(n) * oddFactorialish(n) % 100000;
}
METHOD_INFO:

private static long evenFactorialish(long n) {
    if (n == 0) return 1; else return factorialish(n / 2);
}
METHOD_INFO:

private static long oddFactorialish(long n) {
    if (n == 0) return 1; else return oddFactorialish(n / 5) * factorialCoprime(n) % 100000;
}
METHOD_INFO:

private static long factorialCoprime(long n) {
    n %= 100000;
    long product = 1;
    for (int i = 1; i <= n; i++) {
        if (i % 2 != 0 && i % 5 != 0) product = i * product % 100000;
    }
    return product;
}
METHOD_INFO:

private static long countFactors(long end, long n) {
    if (end == 0) return 0; else return end / n + countFactors(end / n, n);
}
AFTER ANALYZE
null
null
null
Visiting class
p162
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p162().run());
}
METHOD_INFO:

public String run() {
    BigInteger sum = BigInteger.ZERO;
    for (int n = 1; n <= 16; n++) {
        sum = sum.add(bi(15).multiply(bi(16).pow(n - 1))).subtract(bi(43).multiply(bi(15).pow(n - 1))).add(bi(41).multiply(bi(14).pow(n - 1))).subtract(bi(13).pow(n));
    }
    return sum.toString(16).toUpperCase();
}
METHOD_INFO:

private static BigInteger bi(int n) {
    return BigInteger.valueOf(n);
}
AFTER ANALYZE
null
null
null
Visiting class
p164
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p164().run());
}
METHOD_INFO:

public String run() {
    BigInteger[][] ways = new BigInteger[DIGITS + CONSECUTIVE + 1][Library.pow(BASE, CONSECUTIVE)];
    ways[0][0] = BigInteger.ONE;
    for (int prefix = 1; prefix < ways[0].length; prefix++) ways[0][prefix] = BigInteger.ZERO;
    for (int digits = 1; digits < ways.length; digits++) {
        for (int prefix = 0; prefix < ways[digits].length; prefix++) {
            BigInteger sum = BigInteger.ZERO;
            if (digitSum(prefix) <= MAX_SUM) {
                for (int nextDigit = 0; nextDigit < BASE; nextDigit++) sum = sum.add(ways[digits - 1][prefix % Library.pow(BASE, CONSECUTIVE - 1) * BASE + nextDigit]);
            }
            ways[digits][prefix] = sum;
        }
    }
    return ways[DIGITS + CONSECUTIVE][0].subtract(ways[DIGITS + CONSECUTIVE - 1][0]).toString();
}
METHOD_INFO:

private static int digitSum(int n) {
    int sum = 0;
    for (; n != 0; n /= 10) sum += n % 10;
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p166
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p166().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    int[] num = new int[8];
    do {
        int a = num[0];
        int b = num[1];
        int c = num[2];
        int d = num[3];
        int e = num[4];
        int g = num[5];
        int i = num[6];
        int k = num[7];
        int m = b + c + d - e - i;
        if (m < 0 || m > 9) continue;
        int o = a + b + d - g - k;
        if (o < 0 || o > 9) continue;
        int j = a + b + c - g - m;
        if (j < 0 || j > 9) continue;
        int l = a + b + c + d - i - j - k;
        if (l < 0 || l > 9) continue;
        int f = b + c + d * 2 - e - i - k;
        if (f < 0 || f > 9) continue;
        int h = a + b + c + d - e - f - g;
        if (h < 0 || h > 9) continue;
        int n = a + c + d - f - j;
        if (n < 0 || n > 9) continue;
        int p = a + b + c - h - l;
        if (p < 0 || p > 9) continue;
        count++;
    }     while (increment(num));
    return Integer.toString(count);
}
METHOD_INFO:

private static boolean increment(int[] num) {
    int i = 0;
    while (num[i] == 9) {
        num[i] = 0;
        i++;
        if (i == num.length) return false;
    }
    num[i]++;
    return true;
}
AFTER ANALYZE
null
null
null
Visiting class
p169
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p169().run());
}
METHOD_INFO:

public String run() {
    return countWays(NUMBER, NUMBER.bitLength() - 1, 2).toString();
}
METHOD_INFO:

private BigInteger countWays(BigInteger number, int exponent, int repetitions) {
    List<BigInteger> key = Arrays.asList(number, BigInteger.valueOf(exponent), BigInteger.valueOf(repetitions));
    if (ways.containsKey(key)) return ways.get(key);
    BigInteger result;
    if (exponent < 0) result = number.equals(BigInteger.ZERO) ? BigInteger.ONE : BigInteger.ZERO; else {
        result = countWays(number, exponent - 1, 2);
        BigInteger pow = BigInteger.ONE.shiftLeft(exponent);
        BigInteger upper = pow.multiply(BigInteger.valueOf(repetitions + 2));
        if (repetitions > 0 && pow.compareTo(number) <= 0 && number.compareTo(upper) < 0) result = result.add(countWays(number.subtract(pow), exponent, repetitions - 1));
    }
    ways.put(key, result);
    return result;
}
AFTER ANALYZE
null
null
null
Visiting class
p171
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p171().run());
}
METHOD_INFO:

public String run() {
    int MAX_SQR_DIGIT_SUM = (BASE - 1) * (BASE - 1) * LENGTH;
    long[][] sum = new long[LENGTH + 1][MAX_SQR_DIGIT_SUM + 1];
    long[][] count = new long[LENGTH + 1][MAX_SQR_DIGIT_SUM + 1];
    count[0][0] = 1;
    for (int i = 1; i <= LENGTH; i++) {
        for (int j = 0; j < BASE; j++) {
            for (int k = 0; k + j * j <= MAX_SQR_DIGIT_SUM; k++) {
                sum[i][k + j * j] = (sum[i][k + j * j] + sum[i - 1][k] + Library.powMod(BASE, i - 1, MODULUS) * j % MODULUS * count[i - 1][k]) % MODULUS;
                count[i][k + j * j] = (count[i][k + j * j] + count[i - 1][k]) % MODULUS;
            }
        }
    }
    long s = 0;
    for (int i = 1; i * i <= MAX_SQR_DIGIT_SUM; i++) s = (s + sum[LENGTH][i * i]) % MODULUS;
    return String.format("%09d", s);
}
AFTER ANALYZE
null
null
null
Visiting class
p172
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p172().run());
}
METHOD_INFO:

public String run() {
    BigInteger ways = partitionAndCount(LENGTH, MAX_COUNT, new ArrayList<Integer>());
    BigInteger BASE_BI = BigInteger.valueOf(BASE);
    ways = ways.multiply(BASE_BI.subtract(BigInteger.ONE));
    ways = divideExactly(ways, BASE_BI);
    return ways.toString();
}
METHOD_INFO:

private BigInteger partitionAndCount(int sum, int max, List<Integer> terms) {
    if (terms.size() == BASE) {
        if (sum == 0) return countWays(terms); else return BigInteger.ZERO;
    } else {
        BigInteger result = BigInteger.ZERO;
        for (int i = Math.min(max, sum); i >= 0; i--) {
            terms.add(i);
            result = result.add(partitionAndCount(sum - i, i, terms));
            terms.remove(terms.size() - 1);
        }
        return result;
    }
}
METHOD_INFO:

private BigInteger countWays(List<Integer> freqs) {
    int[] histogram = new int[MAX_COUNT + 1];
    for (int x : freqs) histogram[x]++;
    BigInteger ways = Library.factorial(BASE);
    for (int x : histogram) ways = ways.divide(Library.factorial(x));
    ways = ways.multiply(Library.factorial(LENGTH));
    for (int x : freqs) ways = ways.divide(Library.factorial(x));
    return ways;
}
METHOD_INFO:

private static BigInteger divideExactly(BigInteger x, BigInteger y) {
    BigInteger[] temp = x.divideAndRemainder(y);
    if (temp[1].signum() != 0) throw new IllegalArgumentException("Not divisible");
    return temp[0];
}
AFTER ANALYZE
null
null
null
Visiting class
p173
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p173().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int n = 3; n <= TILES / 4 + 1; n++) {
        for (int k = n - 2; k >= 1; k -= 2) {
            if ((long)n * n - (long)k * k > TILES) break;
            count++;
        }
    }
    return Integer.toString(count);
}
AFTER ANALYZE
null
null
null
Visiting class
p174
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p174().run());
}
METHOD_INFO:

public String run() {
    int[] type = new int[SIZE_LIMIT + 1];
    for (int n = 3; (n - 1) * 4 <= SIZE_LIMIT; n++) {
        for (int m = n - 2; m >= 1; m -= 2) {
            int tiles = n * n - m * m;
            if (tiles > SIZE_LIMIT) break;
            type[tiles]++;
        }
    }
    int count = 0;
    for (int t : type) {
        if (1 <= t && t <= TYPE_LIMIT) count++;
    }
    return Integer.toString(count);
}
AFTER ANALYZE
null
null
null
Visiting class
p178
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p178().run());
}
METHOD_INFO:

public String run() {
    BigInteger[][][][] ways = new BigInteger[LIMIT + 1][10][10][10];
    BigInteger sum = BigInteger.ZERO;
    for (int digits = 0; digits < ways.length; digits++) {
        for (int head = 0; head < 10; head++) {
            for (int low = 0; low < 10; low++) {
                for (int high = 0; high < 10; high++) {
                    BigInteger val;
                    if (digits <= 1) val = (low == head && head == high) ? BigInteger.ONE : BigInteger.ZERO; else {
                        val = BigInteger.ZERO;
                        BigInteger[][][] prevWays = ways[digits - 1];
                        if (head - 1 >= low) {
                            val = val.add(prevWays[head - 1][low][high]);
                            if (head == high) val = val.add(prevWays[head - 1][low][high - 1]);
                        }
                        if (head + 1 <= high) {
                            val = val.add(prevWays[head + 1][low][high]);
                            if (head == low) val = val.add(prevWays[head + 1][low + 1][high]);
                        }
                    }
                    ways[digits][head][low][high] = val;
                    if (head > 0 && low == 0 && high == 9) sum = sum.add(val);
                }
            }
        }
    }
    return sum.toString();
}
AFTER ANALYZE
null
null
null
Visiting class
p179
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p179().run());
}
METHOD_INFO:

public String run() {
    int[] numDivisors = new int[LIMIT + 1];
    Arrays.fill(numDivisors, 2);
    for (int i = 2; i < numDivisors.length; i++) {
        for (int j = i * 2; j < numDivisors.length; j += i) numDivisors[j]++;
    }
    int count = 0;
    for (int i = 2; i < numDivisors.length - 1; i++) {
        if (numDivisors[i] == numDivisors[i + 1]) count++;
    }
    return Integer.toString(count);
}
AFTER ANALYZE
null
null
null
Visiting class
p182
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p182().run());
}
METHOD_INFO:

public String run() {
    int[] numUnconcealedP = countAllUnconcealed(P);
    int[] numUnconcealedQ = countAllUnconcealed(Q);
    int minUnconcealedP = Integer.MAX_VALUE;
    for (int x : numUnconcealedP) minUnconcealedP = Math.min(x, minUnconcealedP);
    int minUnconcealedQ = Integer.MAX_VALUE;
    for (int x : numUnconcealedQ) minUnconcealedQ = Math.min(x, minUnconcealedQ);
    long sum = 0;
    for (int e = 0; e < TOTIENT; e++) {
        if (numUnconcealedP[e % (P - 1)] == minUnconcealedP && numUnconcealedQ[e % (Q - 1)] == minUnconcealedQ) sum += e;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private static int[] countAllUnconcealed(int prime) {
    int[] numUnconcealed = new int[prime - 1];
    for (int e = 0; e < numUnconcealed.length; e++) {
        if (Library.gcd(e, prime - 1) == 1) numUnconcealed[e] = countUnconcealed(prime, e); else numUnconcealed[e] = Integer.MAX_VALUE;
    }
    return numUnconcealed;
}
METHOD_INFO:

private static int countUnconcealed(int modulus, int e) {
    int count = 0;
    for (int m = 0; m < modulus; m++) {
        if (Library.powMod(m, e, modulus) == m) count++;
    }
    return count;
}
AFTER ANALYZE
null
null
null
Visiting class
p186
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p186().run());
}
METHOD_INFO:

public String run() {
    DisjointSet ds = new DisjointSet(1000000);
    LfgRandom rand = new LfgRandom();
    int i = 0;
    while (ds.size(524287) < 990000) {
        int caller = rand.next();
        int callee = rand.next();
        if (caller != callee) {
            ds.union(caller, callee);
            i++;
        }
    }
    return Integer.toString(i);
}
Visiting class
DisjointSet
METHOD_INFO:

public <init>(int size) {
    super();
    nodes = new Node[size];
    for (int i = 0; i < size; i++) nodes[i] = new Node();
}
METHOD_INFO:

private Node find(int i) {
    return find(nodes[i]);
}
METHOD_INFO:

private static Node find(Node node) {
    if (node.parent != node) node.parent = find(node.parent);
    return node.parent;
}
METHOD_INFO:

public void union(int i, int j) {
    Node x = find(i);
    Node y = find(j);
    if (x == y) return;
    if (x.rank == y.rank) x.rank++; else if (x.rank < y.rank) {
        Node z = x;
        x = y;
        y = z;
    }
    y.parent = x;
    x.size += y.size;
    y.size = 0;
}
METHOD_INFO:

public int size(int i) {
    return find(i).size;
}
Visiting class
Node
METHOD_INFO:

public <init>() {
    super();
    parent = this;
    rank = 0;
    size = 1;
}
Visiting class
LfgRandom
METHOD_INFO:

public <init>() {
    super();
    k = 1;
    history = new int[55];
    index = 0;
}
METHOD_INFO:

public int next() {
    int result;
    if (k <= 55) {
        result = (int)((100003L - 200003L * k + 300007L * k * k * k) % 1000000);
        k++;
    } else result = (getHistory(24) + getHistory(55)) % 1000000;
    history[index] = result;
    index++;
    if (index == history.length) index = 0;
    return result;
}
METHOD_INFO:

private int getHistory(int n) {
    int i = index - n;
    if (i < 0) i += history.length;
    return history[i];
}
AFTER ANALYZE
null
null
null
Visiting class
p187
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p187().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    int[] primes = Library.listPrimes(LIMIT / 2);
    for (int i = 0, sqrt = Library.sqrt(LIMIT); i < primes.length && primes[i] <= sqrt; i++) {
        int end = Arrays.binarySearch(primes, LIMIT / primes[i]);
        if (end >= 0) end++; else end = -end - 1;
        count += end - i;
    }
    return Integer.toString(count);
}
AFTER ANALYZE
null
null
null
Visiting class
p188
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p188().run());
}
METHOD_INFO:

public String run() {
    return Integer.toString(tetrationMod(1777, 1855, Library.pow(10, 8)));
}
METHOD_INFO:

private static int tetrationMod(int x, int y, int m) {
    if (y == 1) return x % m; else return Library.powMod(x, tetrationMod(x, y - 1, Library.totient(m)), m);
}
AFTER ANALYZE
null
null
null
Visiting class
p191
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p191().run());
}
METHOD_INFO:

public String run() {
    long[][][] numPrizeStrings = new long[NUM_DAYS + 1][MAX_ABSENT + 1][MAX_LATE + 1];
    numPrizeStrings[0][0][0] = 1;
    for (int i = 1; i <= NUM_DAYS; i++) {
        for (int j = 0; j <= MAX_ABSENT; j++) {
            for (int k = 0; k <= MAX_LATE; k++) {
                long sum;
                if (j == 0) {
                    sum = 0;
                    for (int l = 0; l <= MAX_ABSENT; l++) sum += numPrizeStrings[i - 1][l][k];
                    if (k > 0) {
                        for (int l = 0; l <= MAX_ABSENT; l++) sum += numPrizeStrings[i - 1][l][k - 1];
                    }
                } else sum = numPrizeStrings[i - 1][j - 1][k];
                numPrizeStrings[i][j][k] = sum;
            }
        }
    }
    long sum = 0;
    for (int j = 0; j <= MAX_ABSENT; j++) {
        for (int k = 0; k <= MAX_LATE; k++) sum += numPrizeStrings[NUM_DAYS][j][k];
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p197
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p197().run());
}
METHOD_INFO:

public String run() {
    double x = -1;
    double y = -1;
    long i = 0;
    for (; i < ITERATIONS; i++) {
        if (i > 0 && x == y) break;
        x = f(x);
        y = f(f(y));
    }
    long remain = (ITERATIONS - i) % i;
    for (; remain > 0; remain--) x = f(x);
    double answer = x + f(x);
    answer = Math.floor(answer * 1.0E9) / 1.0E9;
    return String.format("%.9f", answer);
}
METHOD_INFO:

private static double f(double x) {
    return Math.floor(Math.pow(2, 30.403243784 - x * x)) / 1.0E9;
}
AFTER ANALYZE
null
null
null
Visiting class
p203
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p203().run());
}
METHOD_INFO:

public String run() {
    Set<Long> numbers = new HashSet<>();
    long max = 0;
    for (int n = 0; n <= 50; n++) {
        for (int k = 0; k <= n; k++) {
            BigInteger x = Library.binomial(n, k);
            if (x.bitLength() >= 64) throw new AssertionError("Number too large to handle");
            numbers.add(x.longValue());
            max = Math.max(x.longValue(), max);
        }
    }
    int[] primes = Library.listPrimes((int)Library.sqrt(max));
    primesSquared = new long[primes.length];
    for (int i = 0; i < primes.length; i++) primesSquared[i] = (long)primes[i] * primes[i];
    long sum = 0;
    for (long n : numbers) {
        if (isSquarefree(n)) sum += n;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private boolean isSquarefree(long n) {
    for (long p2 : primesSquared) {
        if (p2 > n) break;
        if (n % p2 == 0) return false;
    }
    return true;
}
AFTER ANALYZE
null
null
null
Visiting class
p204
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p204().run());
}
METHOD_INFO:

public String run() {
    return Integer.toString(count(0, 1));
}
METHOD_INFO:

private int count(int primeIndex, long product) {
    if (primeIndex == primes.length) return product <= LIMIT ? 1 : 0; else {
        int count = 0;
        while (product <= LIMIT) {
            count += count(primeIndex + 1, product);
            product *= primes[primeIndex];
        }
        return count;
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p205
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p205().run());
}
METHOD_INFO:

public String run() {
    int[] ninePyramidalPdf = {1};
    for (int i = 0; i < 9; i++) ninePyramidalPdf = convolve(ninePyramidalPdf, PYRAMIDAL_DIE_PDF);
    int[] sixCubicPdf = {1};
    for (int i = 0; i < 6; i++) sixCubicPdf = convolve(sixCubicPdf, CUBIC_DIE_PDF);
    long numer = 0;
    for (int i = 0; i < ninePyramidalPdf.length; i++) numer += (long)ninePyramidalPdf[i] * sum(sixCubicPdf, 0, i);
    long denom = (long)sum(ninePyramidalPdf, 0, ninePyramidalPdf.length) * sum(sixCubicPdf, 0, sixCubicPdf.length);
    return String.format("%.7f", (double)numer / denom);
}
METHOD_INFO:

private static int[] convolve(int[] a, int[] b) {
    int[] c = new int[a.length + b.length - 1];
    for (int i = 0; i < a.length; i++) {
        for (int j = 0; j < b.length; j++) c[i + j] += a[i] * b[j];
    }
    return c;
}
METHOD_INFO:

private static int sum(int[] array, int start, int end) {
    int sum = 0;
    for (int i = start; i < end; i++) sum += array[i];
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p206
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p206().run());
}
METHOD_INFO:

public String run() {
    long n = 1000000000;
    int[] ndigits = new int[10];
    int[] n2digits = new int[19];
    long temp = n;
    for (int i = 0; i < ndigits.length; i++, temp /= 10) ndigits[i] = (int)(temp % 10);
    temp = n * n;
    for (int i = 0; i < n2digits.length; i++, temp /= 10) n2digits[i] = (int)(temp % 10);
    while (!isConcealedSquare(n2digits)) {
        add20n(ndigits, n2digits);
        add10Pow(n2digits, 2);
        n += 10;
        add10Pow(ndigits, 1);
    }
    return Long.toString(n);
}
METHOD_INFO:

private static boolean isConcealedSquare(int[] n) {
    for (int i = 1; i <= 9; i++) {
        if (n[20 - i * 2] != i) return false;
    }
    return n[0] == 0;
}
METHOD_INFO:

private static void add10Pow(int[] n, int i) {
    while (n[i] == 9) {
        n[i] = 0;
        i++;
    }
    n[i]++;
}
METHOD_INFO:

private static void add20n(int[] n, int[] n2) {
    int carry = 0;
    int i;
    for (i = 0; i < n.length; i++) {
        int sum = n[i] * 2 + n2[i + 1] + carry;
        n2[i + 1] = sum % 10;
        carry = sum / 10;
    }
    for (i++; carry > 0; i++) {
        int sum = n2[i] + carry;
        n2[i] = sum % 10;
        carry = sum / 10;
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p208
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p208().run());
}
METHOD_INFO:

public String run() {
    Map<State, BigInteger> reachable = new HashMap<>();
    reachable.put(new State(0, 0, 0, 0, 0), BigInteger.ONE);
    for (int i = 0; i < LIMIT; i++) {
        Map<State, BigInteger> newReachable = new HashMap<>();
        for (Map.Entry<State, BigInteger> entry : reachable.entrySet()) {
            State state = entry.getKey();
            BigInteger ways = entry.getValue();
            State acw = state.move(true);
            BigInteger temp = newReachable.containsKey(acw) ? newReachable.get(acw) : BigInteger.ZERO;
            newReachable.put(acw, temp.add(ways));
            State cw = state.move(false);
            temp = newReachable.containsKey(cw) ? newReachable.get(cw) : BigInteger.ZERO;
            newReachable.put(cw, temp.add(ways));
        }
        reachable = newReachable;
    }
    BigInteger sum = BigInteger.ZERO;
    for (int dir = 0; dir < 5; dir++) {
        State st = new State(dir, 0, 0, 0, 0);
        if (reachable.containsKey(st)) sum = sum.add(reachable.get(st));
    }
    return sum.toString();
}
Visiting class
State
METHOD_INFO:

public <init>(int dir, int xComp0, int xComp1, int yComp0, int yComp1) {
    super();
    if (dir < 0 || dir >= 5) throw new IllegalArgumentException();
    direction = dir;
    xComponent0 = xComp0;
    xComponent1 = xComp1;
    yComponent0 = yComp0;
    yComponent1 = yComp1;
}
METHOD_INFO:

public State move(boolean anticlockwise) {
    int sign = anticlockwise ? +1 : -1;
    int[] entry = ANTICLOCKWISE_MOVES[(direction * sign + 5) % 5];
    return new State((direction + sign + 5) % 5, xComponent0 + entry[0] * sign, xComponent1 + entry[1] * sign, yComponent0 + entry[2], yComponent1 + entry[3]);
}
METHOD_INFO:

public boolean equals(Object obj) {
    if (!(obj instanceof State)) return false;
    State other = (State)obj;
    return direction == other.direction && xComponent0 == other.xComponent0 && xComponent1 == other.xComponent1 && yComponent0 == other.yComponent0 && yComponent1 == other.yComponent1;
}
METHOD_INFO:

public int hashCode() {
    return Objects.hash(direction, xComponent0, xComponent1, yComponent0, yComponent1);
}
AFTER ANALYZE
null
null
null
Visiting class
p211
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p211().run());
}
METHOD_INFO:

public String run() {
    isResidue = new boolean[RESIDUE_TEST];
    for (int i = 0; i < RESIDUE_TEST; i++) isResidue[i * i % RESIDUE_TEST] = true;
    long[] sigma2 = listSigma2(LIMIT - 1);
    long sum = 0;
    for (int i = 1; i < LIMIT; i++) {
        if (isPerfectSquare(sigma2[i])) sum += i;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private static long[] listSigma2(int n) {
    int sqrt = Library.sqrt(n);
    short[] quasiPrimeFactor = new short[n + 1];
    for (int i = 2; i <= sqrt; i++) {
        if (quasiPrimeFactor[i] == 0) {
            quasiPrimeFactor[i] = (short)i;
            if ((long)i * i <= n) {
                for (int j = i * i; j <= n; j += i) {
                    if (quasiPrimeFactor[j] == 0) quasiPrimeFactor[j] = (short)i;
                }
            }
        }
    }
    long[] sigma2 = new long[n + 1];
    sigma2[1] = 1;
    for (int i = 2; i < sigma2.length; i++) {
        int p = quasiPrimeFactor[i];
        if (p == 0) p = i;
        long sum = 1;
        int j = i;
        long p2 = (long)p * p;
        for (long k = p2; j % p == 0; j /= p, k *= p2) sum += k;
        sigma2[i] = sum * sigma2[j];
    }
    return sigma2;
}
METHOD_INFO:

private boolean isPerfectSquare(long x) {
    if (!isResidue[(int)(x % RESIDUE_TEST)]) return false;
    long y = 0;
    for (long i = 1L << 31; i != 0; i >>>= 1) {
        y |= i;
        if (y > 3037000499L || y * y > x) y ^= i;
    }
    return y * y == x;
}
AFTER ANALYZE
null
null
null
Visiting class
p214
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p214().run());
}
METHOD_INFO:

public String run() {
    int[] totient = Library.listTotients(LIMIT - 1);
    int[] totientChainLength = new int[totient.length];
    totientChainLength[0] = 0;
    long sum = 0;
    for (int i = 1; i < totient.length; i++) {
        int chainlen = totientChainLength[totient[i]] + 1;
        totientChainLength[i] = chainlen;
        if (chainlen == 25 && totient[i] == i - 1) sum += i;
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p215
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p215().run());
}
METHOD_INFO:

public String run() {
    List<int[]> crackPositions = new ArrayList<>();
    getCrackPositions(new Stack<Integer>(), 0, crackPositions);
    BigInteger[] ways = new BigInteger[crackPositions.size()];
    Arrays.fill(ways, BigInteger.ONE);
    for (int i = 1; i < HEIGHT; i++) {
        BigInteger[] newWays = new BigInteger[ways.length];
        for (int j = 0; j < newWays.length; j++) {
            BigInteger sum = BigInteger.ZERO;
            for (int k = 0; k < ways.length; k++) {
                if (areDisjointSorted(crackPositions.get(j), crackPositions.get(k))) sum = sum.add(ways[k]);
            }
            newWays[j] = sum;
        }
        ways = newWays;
    }
    BigInteger sum = BigInteger.ZERO;
    for (BigInteger x : ways) sum = sum.add(x);
    return sum.toString();
}
METHOD_INFO:

private static void getCrackPositions(Stack<Integer> cracks, int position, List<int[]> result) {
    if (position < 0) throw new IllegalArgumentException(); else if (position < WIDTH) {
        for (int i = 2; i <= 3; i++) {
            cracks.push(position + i);
            getCrackPositions(cracks, position + i, result);
            cracks.pop();
        }
    } else if (position == WIDTH) {
        int[] temp = new int[cracks.size() - 1];
        for (int i = 0; i < temp.length; i++) temp[i] = cracks.get(i);
        result.add(temp);
    } else return;
}
METHOD_INFO:

private static boolean areDisjointSorted(int[] a, int[] b) {
    for (int i = 0, j = 0; i < a.length && j < b.length; ) {
        if (a[i] == b[j]) return false; else if (a[i] < b[j]) i++; else if (a[i] > b[j]) j++; else throw new AssertionError();
    }
    return true;
}
AFTER ANALYZE
null
null
null
Visiting class
p216
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p216().run());
}
ADDING ASSERT:
assert sequence[j] % p == 0;
sequence[j] % p == 0
2147432463
Node[6270122]
ADDING ASSERT:
assert sequence[j] % p == 0;
sequence[j] % p == 0
1652598086
Node[6270168]
METHOD_INFO:

public String run() {
    long[] sequence = new long[LIMIT + 1];
    sequence[0] = sequence[1] = -1;
    for (int i = 2; i < sequence.length; i++) sequence[i] = 2L * i * i - 1;
    int count = 0;
    for (int i = 2; i < sequence.length; i++) {
        long term = sequence[i];
        if (term == 2L * i * i - 1) count++;
        if (1 < term && term <= LIMIT * 2) {
            int p = (int)term;
            for (int j = i + p; j < sequence.length; j += p) {
                assert sequence[j] % p == 0;
                do sequence[j] /= p;                 while (sequence[j] % p == 0);
            }
            for (int j = i + (p - i) * 2 % p; j < sequence.length; j += p) {
                assert sequence[j] % p == 0;
                do sequence[j] /= p;                 while (sequence[j] % p == 0);
            }
        }
    }
    return Integer.toString(count);
}
AFTER ANALYZE
null
null
null
Visiting class
p218
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p218().run());
}
METHOD_INFO:

public String run() {
    return "0";
}
AFTER ANALYZE
null
null
null
Visiting class
p222
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p222().run());
}
METHOD_INFO:

public String run() {
    sphereRadii = new double[21];
    for (int i = 0; i < sphereRadii.length; i++) sphereRadii[i] = (i + 30) * 1000;
    minLength = new double[sphereRadii.length][1 << sphereRadii.length];
    double min = Double.POSITIVE_INFINITY;
    for (int i = 0; i < sphereRadii.length; i++) min = Math.min(findMinimumLength(i, (1 << sphereRadii.length) - 1) + sphereRadii[i], min);
    return Long.toString(Math.round(min));
}
METHOD_INFO:

private double findMinimumLength(int currentSphereIndex, int setOfSpheres) {
    if ((setOfSpheres & (1 << currentSphereIndex)) == 0) throw new IllegalArgumentException();
    if (minLength[currentSphereIndex][setOfSpheres] == 0) {
        double result;
        if (Integer.bitCount(setOfSpheres) == 1) result = sphereRadii[currentSphereIndex]; else {
            result = Double.POSITIVE_INFINITY;
            int newSetOfSpheres = setOfSpheres ^ (1 << currentSphereIndex);
            for (int i = 0; i < sphereRadii.length; i++) {
                if ((newSetOfSpheres & (1 << i)) == 0) continue;
                double temp = Math.sqrt((sphereRadii[i] + sphereRadii[currentSphereIndex] - 50000) * 200000);
                temp += findMinimumLength(i, newSetOfSpheres);
                result = Math.min(temp, result);
            }
        }
        minLength[currentSphereIndex][setOfSpheres] = result;
    }
    return minLength[currentSphereIndex][setOfSpheres];
}
AFTER ANALYZE
null
null
null
Visiting class
p225
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p225().run());
}
METHOD_INFO:

public String run() {
    int count = 0;
    for (int i = 1; ; i += 2) {
        if (!hasTribonacciMultiple(i)) {
            count++;
            if (count == INDEX) return Integer.toString(i);
        }
    }
}
METHOD_INFO:

private static boolean hasTribonacciMultiple(int modulus) {
    int[] slow = {1, 1, 1};
    int[] fast = slow.clone();
    for (boolean head = true; ; head = false) {
        if (slow[0] % modulus == 0) return true;
        if (!head && Arrays.equals(slow, fast)) return false;
        tribonacci(slow, modulus);
        tribonacci(fast, modulus);
        tribonacci(fast, modulus);
    }
}
METHOD_INFO:

private static void tribonacci(int[] state, int mod) {
    int a = state[0];
    int b = state[1];
    int c = state[2];
    state[0] = b;
    state[1] = c;
    state[2] = (a + b + c) % mod;
}
AFTER ANALYZE
null
null
null
Visiting class
p231
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p231().run());
}
METHOD_INFO:

public String run() {
    smallestPrimeFactor = Library.listSmallestPrimeFactors(N);
    return Long.toString(factorialPrimeFactorSum(N) - factorialPrimeFactorSum(K) - factorialPrimeFactorSum(N - K));
}
METHOD_INFO:

private long factorialPrimeFactorSum(int n) {
    long sum = 0;
    for (int i = 1; i <= n; i++) {
        int j = i;
        while (j > 1) {
            int p = smallestPrimeFactor[j];
            sum += p;
            j /= p;
        }
    }
    return sum;
}
AFTER ANALYZE
null
null
null
Visiting class
p243
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p243().run());
}
METHOD_INFO:

public String run() {
    BigInteger totient = BigInteger.ONE;
    BigInteger denominator = BigInteger.ONE;
    for (int p = 2; ; ) {
        totient = totient.multiply(BigInteger.valueOf(p - 1));
        denominator = denominator.multiply(BigInteger.valueOf(p));
        do p++;         while (!Library.isPrime(p));
        if (new Fraction(totient, denominator).compareTo(TARGET) < 0) {
            for (int i = 1; i < p; i++) {
                BigInteger numer = BigInteger.valueOf(i).multiply(totient);
                BigInteger denom = BigInteger.valueOf(i).multiply(denominator);
                if (new Fraction(numer, denom.subtract(BigInteger.ONE)).compareTo(TARGET) < 0) return denom.toString();
            }
        }
    }
}
AFTER ANALYZE
null
null
null
Visiting class
p249
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p249().run());
}
METHOD_INFO:

public String run() {
    boolean[] isPrime = Library.listPrimality(LIMIT * LIMIT / 2);
    long[] numSubsets = new long[LIMIT * LIMIT / 2];
    numSubsets[0] = 1;
    int maxSum = 0;
    for (int i = 0; i < LIMIT; i++) {
        if (!isPrime[i]) continue;
        maxSum += i;
        for (int j = maxSum; j >= i; j--) {
            long temp = numSubsets[j] + numSubsets[j - i];
            if (temp < MODULUS) numSubsets[j] = temp; else numSubsets[j] = temp - MODULUS;
        }
    }
    long sum = 0;
    for (int i = 0; i < numSubsets.length; i++) {
        if (isPrime[i]) sum = (sum + numSubsets[i]) % MODULUS;
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p250
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p250().run());
}
METHOD_INFO:

public String run() {
    long[] numSubsets = new long[250];
    numSubsets[0] = 1;
    for (int i = 1; i <= 250250; i++) {
        int temp = Library.powMod(i, i, 250);
        long[] newArray = new long[numSubsets.length];
        for (int j = 0; j < 250; j++) newArray[(j + temp) % 250] = (numSubsets[j] + numSubsets[(j + temp) % 250]) % MODULUS;
        numSubsets = newArray;
    }
    return Long.toString((numSubsets[0] - 1 + MODULUS) % MODULUS);
}
AFTER ANALYZE
null
null
null
Visiting class
p265
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p265().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    int start = (1 << (TWO_POW_N - N - 1)) + 1;
    int end = 1 << (TWO_POW_N - N);
    for (int i = start; i < end; i += 2) {
        if (checkArrangement(i)) sum += i;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private static boolean checkArrangement(int digits) {
    int seen = 0;
    long temp = (digits & 4294967295L) | ((digits & 4294967295L) << TWO_POW_N);
    for (int i = 0; i < TWO_POW_N; i++) seen |= 1 << ((int)(temp >>> i) & MASK);
    return seen == FULL_SET;
}
AFTER ANALYZE
null
null
null
Visiting class
p267
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p267().run());
}
METHOD_INFO:

public String run() {
    int maxIndex = -1;
    int prevChangeLevel = 1;
    for (int level = 1; level - prevChangeLevel <= 8; level++) {
        if (level > 30) throw new AssertionError();
        double scaler = Math.pow(2, -level);
        for (int i = 1, end = 1 << level; i < end; i += 2) {
            int index = calcBillionaireProbability(i * scaler);
            if (index > maxIndex) {
                maxIndex = index;
                prevChangeLevel = level;
            }
        }
    }
    BigInteger binomialSum = BigInteger.ZERO;
    for (int i = 0; i < maxIndex; i++) binomialSum = binomialSum.add(Library.binomial(TRIALS, i));
    BigInteger denominator = BigInteger.ONE.shiftLeft(TRIALS);
    return roundToDecimal(new Fraction(binomialSum, denominator), 12);
}
METHOD_INFO:

private static int calcBillionaireProbability(double betProportion) {
    double initCapital = 1;
    int i;
    for (i = 0; i <= TRIALS; i++) {
        double finalCapital = initCapital * Math.pow(1 - betProportion, i) * Math.pow(1 + betProportion * 2, TRIALS - i);
        if (finalCapital < 1.0E9) break;
    }
    return i;
}
METHOD_INFO:

private static String roundToDecimal(Fraction num, int places) {
    if (num.numerator.signum() == -1) return "-" + roundToDecimal(new Fraction(num.numerator.negate(), num.denominator), places);
    num = new Fraction(num.numerator.multiply(BigInteger.TEN.pow(places)), num.denominator);
    BigInteger whole = num.numerator.divide(num.denominator);
    Fraction frac = new Fraction(num.numerator.mod(num.denominator), num.denominator);
    Fraction HALF = new Fraction(BigInteger.ONE, BigInteger.valueOf(2));
    if (frac.compareTo(HALF) > 0 || frac.compareTo(HALF) == 0 && whole.testBit(0)) whole = whole.add(BigInteger.ONE);
    StringBuilder sb = new StringBuilder(whole.toString());
    while (sb.length() < places + 1) sb.insert(0, '0');
    sb.insert(sb.length() - places, '.');
    return sb.toString();
}
AFTER ANALYZE
null
null
null
Visiting class
p271
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p271().run());
}
METHOD_INFO:

public String run() {
    for (int fact : FACTORS) {
        Set<Integer> sols = new HashSet<>();
        for (int j = 1; j < fact; j++) {
            if (Library.powMod(j, 3, fact) == 1) sols.add(j);
        }
        factorSolutions.add(sols);
    }
    BigInteger sum = buildAndSumSolutions(0, BigInteger.ZERO, BigInteger.ONE);
    return sum.subtract(BigInteger.ONE).toString();
}
METHOD_INFO:

private BigInteger buildAndSumSolutions(int factorIndex, BigInteger x, BigInteger m) {
    if (factorIndex == FACTORS.length) return x; else {
        BigInteger result = BigInteger.ZERO;
        BigInteger fact = BigInteger.valueOf(FACTORS[factorIndex]);
        for (int sol : factorSolutions.get(factorIndex)) {
            BigInteger newx = chineseRemainderTheorem(x, m, BigInteger.valueOf(sol), fact);
            BigInteger temp = buildAndSumSolutions(factorIndex + 1, newx, m.multiply(fact));
            result = result.add(temp);
        }
        return result;
    }
}
METHOD_INFO:

private static BigInteger chineseRemainderTheorem(BigInteger a, BigInteger p, BigInteger b, BigInteger q) {
    return a.add(b.subtract(a).multiply(p.modInverse(q)).multiply(p)).mod(p.multiply(q));
}
AFTER ANALYZE
null
null
null
Visiting class
p280
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p280().run());
}
METHOD_INFO:

public String run() {
    int[][] successors = new int[State.ID_LIMIT][];
    for (State st : State.listAllStates()) {
        Set<State> suc = st.getSuccessors();
        int[] sucIds = new int[suc.size()];
        Iterator<State> it = suc.iterator();
        for (int i = 0; i < sucIds.length; i++) sucIds[i] = it.next().id;
        successors[st.id] = sucIds;
    }
    double sum = 0;
    double[] probs = new double[State.ID_LIMIT];
    probs[State.START_STATE.id] = 1;
    for (int i = 1; ; i++) {
        double[] nextProbs = new double[probs.length];
        for (int j = 0; j < probs.length; j++) {
            if (probs[j] > 0) {
                int[] suc = successors[j];
                for (int k : suc) nextProbs[k] += probs[j] / suc.length;
            }
        }
        double doneNow = nextProbs[State.DONE_STATE.id];
        if (i > 44 && doneNow < 1.0E-20) break;
        sum += doneNow * i;
        probs = nextProbs;
    }
    return String.format("%.6f", sum);
}
Visiting class
State
METHOD_INFO:

public static Set<State> listAllStates() {
    HashSet<State> result = new HashSet<>();
    for (int i = 0; i < (1 << 11); i++) {
        if (Integer.bitCount(i) != 5) continue;
        for (int y = 0; y < 5; y++) {
            for (int x = 0; x < 5; x++) {
                boolean[] seed = new boolean[11];
                for (int j = 0; j < seed.length; j++) seed[j] = ((i >>> j) & 1) != 0;
                result.add(new State(false, x, y, seed));
            }
        }
    }
    result.add(DONE_STATE);
    return result;
}
METHOD_INFO:

public <init>(boolean done, int x, int y, boolean[] seed) {
    super();
    isDone = done;
    antX = x;
    antY = y;
    hasSeed = seed;
    if (done) id = 5 * 5 * (1 << seed.length); else {
        int temp = 0;
        for (int i = 0; i < seed.length; i++) temp |= (seed[i] ? 1 : 0) << i;
        id = x + y * 5 + temp * 25;
    }
}
METHOD_INFO:

public Set<State> getSuccessors() {
    HashSet<State> result = new HashSet<>();
    if (!isDone) {
        tryAddSuccessor(-1, 0, result);
        tryAddSuccessor(+1, 0, result);
        tryAddSuccessor(0, -1, result);
        tryAddSuccessor(0, +1, result);
    }
    return result;
}
METHOD_INFO:

private void tryAddSuccessor(int dx, int dy, Set<State> result) {
    int x = antX + dx;
    int y = antY + dy;
    if (x < 0 || x >= 5 || y < 0 || y >= 5) return;
    boolean[] seed = hasSeed.clone();
    boolean done = false;
    if (!seed[10] && y == 4 && seed[5 + x]) {
        seed[5 + x] = false;
        seed[10] = true;
    } else if (seed[10] && y == 0 && !seed[x]) {
        seed[10] = false;
        seed[x] = true;
        done = seed[0] & seed[1] & seed[2] & seed[3] & seed[4];
    }
    result.add(new State(done, x, y, seed));
}
AFTER ANALYZE
null
null
null
Visiting class
p301
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p301().run());
}
METHOD_INFO:

public String run() {
    int a = 0;
    int b = 1;
    for (int i = 0; i < 32; i++) {
        int c = a + b;
        a = b;
        b = c;
    }
    return Integer.toString(a);
}
AFTER ANALYZE
null
null
null
Visiting class
p303
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p303().run());
}
METHOD_INFO:

public String run() {
    BigInteger sum = BigInteger.ZERO;
    for (int n = 1; n <= 10000; n++) sum = sum.add(findMinimumMultiple(n).divide(BigInteger.valueOf(n)));
    return sum.toString();
}
ADDING ASSERT:
assert i == feasible.size() - 1;
i == feasible.size() - 1
1548675201
Node[6272844]
METHOD_INFO:

private static BigInteger findMinimumMultiple(int n) {
    List<byte[]> feasible = new ArrayList<>();
    feasible.add(new byte[n]);
    feasible.get(0)[0] = 1;
    for (int i = 0; feasible.get(i)[0] != 2; i++) {
        assert i == feasible.size() - 1;
        byte[] prev = feasible.get(i);
        byte[] cur = new byte[n];
        int digitMod = Library.powMod(10, i, n);
        for (int j = 0; j < n; j++) {
            if (prev[j] > 0) {
                cur[(j + digitMod * 0) % n] = prev[j];
                cur[(j + digitMod * 1) % n] = 2;
                cur[(j + digitMod * 2) % n] = 2;
            }
        }
        feasible.add(cur);
    }
    BigInteger result = BigInteger.ZERO;
    int remainder = 0;
    outer: for (int i = feasible.size() - 2; i >= 0; i--) {
        int digitMod = Library.powMod(10, i, n);
        for (int j = (i == feasible.size() - 2 ? 1 : 0); j <= 2; j++) {
            int newRem = (remainder - digitMod * j % n + n) % n;
            if (feasible.get(i)[newRem] > 0) {
                result = result.multiply(BigInteger.valueOf(10)).add(BigInteger.valueOf(j));
                remainder = newRem;
                continue outer;
            }
        }
        throw new AssertionError();
    }
    return result;
}
AFTER ANALYZE
null
null
null
Visiting class
p304
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p304().run());
}
METHOD_INFO:

public String run() {
    int[] primes = Library.listPrimes((int)Library.sqrt(BASE + SEARCH_RANGE));
    isComposite = new boolean[SEARCH_RANGE];
    for (int p : primes) {
        for (int i = (int)((BASE + p - 1) / p * p - BASE); i < isComposite.length; i += p) isComposite[i] = true;
    }
    long sum = 0;
    int p = 0;
    for (int i = 0; i < 100000; i++) {
        p = nextPrime(p);
        sum = (sum + fibonacciMod(BASE + p)) % MODULUS;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private int nextPrime(int n) {
    do {
        n++;
        if (n >= isComposite.length) throw new AssertionError("Search range exhausted");
    }     while (isComposite[n]);
    return n;
}
METHOD_INFO:

private static long fibonacciMod(long n) {
    BigInteger a = BigInteger.ZERO;
    BigInteger b = BigInteger.ONE;
    for (int i = 63; i >= 0; i--) {
        BigInteger d = a.multiply(b.shiftLeft(1).subtract(a));
        BigInteger e = a.pow(2).add(b.pow(2));
        a = d;
        b = e;
        if (((n >>> i) & 1) != 0) {
            BigInteger c = a.add(b);
            a = b;
            b = c;
        }
        a = a.mod(MODULUS_BI);
        b = b.mod(MODULUS_BI);
    }
    return a.longValue();
}
AFTER ANALYZE
null
null
null
Visiting class
p315
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p315().run());
}
METHOD_INFO:

public String run() {
    boolean[] isPrime = Library.listPrimality(20000000);
    int sum = 0;
    for (int i = 10000000; i < isPrime.length; i++) {
        if (isPrime[i]) sum += samTransitionsMinusMaxTransitions(i);
    }
    return Integer.toString(sum);
}
METHOD_INFO:

private static int samTransitionsMinusMaxTransitions(int n) {
    int samTrans = 0;
    int maxTrans = 0;
    long segmentState = 0;
    while (true) {
        long newState = numberToSegments(n);
        if (newState == segmentState) break;
        maxTrans += Long.bitCount(newState ^ segmentState);
        segmentState = newState;
        samTrans += 2 * Long.bitCount(newState);
        n = digitSum(n);
    }
    maxTrans += Long.bitCount(segmentState);
    return samTrans - maxTrans;
}
METHOD_INFO:

private static long numberToSegments(int n) {
    if (n < 0 || n > 999999999) throw new IllegalArgumentException();
    long result = 0;
    int i = 0;
    do {
        result |= (long)DECIMAL_DIGIT_TO_SEGMENT[n % 10] << (i * 7);
        n /= 10;
        i++;
    }     while (n != 0);
    return result;
}
METHOD_INFO:

private static int digitSum(int n) {
    if (n < 0) throw new IllegalArgumentException();
    int result = 0;
    while (n != 0) {
        result += n % 10;
        n /= 10;
    }
    return result;
}
AFTER ANALYZE
null
null
null
Visiting class
p323
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p323().run());
}
ADDING ASSERT:
assert SIZE >= 0;
SIZE >= 0
1588914365
Node[6273624]
ADDING ASSERT:
assert DECIMALS >= 0;
DECIMALS >= 0
1026801430
Node[6273628]
ADDING ASSERT:
assert ans.compareTo(Fraction.ZERO) >= 0;
ans.compareTo(Fraction.ZERO) >= 0
634824041
Node[6273758]
ADDING ASSERT:
assert frac.compareTo(Fraction.ZERO) >= 0;
frac.compareTo(Fraction.ZERO) >= 0
1054502068
Node[6273808]
ADDING ASSERT:
assert frac.compareTo(new Fraction(BigInteger.ONE)) < 0;
frac.compareTo(new Fraction(BigInteger.ONE)) < 0
1331383899
Node[6273816]
METHOD_INFO:

@SuppressWarnings(value = "unused")
public String run() {
    Fraction[] expect = new Fraction[SIZE + 1];
    expect[0] = Fraction.ZERO;
    for (int n = 1; n < expect.length; n++) {
        Fraction sum = Fraction.ZERO;
        for (int k = 0; k < n; k++) {
            BigInteger binom = Library.binomial(n, k);
            Fraction term = new Fraction(expect[k].numerator.multiply(binom), expect[k].denominator);
            sum = sum.add(term);
        }
        BigInteger twoPowN = BigInteger.ONE.shiftLeft(n);
        Fraction temp = sum.add(new Fraction(twoPowN));
        expect[n] = new Fraction(temp.numerator, temp.denominator.multiply(twoPowN.subtract(BigInteger.ONE)));
    }
    Fraction ans = expect[SIZE];
    assert ans.compareTo(Fraction.ZERO) >= 0;
    Fraction scaled = new Fraction(ans.numerator.multiply(BigInteger.TEN.pow(DECIMALS)), ans.denominator);
    BigInteger[] quotRem = scaled.numerator.divideAndRemainder(scaled.denominator);
    BigInteger whole = quotRem[0];
    Fraction frac = new Fraction(quotRem[1], scaled.denominator);
    assert frac.compareTo(Fraction.ZERO) >= 0;
    assert frac.compareTo(new Fraction(BigInteger.ONE)) < 0;
    Fraction HALF = new Fraction(BigInteger.ONE, BigInteger.valueOf(2));
    if (frac.compareTo(HALF) > 0 || frac.equals(HALF) && whole.testBit(0)) whole = whole.add(BigInteger.ONE);
    String temp = whole.toString();
    if (DECIMALS == 0) return whole.toString();
    while (temp.length() < DECIMALS + 1) temp = "0" + temp;
    int index = temp.length() - DECIMALS;
    return String.format("%s.%s", temp.substring(0, index), temp.substring(index));
}
AFTER ANALYZE
null
null
null
Visiting class
p329
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p329().run());
}
ADDING ASSERT:
assert 0 <= START_NUM && START_NUM < END_NUM && END_NUM < Integer.MAX_VALUE;
0 <= START_NUM && START_NUM < END_NUM && END_NUM < Integer.MAX_VALUE
1013293880
Node[6273953]
ADDING ASSERT:
assert 1 <= CROAK_SEQ.length() && CROAK_SEQ.length() <= 31;
1 <= CROAK_SEQ.length() && CROAK_SEQ.length() <= 31
1908519253
Node[6273966]
METHOD_INFO:

public String run() {
    long globalNumerator = 0;
    boolean[] isPrime = Library.listPrimality(END_NUM);
    for (int i = START_NUM; i <= END_NUM; i++) {
        for (int j = 0; j < NUM_TRIALS; j++) {
            int pos = i;
            int trialNumerator = 1;
            if (isPrime[pos] == (CROAK_SEQ.charAt(0) == 'P')) trialNumerator *= 2;
            for (int k = 0; k < NUM_JUMPS; k++) {
                if (pos <= START_NUM) pos++; else if (pos >= END_NUM) pos--; else if (((j >>> k) & 1) == 0) pos++; else pos--;
                if (isPrime[pos] == (CROAK_SEQ.charAt(k + 1) == 'P')) trialNumerator *= 2;
            }
            globalNumerator += trialNumerator;
        }
    }
    BigInteger globalDenominator = BigInteger.valueOf(END_NUM + 1L - START_NUM).shiftLeft(NUM_JUMPS).multiply(BigInteger.valueOf(3).pow(CROAK_SEQ.length()));
    return new Fraction(BigInteger.valueOf(globalNumerator), globalDenominator).toString();
}
AFTER ANALYZE
null
null
null
Visiting class
p345
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p345().run());
}
METHOD_INFO:

public String run() {
    if (COLUMNS > 30) throw new AssertionError();
    maxSum = new int[ROWS][1 << COLUMNS];
    return Integer.toString(findMaximumSum(0, (1 << COLUMNS) - 1));
}
METHOD_INFO:

private int findMaximumSum(int startRow, int setOfCols) {
    if (startRow == ROWS) {
        if (Integer.bitCount(setOfCols) != COLUMNS - ROWS) throw new AssertionError();
        return 0;
    }
    if (maxSum[startRow][setOfCols] == 0) {
        int max = 0;
        for (int col = 0; (1 << col) <= setOfCols; col++) {
            if ((setOfCols & (1 << col)) != 0) max = Math.max(MATRIX[startRow][col] + findMaximumSum(startRow + 1, setOfCols ^ (1 << col)), max);
        }
        maxSum[startRow][setOfCols] = max;
    }
    return maxSum[startRow][setOfCols];
}
AFTER ANALYZE
null
null
null
Visiting class
p346
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p346().run());
}
METHOD_INFO:

public String run() {
    Set<Long> strongRepunits = new HashSet<>();
    strongRepunits.add(1L);
    for (int length = 3; length <= BigInteger.valueOf(LIMIT).bitLength(); length++) {
        middle: for (int base = 2; ; base++) {
            long value = 0;
            for (int i = 0; i < length; i++) {
                if (Long.MAX_VALUE / base < value) break middle;
                value *= base;
                if (value + 1 < value) break middle;
                value++;
            }
            if (value >= LIMIT) break;
            strongRepunits.add(value);
        }
    }
    long sum = 0;
    for (long x : strongRepunits) {
        if (sum + x < sum) throw new ArithmeticException("Overflow");
        sum += x;
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p347
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p347().run());
}
METHOD_INFO:

public String run() {
    Set<Integer> possible = new HashSet<>();
    int[] primes = Library.listPrimes(LIMIT / 2);
    for (int i = 0, end = Library.sqrt(LIMIT); i < primes.length; i++) {
        int p = primes[i];
        if (p > end) break;
        for (int j = i + 1; j < primes.length; j++) {
            int q = primes[j];
            int lcm = p * q;
            if (lcm > LIMIT) break;
            int multLimit = LIMIT / lcm;
            int multiplier = 1;
            while (multiplier * p <= multLimit) multiplier *= p;
            int maxMult = multiplier;
            while (multiplier % p == 0) {
                multiplier /= p;
                while (multiplier * q <= multLimit) multiplier *= q;
                maxMult = Math.max(multiplier, maxMult);
            }
            possible.add(maxMult * lcm);
        }
    }
    long sum = 0;
    for (int x : possible) sum += x;
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p348
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p348().run());
}
ADDING ASSERT:
assert 0 <= TARGET_COUNT;
0 <= TARGET_COUNT
1232525063
Node[6274968]
ADDING ASSERT:
assert 0 <= TARGET_WAYS && TARGET_WAYS <= Byte.MAX_VALUE - 1;
0 <= TARGET_WAYS && TARGET_WAYS <= Byte.MAX_VALUE - 1
1971356297
Node[6274972]
METHOD_INFO:

public String run() {
    for (long limit = 1; ; limit *= 10) {
        if (limit > Integer.MAX_VALUE) throw new AssertionError("Overflow");
        long answer = trySearch((int)limit);
        if (answer != -1) return Long.toString(answer);
    }
}
METHOD_INFO:

private static long trySearch(int limit) {
    byte[] ways = new byte[limit];
    for (int i = cbrt(limit - 1); i > 1; i--) {
        int cube = i * i * i;
        for (int j = Library.sqrt(limit - 1 - cube); j > 1; j--) {
            int index = cube + j * j;
            ways[index] = (byte)Math.min(ways[index] + 1, TARGET_WAYS + 1);
        }
    }
    long result = 0;
    int count = 0;
    for (int i = 0; i < ways.length; i++) {
        if (ways[i] == TARGET_WAYS && Library.isPalindrome(i)) {
            result += i;
            count++;
            if (count == TARGET_COUNT) return result;
        }
    }
    return -1;
}
METHOD_INFO:

private static int cbrt(int x) {
    if (x < 0) throw new IllegalArgumentException("Not implemented");
    int y = 0;
    for (int i = 1 << 10; i != 0; i >>>= 1) {
        y |= i;
        if (y > 1290 || y * y * y > x) y ^= i;
    }
    return y;
}
AFTER ANALYZE
null
null
null
Visiting class
p357
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p357().run());
}
METHOD_INFO:

public String run() {
    isPrime = Library.listPrimality(LIMIT + 1);
    long sum = 0;
    for (int n = 0; n <= LIMIT; n++) {
        if (isPrime[n + 1] && isPrimeGenerating(n)) sum += n;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private boolean isPrimeGenerating(int n) {
    for (int i = 1, end = Library.sqrt(n); i <= end; i++) {
        if (n % i == 0 && !isPrime[i + n / i]) return false;
    }
    return true;
}
AFTER ANALYZE
null
null
null
Visiting class
p381
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p381().run());
}
METHOD_INFO:

public String run() {
    boolean[] isPrime = Library.listPrimality(Library.pow(10, 8));
    long sum = 0;
    for (int i = 5; i < isPrime.length; i++) {
        if (isPrime[i]) sum += s(i);
    }
    return Long.toString(sum);
}
METHOD_INFO:

private static int s(int p) {
    return (int)((long)(p - 3) * Library.reciprocalMod(8 % p, p) % p);
}
AFTER ANALYZE
null
null
null
Visiting class
p387
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p387().run());
}
METHOD_INFO:

public String run() {
    for (int i = 1; i <= 9; i++) findHarshadPrimes(i, i, false);
    return sum.toString();
}
METHOD_INFO:

private void findHarshadPrimes(long n, int digitSum, boolean isStrong) {
    long m = n * 10;
    int s = digitSum;
    for (int i = 0; i < 10 && m < LIMIT; i++, m++, s++) {
        if (isStrong && isPrime(m)) sum = sum.add(BigInteger.valueOf(m));
        if (m % s == 0) findHarshadPrimes(m, s, isPrime(m / s));
    }
}
METHOD_INFO:

private static boolean isPrime(long x) {
    if (x < 0) throw new IllegalArgumentException("Negative number");
    if (x == 0 || x == 1) return false;
    for (long i = 2, end = Library.sqrt(x); i <= end; i++) {
        if (x % i == 0) return false;
    }
    return true;
}
AFTER ANALYZE
null
null
null
Visiting class
p401
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p401().run());
}
METHOD_INFO:

public String run() {
    int splitCount = (int)Library.sqrt(LIMIT);
    splitCount = Math.max(splitCount / 3, 1);
    int splitAt = (int)(LIMIT / (splitCount + 1));
    long sum = 0;
    for (int i = 1; i <= splitAt; i++) {
        long count = LIMIT / i % MODULUS;
        long term = (long)i * i % MODULUS;
        term = term * count % MODULUS;
        sum = (sum + term) % MODULUS;
    }
    for (int i = splitCount; i >= 1; i--) {
        long start = LIMIT / (i + 1);
        long end = LIMIT / i;
        long sumSquares = sumSquaresMod(end) - sumSquaresMod(start);
        sumSquares = (sumSquares + MODULUS) % MODULUS;
        sum = (sum + i * sumSquares % MODULUS) % MODULUS;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private static long sumSquaresMod(long n) {
    BigInteger x = BigInteger.valueOf(n);
    BigInteger y = x.multiply(x.add(BigInteger.ONE));
    y = y.multiply(x.shiftLeft(1).add(BigInteger.ONE));
    y = y.divide(SIX_BI);
    y = y.mod(MODULUS_BI);
    return y.longValue();
}
AFTER ANALYZE
null
null
null
Visiting class
p407
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p407().run());
}
METHOD_INFO:

public String run() {
    int[] smallestPrimeFactor = Library.listSmallestPrimeFactors(LIMIT);
    int maxNumPrimeFactors = 0;
    for (int i = 2, prod = 1; i < smallestPrimeFactor.length; i++) {
        if (smallestPrimeFactor[i] == i) {
            if (LIMIT / prod < i) break;
            prod *= i;
            maxNumPrimeFactors++;
        }
    }
    long sum = 0;
    int[] solns = new int[1 << maxNumPrimeFactors];
    int[] newsolns = new int[1 << maxNumPrimeFactors];
    for (int i = 1; i <= LIMIT; i++) {
        List<Integer> factorization = new ArrayList<>();
        for (int j = i; j != 1; ) {
            int p = smallestPrimeFactor[j];
            int q = 1;
            do {
                j /= p;
                q *= p;
            }             while (j % p == 0);
            factorization.add(q);
        }
        solns[0] = 0;
        int solnslen = 1;
        int modulus = 1;
        for (int q : factorization) {
            int recip = Library.reciprocalMod(q % modulus, modulus);
            int newmod = q * modulus;
            int newsolnslen = 0;
            for (int j = 0; j < solnslen; j++) {
                newsolns[newsolnslen++] = ((0 + (int)((long)(solns[j] - 0 + modulus) * recip % modulus) * q) % newmod);
                newsolns[newsolnslen++] = ((1 + (int)((long)(solns[j] - 1 + modulus) * recip % modulus) * q) % newmod);
            }
            solnslen = newsolnslen;
            modulus = newmod;
            int[] temp = solns;
            solns = newsolns;
            newsolns = temp;
        }
        int max = 0;
        for (int j = 0; j < solnslen; j++) max = Math.max(solns[j], max);
        sum += max;
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p417
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p417().run());
}
METHOD_INFO:

public String run() {
    int[] primes = Library.listPrimes(LIMIT);
    int[] smallestPrimeFactor = Library.listSmallestPrimeFactors(LIMIT);
    long[] primePowersAndTotients = calcPrimePowersAndTotients(primes);
    int[] primePowerPeriods = calcPrimePowerPeriods(primePowersAndTotients, smallestPrimeFactor);
    smallestPrimeFactor = null;
    int[] periods = calcPeriods(primePowersAndTotients, primePowerPeriods);
    return Long.toString(sumAllPeriods(periods));
}
METHOD_INFO:

private static long[] calcPrimePowersAndTotients(int[] primes) {
    LongList temp = new LongList(primes.length * 2);
    for (int p : primes) {
        if (p == 2 || p == 5) continue;
        for (long pow = p, tot = p - 1; pow <= LIMIT; pow *= p, tot *= p) temp.append(pow << 32 | tot);
    }
    long[] result = temp.toArray();
    Arrays.sort(result);
    return result;
}
METHOD_INFO:

private static int[] calcPrimePowerPeriods(long[] primePowersAndTotients, int[] smallestPrimeFactor) {
    int[] result = new int[primePowersAndTotients.length];
    for (int i = 0; i < primePowersAndTotients.length; i++) {
        long ppt = primePowersAndTotients[i];
        int primePow = (int)(ppt >>> 32);
        int period = (int)ppt;
        int remainingFactors = period;
        while (remainingFactors > 1) {
            int q = smallestPrimeFactor[remainingFactors];
            if (Library.powMod(10, period / q, primePow) == 1) period /= q;
            remainingFactors /= q;
        }
        result[i] = period;
    }
    return result;
}
METHOD_INFO:

private static int[] calcPeriods(long[] primePowersAndTotients, int[] primePowerPeriods) {
    int[] result = new int[LIMIT + 1];
    result[1] = 1;
    for (int i = 0; i < primePowersAndTotients.length; i++) {
        int ppow = (int)(primePowersAndTotients[i] >>> 32);
        int period = primePowerPeriods[i];
        for (int j = 0, end = LIMIT / ppow; j <= end; j++) {
            if (result[j] != 0) result[j * ppow] = lcm(result[j], period);
        }
    }
    result[1] = 0;
    return result;
}
METHOD_INFO:

private static long sumAllPeriods(int[] periods) throws AssertionError {
    long sum = 0;
    for (int i = 3; i <= LIMIT; i++) {
        int n = i;
        n >>>= Integer.numberOfTrailingZeros(n);
        while (n % 5 == 0) n /= 5;
        if (n > 1 && periods[n] == 0) throw new AssertionError();
        sum += periods[n];
    }
    return sum;
}
METHOD_INFO:

private static int lcm(int x, int y) {
    return x / Library.gcd(x, y) * y;
}
Visiting class
LongList
METHOD_INFO:

public <init>(int initCapacity) {
    super();
    if (initCapacity < 1) throw new IllegalArgumentException();
    data = new long[initCapacity];
    length = 0;
}
METHOD_INFO:

public void append(long x) {
    if (length == data.length) data = Arrays.copyOf(data, length * 2);
    data[length] = x;
    length++;
}
METHOD_INFO:

public long[] toArray() {
    return Arrays.copyOf(data, length);
}
AFTER ANALYZE
null
null
null
Visiting class
p425
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p425().run());
}
METHOD_INFO:

public String run() {
    boolean[] isPrime = Library.listPrimality(LIMIT);
    int[] pathMax = new int[isPrime.length];
    Arrays.fill(pathMax, Integer.MAX_VALUE);
    Queue<IntPair> queue = new PriorityQueue<>();
    queue.add(new IntPair(2, 2));
    while (!queue.isEmpty()) {
        IntPair item = queue.remove();
        int n = item.b;
        int pmax = item.a;
        if (pmax >= pathMax[n]) {
            continue;
        }
        pathMax[n] = pmax;
        int[] digits = toDigits(n);
        int[] tempDigits = digits.clone();
        for (int i = 0; i < tempDigits.length; i++) {
            for (int j = 0; j < 10; j++) {
                tempDigits[i] = j;
                int m = toNumber(tempDigits);
                int nextPmax = Math.max(m, pmax);
                if (m < isPrime.length && isPrime[m] && nextPmax < pathMax[m]) queue.add(new IntPair(nextPmax, m));
            }
            tempDigits[i] = digits[i];
        }
    }
    long sum = 0;
    for (int i = 0; i < isPrime.length; i++) {
        if (isPrime[i] && pathMax[i] > i) sum += i;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private static int[] toDigits(int n) {
    if (n < 0) throw new IllegalArgumentException();
    int[] temp = new int[11];
    int len = 0;
    do {
        temp[len] = n % 10;
        n /= 10;
        len++;
    }     while (n > 0);
    int[] result = new int[len + 1];
    for (int i = 0; i < result.length; i++) result[i] = temp[len - i];
    return result;
}
METHOD_INFO:

private static int toNumber(int[] digits) {
    int result = 0;
    for (int x : digits) result = result * 10 + x;
    return result;
}
Visiting class
IntPair
METHOD_INFO:

public <init>(int a, int b) {
    super();
    this.a = a;
    this.b = b;
}
METHOD_INFO:

public int compareTo(IntPair other) {
    return Integer.compare(a, other.a);
}
AFTER ANALYZE
null
null
null
Visiting class
p429
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p429().run());
}
METHOD_INFO:

public String run() {
    int[] primes = Library.listPrimes(LIMIT);
    long sum = 1;
    for (int p : primes) {
        int power = countFactors(LIMIT, p);
        sum *= 1 + Library.powMod(p, power * 2, MODULUS);
        sum %= MODULUS;
    }
    return Long.toString(sum);
}
METHOD_INFO:

private static int countFactors(int n, int p) {
    if (n == 0) return 0; else return n / p + countFactors(n / p, p);
}
AFTER ANALYZE
null
null
null
Visiting class
p431
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p431().run());
}
METHOD_INFO:

public String run() {
    double sum = 0;
    for (int i = 20; i <= 25; i++) sum += findRootSecant(0, RADIUS, i * i);
    return String.format("%.9f", sum);
}
METHOD_INFO:

private static double findRootSecant(double x0, double x1, double val) {
    int samples = 10000;
    double y0 = volume(x0, samples);
    double y1 = volume(x1, samples);
    while (Math.abs(x0 - x1) > 1.0E-12) {
        double x2 = (val - y0) / (y1 - y0) * (x1 - x0) + x0;
        double y2 = volume(x2, samples);
        x0 = x1;
        x1 = x2;
        y0 = y1;
        y1 = y2;
        if (Math.abs(x0 - x1) < 1.0E-4) samples = Math.max(1000000, samples);
        if (Math.abs(x0 - x1) < 1.0E-6) samples = Math.max(10000000, samples);
        if (Math.abs(x0 - x1) < 1.0E-8) samples = Math.max(100000000, samples);
    }
    return x1;
}
METHOD_INFO:

private static double volume(double x, int samples) {
    double discVolume = Math.pow(RADIUS + x, 3) / 3 * Math.PI * 2;
    if (x > 0) {
        double scaler = x * 2 / samples;
        double r2plusx2 = RADIUS * RADIUS + x * x;
        double rec2x = 1 / (x * 2);
        double sum = 0;
        for (int i = 0; i < samples; i++) {
            double r = RADIUS - x + (i + 0.5) * scaler;
            double r2 = r * r;
            sum += Math.acos(((r2plusx2 - r2) * rec2x - x) / r) * r2;
        }
        discVolume -= sum * 4 * x / samples;
    }
    return discVolume * Math.tan(REPOSE);
}
AFTER ANALYZE
null
null
null
Visiting class
p433
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p433().run());
}
METHOD_INFO:

public String run() {
    for (int i = 1; i <= LIMIT; i++) exploreGcds(i, 0, 0);
    return Long.toString(sum * 2 + (long)LIMIT * (LIMIT + 1) / 2);
}
METHOD_INFO:

private void exploreGcds(int x, int y, int steps) {
    if (!(0 <= y && y < x && x <= LIMIT)) throw new IllegalArgumentException();
    sum += steps;
    for (int z = y + (y > 0 ? 1 : 2) * x; z <= LIMIT; z += x) exploreGcds(z, x, steps + 1);
}
AFTER ANALYZE
null
null
null
Visiting class
p451
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p451().run());
}
METHOD_INFO:

public String run() {
    smallestPrimeFactor = Library.listSmallestPrimeFactors(LIMIT);
    solutions = new IntArrayArray(LIMIT / 2 + 1);
    solutions.append();
    solutions.append();
    solutions.append(1);
    long sum = 0;
    for (int i = 3; i <= LIMIT; i++) {
        int[] sols = getSolutions(i);
        if (i <= LIMIT / 2) solutions.append(sols);
        sum += sols[sols.length - 2];
    }
    return Long.toString(sum);
}
METHOD_INFO:

private int[] getSolutions(int n) {
    if (smallestPrimeFactor[n] == n) return new int[]{1, n - 1}; else {
        List<Integer> temp = new ArrayList<>();
        int p = smallestPrimeFactor[n];
        int[] sols = solutions.get(n / p);
        for (int i = 0, inc = n / p; i < n; i += inc) {
            for (int j : sols) {
                int k = i + j;
                if ((long)k * k % n == 1) temp.add(k);
            }
        }
        int[] result = new int[temp.size()];
        for (int i = 0; i < result.length; i++) result[i] = temp.get(i);
        return result;
    }
}
Visiting class
IntArrayArray
METHOD_INFO:

public <init>(int len) {
    super();
    data = new int[1];
    dataLength = 0;
    starts = new int[len + 1];
    Arrays.fill(starts, -1);
    starts[0] = 0;
    index = 0;
}
METHOD_INFO:

public int[] get(int i) {
    return Arrays.copyOfRange(data, starts[i], starts[i + 1]);
}
METHOD_INFO:

public void append(int... arr) {
    while (dataLength + arr.length > data.length) data = Arrays.copyOf(data, data.length * 2);
    System.arraycopy(arr, 0, data, dataLength, arr.length);
    dataLength += arr.length;
    index++;
    starts[index] = dataLength;
}
AFTER ANALYZE
null
null
null
Visiting class
p493
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p493().run());
}
METHOD_INFO:

public String run() {
    explore(NUM_PICKED, BALLS_PER_COLOR, new Stack<Integer>());
    BigInteger denominator = Library.binomial(NUM_COLORS * BALLS_PER_COLOR, NUM_PICKED);
    BigDecimal num = new BigDecimal(numerator);
    BigDecimal den = new BigDecimal(denominator);
    return num.divide(den, 9, RoundingMode.HALF_EVEN).toString();
}
METHOD_INFO:

private void explore(int remain, int limit, Stack<Integer> history) {
    if (remain == 0) {
        int[] hist = new int[NUM_COLORS];
        for (int i = 0; i < history.size(); i++) hist[i] = history.get(i);
        int[] histogram = new int[BALLS_PER_COLOR + 1];
        for (int x : hist) histogram[x]++;
        BigInteger count = Library.factorial(NUM_COLORS);
        for (int x : histogram) count = divideExactly(count, Library.factorial(x));
        for (int x : hist) count = count.multiply(Library.binomial(BALLS_PER_COLOR, x));
        int distinctColors = history.size();
        numerator = numerator.add(count.multiply(BigInteger.valueOf(distinctColors)));
    } else if (history.size() < NUM_COLORS) {
        for (int i = Math.min(limit, remain); i > 0; i--) {
            history.push(i);
            explore(remain - i, i, history);
            history.pop();
        }
    }
}
METHOD_INFO:

private static BigInteger divideExactly(BigInteger x, BigInteger y) {
    BigInteger[] temp = x.divideAndRemainder(y);
    if (temp[1].signum() != 0) throw new IllegalArgumentException("Not divisible");
    return temp[0];
}
AFTER ANALYZE
null
null
null
Visiting class
p500
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p500().run());
}
METHOD_INFO:

public String run() {
    Queue<Long> queue = new PriorityQueue<>();
    int nextPrime = 2;
    queue.add((long)nextPrime);
    long product = 1;
    for (int i = 0; i < TARGET; i++) {
        long item = queue.remove();
        product *= item % MODULUS;
        product %= MODULUS;
        queue.add(item * item);
        if (item == nextPrime) {
            do nextPrime++;             while (!Library.isPrime(nextPrime));
            queue.add((long)nextPrime);
        }
    }
    return Long.toString(product);
}
AFTER ANALYZE
null
null
null
Visiting class
p518
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p518().run());
}
METHOD_INFO:

public String run() {
    long sum = 0;
    boolean[] isPrime = Library.listPrimality(LIMIT - 1);
    for (int x = 1; x < isPrime.length; x++) {
        for (int y = 1; ; y++) {
            long a = (long)x * y * y - 1;
            if (a >= isPrime.length) break;
            if (!isPrime[(int)a]) continue;
            for (int z = y + 1; ; z++) {
                if (Library.gcd(y, z) != 1) continue;
                long b = (long)x * y * z - 1;
                long c = (long)x * z * z - 1;
                if (c >= isPrime.length) break;
                if (isPrime[(int)b] && isPrime[(int)c]) {
                    long addend = a + b + c;
                    if (sum + addend < sum) throw new ArithmeticException("Overflow");
                    sum += addend;
                }
            }
        }
    }
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p549
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p549().run());
}
METHOD_INFO:

public String run() {
    int[] smallestDivisibleFactorials = new int[LIMIT + 1];
    for (int i = 2; i < smallestDivisibleFactorials.length; i++) {
        if (smallestDivisibleFactorials[i] == 0) {
            long power = 1;
            middle: for (int j = i; ; j += i) {
                power *= i;
                if (power > LIMIT) break;
                for (int inc = (int)power, k = inc; k < smallestDivisibleFactorials.length; k += inc) smallestDivisibleFactorials[k] = Math.max(j, smallestDivisibleFactorials[k]);
                for (int temp = j / i; temp % i == 0; temp /= i) {
                    power *= i;
                    if (power > LIMIT) break middle;
                }
            }
        }
    }
    long sum = 0;
    for (int x : smallestDivisibleFactorials) sum += x;
    return Long.toString(sum);
}
AFTER ANALYZE
null
null
null
Visiting class
p587
METHOD_INFO:

public <init>() {
    super();
}
METHOD_INFO:

public static void main(String[] args) {
    System.out.println(new p587().run());
}
METHOD_INFO:

public String run() {
    double lSectionArea = 1 - Math.PI / 4;
    for (int i = 1; ; i++) {
        double slope = 1.0 / i;
        double a = slope * slope + 1;
        double b = -2 * (slope + 1);
        double c = 1;
        double x = (2 * c) / (-b + Math.sqrt(b * b - 4 * a * c));
        double concaveTriangleArea = x * (1 - Math.sqrt((-x + 2) * x)) / 2;
        concaveTriangleArea += integral(1) - integral(x);
        if (concaveTriangleArea / lSectionArea < 0.001) return Integer.toString(i);
        if (i == Integer.MAX_VALUE) throw new AssertionError();
    }
}
METHOD_INFO:

private static double integral(double x) {
    double t = x - 1;
    return t - (Math.sqrt(1 - t * t) * t + Math.asin(t)) / 2;
}
AFTER ANALYZE
null
null
null
BEFORE CFG
null
null
null

public String run();

public <init>() {
    super();
}
STATEMENT:
super();

@Test()
public void testP001() {
    org.junit.Assert.assertEquals("233168", new p001().run());
}

@Test()
public void testP002() {
    org.junit.Assert.assertEquals("4613732", new p002().run());
}

@Test()
public void testP003() {
    org.junit.Assert.assertEquals("6857", new p003().run());
}

@Test()
public void testP004() {
    org.junit.Assert.assertEquals("906609", new p004().run());
}

@Test()
public void testP005() {
    org.junit.Assert.assertEquals("232792560", new p005().run());
}

@Test()
public void testP006() {
    org.junit.Assert.assertEquals("25164150", new p006().run());
}

@Test()
public void testP007() {
    org.junit.Assert.assertEquals("104743", new p007().run());
}

@Test()
public void testP008() {
    org.junit.Assert.assertEquals("23514624000", new p008().run());
}

@Test()
public void testP009() {
    org.junit.Assert.assertEquals("31875000", new p009().run());
}

@Test()
public void testP010() {
    org.junit.Assert.assertEquals("142913828922", new p010().run());
}

@Test()
public void testP011() {
    org.junit.Assert.assertEquals("70600674", new p011().run());
}

@Test()
public void testP012() {
    org.junit.Assert.assertEquals("76576500", new p012().run());
}

@Test()
public void testP013() {
    org.junit.Assert.assertEquals("5537376230", new p013().run());
}

@Test()
public void testP014() {
    org.junit.Assert.assertEquals("837799", new p014().run());
}

@Test()
public void testP015() {
    org.junit.Assert.assertEquals("137846528820", new p015().run());
}

@Test()
public void testP016() {
    org.junit.Assert.assertEquals("1366", new p016().run());
}

@Test()
public void testP017() {
    org.junit.Assert.assertEquals("21124", new p017().run());
}

@Test()
public void testP018() {
    org.junit.Assert.assertEquals("1074", new p018().run());
}

@Test()
public void testP019() {
    org.junit.Assert.assertEquals("171", new p019().run());
}

@Test()
public void testP020() {
    org.junit.Assert.assertEquals("648", new p020().run());
}

@Test()
public void testP021() {
    org.junit.Assert.assertEquals("31626", new p021().run());
}

@Test()
public void testP022() {
    org.junit.Assert.assertEquals("871198282", new p022().run());
}

@Test()
public void testP023() {
    org.junit.Assert.assertEquals("4179871", new p023().run());
}

@Test()
public void testP024() {
    org.junit.Assert.assertEquals("2783915460", new p024().run());
}

@Test()
public void testP025() {
    org.junit.Assert.assertEquals("4782", new p025().run());
}

@Test()
public void testP026() {
    org.junit.Assert.assertEquals("983", new p026().run());
}

@Test()
public void testP027() {
    org.junit.Assert.assertEquals("-59231", new p027().run());
}

@Test()
public void testP028() {
    org.junit.Assert.assertEquals("669171001", new p028().run());
}

@Test()
public void testP029() {
    org.junit.Assert.assertEquals("9183", new p029().run());
}

@Test()
public void testP030() {
    org.junit.Assert.assertEquals("443839", new p030().run());
}

@Test()
public void testP031() {
    org.junit.Assert.assertEquals("73682", new p031().run());
}

@Test()
public void testP032() {
    org.junit.Assert.assertEquals("45228", new p032().run());
}

@Test()
public void testP033() {
    org.junit.Assert.assertEquals("100", new p033().run());
}

@Test()
public void testP034() {
    org.junit.Assert.assertEquals("40730", new p034().run());
}

@Test()
public void testP035() {
    org.junit.Assert.assertEquals("55", new p035().run());
}

@Test()
public void testP036() {
    org.junit.Assert.assertEquals("872187", new p036().run());
}

@Test()
public void testP037() {
    org.junit.Assert.assertEquals("748317", new p037().run());
}

@Test()
public void testP038() {
    org.junit.Assert.assertEquals("932718654", new p038().run());
}

@Test()
public void testP039() {
    org.junit.Assert.assertEquals("840", new p039().run());
}

@Test()
public void testP040() {
    org.junit.Assert.assertEquals("210", new p040().run());
}

@Test()
public void testP041() {
    org.junit.Assert.assertEquals("7652413", new p041().run());
}

@Test()
public void testP042() {
    org.junit.Assert.assertEquals("162", new p042().run());
}

@Test()
public void testP043() {
    org.junit.Assert.assertEquals("16695334890", new p043().run());
}

@Test()
public void testP044() {
    org.junit.Assert.assertEquals("5482660", new p044().run());
}

@Test()
public void testP045() {
    org.junit.Assert.assertEquals("1533776805", new p045().run());
}

@Test()
public void testP046() {
    org.junit.Assert.assertEquals("5777", new p046().run());
}

@Test()
public void testP047() {
    org.junit.Assert.assertEquals("134043", new p047().run());
}

@Test()
public void testP048() {
    org.junit.Assert.assertEquals("9110846700", new p048().run());
}

@Test()
public void testP049() {
    org.junit.Assert.assertEquals("296962999629", new p049().run());
}

@Test()
public void testP050() {
    org.junit.Assert.assertEquals("997651", new p050().run());
}

@Test()
public void testP051() {
    org.junit.Assert.assertEquals("121313", new p051().run());
}

@Test()
public void testP052() {
    org.junit.Assert.assertEquals("142857", new p052().run());
}

@Test()
public void testP053() {
    org.junit.Assert.assertEquals("4075", new p053().run());
}

@Test()
public void testP054() {
    org.junit.Assert.assertEquals("376", new p054().run());
}

@Test()
public void testP055() {
    org.junit.Assert.assertEquals("249", new p055().run());
}

@Test()
public void testP056() {
    org.junit.Assert.assertEquals("972", new p056().run());
}

@Test()
public void testP057() {
    org.junit.Assert.assertEquals("153", new p057().run());
}

@Test()
public void testP058() {
    org.junit.Assert.assertEquals("26241", new p058().run());
}

@Test()
public void testP059() {
    org.junit.Assert.assertEquals("107359", new p059().run());
}

@Test()
public void testP060() {
    org.junit.Assert.assertEquals("26033", new p060().run());
}

@Test()
public void testP061() {
    org.junit.Assert.assertEquals("28684", new p061().run());
}

@Test()
public void testP062() {
    org.junit.Assert.assertEquals("127035954683", new p062().run());
}

@Test()
public void testP063() {
    org.junit.Assert.assertEquals("49", new p063().run());
}

@Test()
public void testP064() {
    org.junit.Assert.assertEquals("1322", new p064().run());
}

@Test()
public void testP065() {
    org.junit.Assert.assertEquals("272", new p065().run());
}

@Test()
public void testP066() {
    org.junit.Assert.assertEquals("661", new p066().run());
}

@Test()
public void testP067() {
    org.junit.Assert.assertEquals("7273", new p067().run());
}

@Test()
public void testP068() {
    org.junit.Assert.assertEquals("6531031914842725", new p068().run());
}

@Test()
public void testP069() {
    org.junit.Assert.assertEquals("510510", new p069().run());
}

@Test()
public void testP070() {
    org.junit.Assert.assertEquals("8319823", new p070().run());
}

@Test()
public void testP071() {
    org.junit.Assert.assertEquals("428570", new p071().run());
}

@Test()
public void testP072() {
    org.junit.Assert.assertEquals("303963552391", new p072().run());
}

@Test()
public void testP073() {
    org.junit.Assert.assertEquals("7295372", new p073().run());
}

@Test()
public void testP074() {
    org.junit.Assert.assertEquals("402", new p074().run());
}

@Test()
public void testP075() {
    org.junit.Assert.assertEquals("161667", new p075().run());
}

@Test()
public void testP076() {
    org.junit.Assert.assertEquals("190569291", new p076().run());
}

@Test()
public void testP077() {
    org.junit.Assert.assertEquals("71", new p077().run());
}

@Test()
public void testP078() {
    org.junit.Assert.assertEquals("55374", new p078().run());
}

@Test()
public void testP079() {
    org.junit.Assert.assertEquals("73162890", new p079().run());
}

@Test()
public void testP080() {
    org.junit.Assert.assertEquals("40886", new p080().run());
}

@Test()
public void testP081() {
    org.junit.Assert.assertEquals("427337", new p081().run());
}

@Test()
public void testP082() {
    org.junit.Assert.assertEquals("260324", new p082().run());
}

@Test()
public void testP083() {
    org.junit.Assert.assertEquals("425185", new p083().run());
}

@Test()
public void testP084() {
    org.junit.Assert.assertEquals("101524", new p084().run());
}

@Test()
public void testP085() {
    org.junit.Assert.assertEquals("2772", new p085().run());
}

@Test()
public void testP086() {
    org.junit.Assert.assertEquals("1818", new p086().run());
}

@Test()
public void testP087() {
    org.junit.Assert.assertEquals("1097343", new p087().run());
}

@Test()
public void testP088() {
    org.junit.Assert.assertEquals("7587457", new p088().run());
}

@Test()
public void testP089() {
    org.junit.Assert.assertEquals("743", new p089().run());
}

@Test()
public void testP090() {
    org.junit.Assert.assertEquals("1217", new p090().run());
}

@Test()
public void testP091() {
    org.junit.Assert.assertEquals("14234", new p091().run());
}

@Test()
public void testP092() {
    org.junit.Assert.assertEquals("8581146", new p092().run());
}

@Test()
public void testP093() {
    org.junit.Assert.assertEquals("1258", new p093().run());
}

@Test()
public void testP094() {
    org.junit.Assert.assertEquals("518408346", new p094().run());
}

@Test()
public void testP095() {
    org.junit.Assert.assertEquals("14316", new p095().run());
}

@Test()
public void testP096() {
    org.junit.Assert.assertEquals("24702", new p096().run());
}

@Test()
public void testP097() {
    org.junit.Assert.assertEquals("8739992577", new p097().run());
}

@Test()
public void testP098() {
    org.junit.Assert.assertEquals("18769", new p098().run());
}

@Test()
public void testP099() {
    org.junit.Assert.assertEquals("709", new p099().run());
}

@Test()
public void testP100() {
    org.junit.Assert.assertEquals("756872327473", new p100().run());
}

@Test()
public void testP101() {
    org.junit.Assert.assertEquals("37076114526", new p101().run());
}

@Test()
public void testP102() {
    org.junit.Assert.assertEquals("228", new p102().run());
}

@Test()
public void testP104() {
    org.junit.Assert.assertEquals("329468", new p104().run());
}

@Test()
public void testP105() {
    org.junit.Assert.assertEquals("73702", new p105().run());
}

@Test()
public void testP107() {
    org.junit.Assert.assertEquals("259679", new p107().run());
}

@Test()
public void testP108() {
    org.junit.Assert.assertEquals("180180", new p108().run());
}

@Test()
public void testP109() {
    org.junit.Assert.assertEquals("38182", new p109().run());
}

@Test()
public void testP111() {
    org.junit.Assert.assertEquals("612407567715", new p111().run());
}

@Test()
public void testP112() {
    org.junit.Assert.assertEquals("1587000", new p112().run());
}

@Test()
public void testP113() {
    org.junit.Assert.assertEquals("51161058134250", new p113().run());
}

@Test()
public void testP114() {
    org.junit.Assert.assertEquals("16475640049", new p114().run());
}

@Test()
public void testP115() {
    org.junit.Assert.assertEquals("168", new p115().run());
}

@Test()
public void testP116() {
    org.junit.Assert.assertEquals("20492570929", new p116().run());
}

@Test()
public void testP117() {
    org.junit.Assert.assertEquals("100808458960497", new p117().run());
}

@Test()
public void testP118() {
    org.junit.Assert.assertEquals("44680", new p118().run());
}

@Test()
public void testP119() {
    org.junit.Assert.assertEquals("248155780267521", new p119().run());
}

@Test()
public void testP120() {
    org.junit.Assert.assertEquals("333082500", new p120().run());
}

@Test()
public void testP121() {
    org.junit.Assert.assertEquals("2269", new p121().run());
}

@Test()
public void testP122() {
    org.junit.Assert.assertEquals("1582", new p122().run());
}

@Test()
public void testP123() {
    org.junit.Assert.assertEquals("21035", new p123().run());
}

@Test()
public void testP124() {
    org.junit.Assert.assertEquals("21417", new p124().run());
}

@Test()
public void testP125() {
    org.junit.Assert.assertEquals("2906969179", new p125().run());
}

@Test()
public void testP127() {
    org.junit.Assert.assertEquals("18407904", new p127().run());
}

@Test()
public void testP128() {
    org.junit.Assert.assertEquals("14516824220", new p128().run());
}

@Test()
public void testP129() {
    org.junit.Assert.assertEquals("1000023", new p129().run());
}

@Test()
public void testP130() {
    org.junit.Assert.assertEquals("149253", new p130().run());
}

@Test()
public void testP132() {
    org.junit.Assert.assertEquals("843296", new p132().run());
}

@Test()
public void testP133() {
    org.junit.Assert.assertEquals("453647705", new p133().run());
}

@Test()
public void testP134() {
    org.junit.Assert.assertEquals("18613426663617118", new p134().run());
}

@Test()
public void testP135() {
    org.junit.Assert.assertEquals("4989", new p135().run());
}

@Test()
public void testP139() {
    org.junit.Assert.assertEquals("10057761", new p139().run());
}

@Test()
public void testP142() {
    org.junit.Assert.assertEquals("1006193", new p142().run());
}

@Test()
public void testP145() {
    org.junit.Assert.assertEquals("608720", new p145().run());
}

@Test()
public void testP146() {
    org.junit.Assert.assertEquals("676333270", new p146().run());
}

@Test()
public void testP149() {
    org.junit.Assert.assertEquals("52852124", new p149().run());
}

@Test()
public void testP150() {
    org.junit.Assert.assertEquals("-271248680", new p150().run());
}

@Test()
public void testP151() {
    org.junit.Assert.assertEquals("0.464399", new p151().run());
}

@Test()
public void testP155() {
    org.junit.Assert.assertEquals("3857447", new p155().run());
}

@Test()
public void testP160() {
    org.junit.Assert.assertEquals("16576", new p160().run());
}

@Test()
public void testP162() {
    org.junit.Assert.assertEquals("3D58725572C62302", new p162().run());
}

@Test()
public void testP164() {
    org.junit.Assert.assertEquals("378158756814587", new p164().run());
}

@Test()
public void testP166() {
    org.junit.Assert.assertEquals("7130034", new p166().run());
}

@Test()
public void testP169() {
    org.junit.Assert.assertEquals("178653872807", new p169().run());
}

@Test()
public void testP171() {
    org.junit.Assert.assertEquals("142989277", new p171().run());
}

@Test()
public void testP172() {
    org.junit.Assert.assertEquals("227485267000992000", new p172().run());
}

@Test()
public void testP173() {
    org.junit.Assert.assertEquals("1572729", new p173().run());
}

@Test()
public void testP174() {
    org.junit.Assert.assertEquals("209566", new p174().run());
}

@Test()
public void testP178() {
    org.junit.Assert.assertEquals("126461847755", new p178().run());
}

@Test()
public void testP179() {
    org.junit.Assert.assertEquals("986262", new p179().run());
}

@Test()
public void testP182() {
    org.junit.Assert.assertEquals("399788195976", new p182().run());
}

@Test()
public void testP186() {
    org.junit.Assert.assertEquals("2325629", new p186().run());
}

@Test()
public void testP187() {
    org.junit.Assert.assertEquals("17427258", new p187().run());
}

@Test()
public void testP188() {
    org.junit.Assert.assertEquals("95962097", new p188().run());
}

@Test()
public void testP191() {
    org.junit.Assert.assertEquals("1918080160", new p191().run());
}

@Test()
public void testP197() {
    org.junit.Assert.assertEquals("1.710637717", new p197().run());
}

@Test()
public void testP203() {
    org.junit.Assert.assertEquals("34029210557338", new p203().run());
}

@Test()
public void testP204() {
    org.junit.Assert.assertEquals("2944730", new p204().run());
}

@Test()
public void testP205() {
    org.junit.Assert.assertEquals("0.5731441", new p205().run());
}

@Test()
public void testP206() {
    org.junit.Assert.assertEquals("1389019170", new p206().run());
}

@Test()
public void testP208() {
    org.junit.Assert.assertEquals("331951449665644800", new p208().run());
}

@Test()
public void testP211() {
    org.junit.Assert.assertEquals("1922364685", new p211().run());
}

@Test()
public void testP214() {
    org.junit.Assert.assertEquals("1677366278943", new p214().run());
}

@Test()
public void testP215() {
    org.junit.Assert.assertEquals("806844323190414", new p215().run());
}

@Test()
public void testP216() {
    org.junit.Assert.assertEquals("5437849", new p216().run());
}

@Test()
public void testP218() {
    org.junit.Assert.assertEquals("0", new p218().run());
}

@Test()
public void testP222() {
    org.junit.Assert.assertEquals("1590933", new p222().run());
}

@Test()
public void testP225() {
    org.junit.Assert.assertEquals("2009", new p225().run());
}

@Test()
public void testP231() {
    org.junit.Assert.assertEquals("7526965179680", new p231().run());
}

@Test()
public void testP243() {
    org.junit.Assert.assertEquals("892371480", new p243().run());
}

@Test()
public void testP249() {
    org.junit.Assert.assertEquals("9275262564250418", new p249().run());
}

@Test()
public void testP250() {
    org.junit.Assert.assertEquals("1425480602091519", new p250().run());
}

@Test()
public void testP265() {
    org.junit.Assert.assertEquals("209110240768", new p265().run());
}

@Test()
public void testP267() {
    org.junit.Assert.assertEquals("0.999992836187", new p267().run());
}

@Test()
public void testP271() {
    org.junit.Assert.assertEquals("4617456485273129588", new p271().run());
}

@Test()
public void testP280() {
    org.junit.Assert.assertEquals("430.088247", new p280().run());
}

@Test()
public void testP301() {
    org.junit.Assert.assertEquals("2178309", new p301().run());
}

@Test()
public void testP303() {
    org.junit.Assert.assertEquals("1111981904675169", new p303().run());
}

@Test()
public void testP304() {
    org.junit.Assert.assertEquals("283988410192", new p304().run());
}

@Test()
public void testP315() {
    org.junit.Assert.assertEquals("13625242", new p315().run());
}

@Test()
public void testP323() {
    org.junit.Assert.assertEquals("6.3551758451", new p323().run());
}

@Test()
public void testP329() {
    org.junit.Assert.assertEquals("199740353/29386561536000", new p329().run());
}

@Test()
public void testP345() {
    org.junit.Assert.assertEquals("13938", new p345().run());
}

@Test()
public void testP346() {
    org.junit.Assert.assertEquals("336108797689259276", new p346().run());
}

@Test()
public void testP347() {
    org.junit.Assert.assertEquals("11109800204052", new p347().run());
}

@Test()
public void testP348() {
    org.junit.Assert.assertEquals("1004195061", new p348().run());
}

@Test()
public void testP357() {
    org.junit.Assert.assertEquals("1739023853137", new p357().run());
}

@Test()
public void testP381() {
    org.junit.Assert.assertEquals("139602943319822", new p381().run());
}

@Test()
public void testP387() {
    org.junit.Assert.assertEquals("696067597313468", new p387().run());
}

@Test()
public void testP401() {
    org.junit.Assert.assertEquals("281632621", new p401().run());
}

@Test()
public void testP407() {
    org.junit.Assert.assertEquals("39782849136421", new p407().run());
}

@Test()
public void testP417() {
    org.junit.Assert.assertEquals("446572970925740", new p417().run());
}

@Test()
public void testP425() {
    org.junit.Assert.assertEquals("46479497324", new p425().run());
}

@Test()
public void testP429() {
    org.junit.Assert.assertEquals("98792821", new p429().run());
}

@Test()
public void testP431() {
    org.junit.Assert.assertEquals("23.386029052", new p431().run());
}

@Test()
public void testP433() {
    org.junit.Assert.assertEquals("326624372659664", new p433().run());
}

@Test()
public void testP451() {
    org.junit.Assert.assertEquals("153651073760956", new p451().run());
}

@Test()
public void testP493() {
    org.junit.Assert.assertEquals("6.818741802", new p493().run());
}

@Test()
public void testP500() {
    org.junit.Assert.assertEquals("35407281", new p500().run());
}

@Test()
public void testP518() {
    org.junit.Assert.assertEquals("100315739184392", new p518().run());
}

@Test()
public void testP549() {
    org.junit.Assert.assertEquals("476001479068717", new p549().run());
}

@Test()
public void testP587() {
    org.junit.Assert.assertEquals("2240", new p587().run());
}

public <init>(BigInteger numer) {
    super();
    numerator = numer;
    denominator = BigInteger.ONE;
}
STATEMENT:
super();
STATEMENT:
numerator = numer;
STATEMENT:
denominator = BigInteger.ONE;

public <init>(BigInteger numer, BigInteger denom) {
    super();
    if (denom.signum() == 0) throw new ArithmeticException("Division by zero");
    if (denom.signum() == -1) {
        numer = numer.negate();
        denom = denom.negate();
    }
    BigInteger gcd = numer.gcd(denom);
    if (!gcd.equals(BigInteger.ONE)) {
        numer = numer.divide(gcd);
        denom = denom.divide(gcd);
    }
    numerator = numer;
    denominator = denom;
}
STATEMENT:
super();
STATEMENT:
if (denom.signum() == 0) throw new ArithmeticException("Division by zero");
STATEMENT:
if (denom.signum() == -1) {
    numer = numer.negate();
    denom = denom.negate();
}
STATEMENT:
BigInteger gcd = numer.gcd(denom)
STATEMENT:
if (!gcd.equals(BigInteger.ONE)) {
    numer = numer.divide(gcd);
    denom = denom.divide(gcd);
}
STATEMENT:
numerator = numer;
STATEMENT:
denominator = denom;

public Fraction add(Fraction other) {
    return new Fraction(numerator.multiply(other.denominator).add(other.numerator.multiply(denominator)), denominator.multiply(other.denominator));
}

public Fraction subtract(Fraction other) {
    return new Fraction(numerator.multiply(other.denominator).subtract(other.numerator.multiply(denominator)), denominator.multiply(other.denominator));
}

public Fraction multiply(Fraction other) {
    return new Fraction(numerator.multiply(other.numerator), denominator.multiply(other.denominator));
}

public Fraction divide(Fraction other) {
    return new Fraction(numerator.multiply(other.denominator), denominator.multiply(other.numerator));
}

public boolean equals(Object obj) {
    if (!(obj instanceof Fraction)) return false;
    Fraction other = (Fraction)(Fraction)obj;
    return numerator.equals(other.numerator) && denominator.equals(other.denominator);
}

public int compareTo(Fraction other) {
    return numerator.multiply(other.denominator).compareTo(other.numerator.multiply(denominator));
}

public int hashCode() {
    return numerator.hashCode() + denominator.hashCode();
}

public String toString() {
    return numerator + "/" + denominator;
}

<init>() {
    super();
}
STATEMENT:
super();

private <init>(/*synthetic*/ final D this$0) {
    this.this$0 = this$0;
    super();
}
STATEMENT:
super();

<init>() {
    super();
}
STATEMENT:
super();

public static String reverse(String s) {
    return new StringBuilder(s).reverse().toString();
}

public static boolean isPalindrome(String s) {
    return s.equals(reverse(s));
}

public static boolean isPalindrome(int x) {
    return isPalindrome(Integer.toString(x));
}

public static int sqrt(int x) {
    if (x < 0) throw new IllegalArgumentException("Square root of negative number");
    int y = 0;
    for (int i = 1 << 15; i != 0; i >>>= 1) {
        y |= i;
        if (y > 46340 || y * y > x) y ^= i;
    }
    return y;
}

public static long sqrt(long x) {
    if (x < 0) throw new IllegalArgumentException("Square root of negative number");
    long y = 0;
    for (long i = 1L << 31; i != 0; i >>>= 1) {
        y |= i;
        if (y > 3037000499L || y * y > x) y ^= i;
    }
    return y;
}

public static BigInteger sqrt(BigInteger x) {
    if (x.signum() == -1) throw new IllegalArgumentException("Square root of negative number");
    BigInteger y = BigInteger.ZERO;
    for (int i = (x.bitLength() - 1) / 2; i >= 0; --i) {
        y = y.setBit(i);
        if (y.multiply(y).compareTo(x) > 0) y = y.clearBit(i);
    }
    return y;
}

public static boolean isSquare(int x) {
    if (x < 0) return false;
    int y = Library.sqrt(x);
    return y * y == x;
}

public static int pow(int x, int y) {
    if (x < 0) throw new IllegalArgumentException("Negative base not supported");
    if (y < 0) throw new IllegalArgumentException("Negative exponent");
    int z = 1;
    for (int i = 0; i < y; ++i) {
        if (Integer.MAX_VALUE / z < x) throw new ArithmeticException("Overflow");
        z *= x;
    }
    return z;
}

public static int powMod(int x, int y, int m) {
    if (x < 0) throw new IllegalArgumentException("Negative base not supported");
    if (y < 0) throw new IllegalArgumentException("Modular reciprocal not supported");
    if (m <= 0) throw new IllegalArgumentException("Modulus must be positive");
    if (m == 1) return 0;
    int z = 1;
    for (; y != 0; y >>>= 1) {
        if ((y & 1) != 0) z = (int)((long)z * x % m);
        x = (int)((long)x * x % m);
    }
    return z;
}

public static int reciprocalMod(int x, int m) {
    if (!(0 <= x && x < m)) throw new IllegalArgumentException();
    int y = x;
    x = m;
    int a = 0;
    int b = 1;
    while (y != 0) {
        int z = x % y;
        int c = a - x / y * b;
        x = y;
        y = z;
        a = b;
        b = c;
    }
    if (x == 1) return a >= 0 ? a : a + m; else throw new IllegalArgumentException("Reciprocal does not exist");
}

public static BigInteger factorial(int n) {
    if (n < 0) throw new IllegalArgumentException("Factorial of negative number");
    BigInteger prod = BigInteger.ONE;
    for (int i = 2; i <= n; ++i) prod = prod.multiply(BigInteger.valueOf(i));
    return prod;
}

public static BigInteger binomial(int n, int k) {
    if (k < 0 || k > n) throw new IllegalArgumentException();
    BigInteger product = BigInteger.ONE;
    for (int i = 0; i < k; ++i) product = product.multiply(BigInteger.valueOf(n - i));
    return product.divide(factorial(k));
}

public static int gcd(int x, int y) {
    if (x < 0 || y < 0) throw new IllegalArgumentException("Negative number");
    while (y != 0) {
        int z = x % y;
        x = y;
        y = z;
    }
    return x;
}

public static boolean isPrime(int x) {
    if (x < 0) throw new IllegalArgumentException("Negative number");
    if (x == 0 || x == 1) return false; else if (x == 2) return true; else {
        if (x % 2 == 0) return false;
        for (int i = 3, end = sqrt(x); i <= end; i += 2) {
            if (x % i == 0) return false;
        }
        return true;
    }
}

public static boolean[] listPrimality(int n) {
    if (n < 0) throw new IllegalArgumentException("Negative array size");
    boolean[] result = new boolean[n + 1];
    if (n >= 2) result[2] = true;
    for (int i = 3; i <= n; i += 2) result[i] = true;
    for (int i = 3, end = sqrt(n); i <= end; i += 2) {
        if (result[i]) {
            for (int j = i * i, inc = i * 2; j <= n; j += inc) result[j] = false;
        }
    }
    return result;
}

public static int[] listPrimes(int n) {
    boolean[] isPrime = listPrimality(n);
    int count = 0;
    for (/*synthetic*/ boolean[] arr$ = isPrime, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        boolean b = arr$[i$];
        {
            if (b) ++count;
        }
    }
    int[] result = new int[count];
    for (int i = 0, j = 0; i < isPrime.length; ++i) {
        if (isPrime[i]) {
            result[j] = i;
            ++j;
        }
    }
    return result;
}

public static int[] listSmallestPrimeFactors(int n) {
    int[] result = new int[n + 1];
    int limit = sqrt(n);
    for (int i = 2; i < result.length; ++i) {
        if (result[i] == 0) {
            result[i] = i;
            if (i <= limit) {
                for (int j = i * i; j <= n; j += i) {
                    if (result[j] == 0) result[j] = i;
                }
            }
        }
    }
    return result;
}

public static int totient(int n) {
    if (n <= 0) throw new IllegalArgumentException("Totient of non-positive integer");
    int p = 1;
    for (int i = 2, end = Library.sqrt(n); i <= end; ++i) {
        if (n % i == 0) {
            p *= i - 1;
            n /= i;
            while (n % i == 0) {
                p *= i;
                n /= i;
            }
            end = Library.sqrt(n);
        }
    }
    if (n != 1) p *= n - 1;
    return p;
}

public static int[] listTotients(int n) {
    if (n < 0) throw new IllegalArgumentException("Negative array size");
    int[] result = new int[n + 1];
    for (int i = 0; i <= n; ++i) result[i] = i;
    for (int i = 2; i <= n; ++i) {
        if (result[i] == i) {
            for (int j = i; j <= n; j += i) result[j] -= result[j] / i;
        }
    }
    return result;
}

public static boolean nextPermutation(int[] arr) {
    int i = arr.length - 1;
    for (; i > 0 && arr[i - 1] >= arr[i]; --i) ;
    if (i <= 0) return false;
    {
        int j = arr.length - 1;
        for (; arr[j] <= arr[i - 1]; --j) ;
        int temp = arr[i - 1];
        arr[i - 1] = arr[j];
        arr[j] = temp;
    }
    for (int j = arr.length - 1; i < j; ++i, --j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    return true;
}

<init>() {
    super();
}
STATEMENT:
super();

public <init>() {
    super();
}
STATEMENT:
super();

@Test()
public void testReverse() {
    Assert.assertEquals("", Library.reverse(""));
    Assert.assertEquals("a", Library.reverse("a"));
    Assert.assertEquals("ba", Library.reverse("ab"));
    Assert.assertEquals("001", Library.reverse("100"));
    Assert.assertEquals("a0a", Library.reverse("a0a"));
}

@Test()
public void testIsPalindromeString() {
    Assert.assertTrue(Library.isPalindrome(""));
    Assert.assertTrue(Library.isPalindrome("a"));
    Assert.assertTrue(Library.isPalindrome("aa"));
    Assert.assertTrue(Library.isPalindrome("aaa"));
    Assert.assertTrue(Library.isPalindrome("aaaa"));
    Assert.assertTrue(Library.isPalindrome("aba"));
    Assert.assertTrue(Library.isPalindrome("abba"));
    Assert.assertTrue(Library.isPalindrome("abbba"));
    Assert.assertTrue(Library.isPalindrome("acbca"));
    Assert.assertFalse(Library.isPalindrome("ab"));
    Assert.assertFalse(Library.isPalindrome("ba"));
    Assert.assertFalse(Library.isPalindrome("aaba"));
    Assert.assertFalse(Library.isPalindrome("abcd"));
}

@Test()
public void testIsPalindromeInt() {
    Assert.assertTrue(Library.isPalindrome(0));
    Assert.assertTrue(Library.isPalindrome(1));
    Assert.assertTrue(Library.isPalindrome(5));
    Assert.assertTrue(Library.isPalindrome(11));
    Assert.assertTrue(Library.isPalindrome(33));
    Assert.assertTrue(Library.isPalindrome(101));
    Assert.assertTrue(Library.isPalindrome(151));
    Assert.assertTrue(Library.isPalindrome(737));
    Assert.assertTrue(Library.isPalindrome(2222));
    Assert.assertTrue(Library.isPalindrome(5665));
    Assert.assertTrue(Library.isPalindrome(2147447412));
    Assert.assertFalse(Library.isPalindrome(12));
    Assert.assertFalse(Library.isPalindrome(43));
    Assert.assertFalse(Library.isPalindrome(220));
    Assert.assertFalse(Library.isPalindrome(1010));
    Assert.assertFalse(Library.isPalindrome(2147483647));
}

@Test()
public void testSqrtInt() {
    Assert.assertEquals(0, Library.sqrt(0));
    Assert.assertEquals(1, Library.sqrt(1));
    Assert.assertEquals(1, Library.sqrt(2));
    Assert.assertEquals(1, Library.sqrt(3));
    Assert.assertEquals(2, Library.sqrt(4));
    Assert.assertEquals(2, Library.sqrt(5));
    Assert.assertEquals(2, Library.sqrt(8));
    Assert.assertEquals(3, Library.sqrt(9));
    Assert.assertEquals(3, Library.sqrt(10));
    Assert.assertEquals(18, Library.sqrt(360));
    Assert.assertEquals(19, Library.sqrt(361));
    Assert.assertEquals(19, Library.sqrt(362));
    Assert.assertEquals(256, Library.sqrt(65536));
    Assert.assertEquals(32768, Library.sqrt(1073741824));
    Assert.assertEquals(46340, Library.sqrt(2147483647));
}

@Test()
public void testSqrtIntRandomly() {
    final int trials = 1000000;
    for (int i = 0; i < trials; ++i) {
        int x = rand.nextInt() >>> 1;
        int y = Library.sqrt(x);
        Assert.assertTrue(0 <= y && y <= x);
        Assert.assertTrue((long)y * y <= x && x < (y + 1L) * (y + 1L));
    }
}

@Test(expected = IllegalArgumentException.class)
public void testSqrtIntInvalid0() {
    Library.sqrt(-1);
}

@Test(expected = IllegalArgumentException.class)
public void testSqrtIntInvalid1() {
    Library.sqrt(-300000);
}

@Test(expected = IllegalArgumentException.class)
public void testSqrtIntInvalid2() {
    Library.sqrt(Integer.MIN_VALUE);
}

@Test()
public void testSqrtLong() {
    Assert.assertEquals(0L, Library.sqrt(0L));
    Assert.assertEquals(1L, Library.sqrt(1L));
    Assert.assertEquals(1L, Library.sqrt(2L));
    Assert.assertEquals(1L, Library.sqrt(3L));
    Assert.assertEquals(2L, Library.sqrt(4L));
    Assert.assertEquals(2L, Library.sqrt(5L));
    Assert.assertEquals(2L, Library.sqrt(8L));
    Assert.assertEquals(3L, Library.sqrt(9L));
    Assert.assertEquals(3L, Library.sqrt(10L));
    Assert.assertEquals(18L, Library.sqrt(360L));
    Assert.assertEquals(19L, Library.sqrt(361L));
    Assert.assertEquals(19L, Library.sqrt(362L));
    Assert.assertEquals(256L, Library.sqrt(65536L));
    Assert.assertEquals(32768L, Library.sqrt(1073741824L));
    Assert.assertEquals(46340L, Library.sqrt(2147483648L));
    Assert.assertEquals(2645751L, Library.sqrt(7000000000000L));
    Assert.assertEquals(3037000499L, Library.sqrt(9223372036854775807L));
}

@Test()
public void testSqrtLongRandomly() {
    final int trials = 1000000;
    for (int i = 0; i < trials; ++i) {
        long x = rand.nextLong() >>> 1;
        long y = Library.sqrt(x);
        Assert.assertTrue(0 <= y && y <= x);
        if (x > 0) Assert.assertTrue(y <= x / y && x / (y + 1) < y + 1);
    }
}

@Test(expected = IllegalArgumentException.class)
public void testSqrtLongInvalid0() {
    Library.sqrt(-1);
}

@Test(expected = IllegalArgumentException.class)
public void testSqrtLongInvalid1() {
    Library.sqrt(-3000000000L);
}

@Test(expected = IllegalArgumentException.class)
public void testSqrtLongInvalid2() {
    Library.sqrt(Long.MIN_VALUE);
}

@Test()
public void testIsSquare() {
    Assert.assertTrue(Library.isSquare(0));
    Assert.assertTrue(Library.isSquare(1));
    Assert.assertTrue(Library.isSquare(4));
    Assert.assertTrue(Library.isSquare(9));
    Assert.assertTrue(Library.isSquare(16));
    Assert.assertTrue(Library.isSquare(25));
    Assert.assertTrue(Library.isSquare(36));
    Assert.assertTrue(Library.isSquare(100));
    Assert.assertTrue(Library.isSquare(65536));
    Assert.assertTrue(Library.isSquare(2147302921));
    Assert.assertTrue(Library.isSquare(2147395600));
    Assert.assertFalse(Library.isSquare(Integer.MIN_VALUE));
    Assert.assertFalse(Library.isSquare(Integer.MIN_VALUE + 1));
    Assert.assertFalse(Library.isSquare(-8654038));
    Assert.assertFalse(Library.isSquare(-300));
    Assert.assertFalse(Library.isSquare(-4));
    Assert.assertFalse(Library.isSquare(-1));
    Assert.assertFalse(Library.isSquare(2));
    Assert.assertFalse(Library.isSquare(3));
    Assert.assertFalse(Library.isSquare(5));
    Assert.assertFalse(Library.isSquare(6));
    Assert.assertFalse(Library.isSquare(7));
    Assert.assertFalse(Library.isSquare(8));
    Assert.assertFalse(Library.isSquare(120));
    Assert.assertFalse(Library.isSquare(9999));
    Assert.assertFalse(Library.isSquare(Integer.MAX_VALUE - 1));
    Assert.assertFalse(Library.isSquare(Integer.MAX_VALUE));
}

@Test()
public void testPowMod() {
    Assert.assertEquals(0, Library.powMod(0, 0, 1));
    Assert.assertEquals(0, Library.powMod(1, 0, 1));
    Assert.assertEquals(0, Library.powMod(0, 1, 1));
    Assert.assertEquals(0, Library.powMod(1, 1, 1));
    Assert.assertEquals(0, Library.powMod(2, 3, 1));
    Assert.assertEquals(1, Library.powMod(0, 0, 2));
    Assert.assertEquals(1, Library.powMod(1, 0, 2));
    Assert.assertEquals(1, Library.powMod(2, 0, 2));
    Assert.assertEquals(0, Library.powMod(0, 1, 2));
    Assert.assertEquals(1, Library.powMod(1, 1, 2));
    Assert.assertEquals(0, Library.powMod(2, 1, 2));
    Assert.assertEquals(0, Library.powMod(0, 2, 2));
    Assert.assertEquals(1, Library.powMod(1, 2, 2));
    Assert.assertEquals(0, Library.powMod(2, 2, 2));
    Assert.assertEquals(1, Library.powMod(2, 2, 3));
    Assert.assertEquals(4, Library.powMod(4, 3, 5));
    Assert.assertEquals(3, Library.powMod(7, 7, 10));
    Assert.assertEquals(326216098, Library.powMod(78051657, 234602, 456087413));
    Assert.assertEquals(1488576545, Library.powMod(2147480000, 2147483645, 2147483647));
}

@Test()
public void testReciprocalMod() {
    int[][] goodCases = {{1, 2, 1}, {1, 3, 1}, {2, 3, 2}, {1, 4, 1}, {3, 4, 3}, {1, 5, 1}, {2, 5, 3}, {3, 5, 2}, {4, 5, 4}, {2, 7, 4}, {3, 7, 5}, {4, 7, 2}, {5, 7, 3}, {6, 7, 6}, {18585, 26128, 5705}, {4352341, 7559949, 3054661}, {290514683, 936234758, 903930729}, {735803087, 1384775511, 1321131185}, {1, 2147483647, 1}, {2, 2147483647, 1073741824}, {188080773, 2147483647, 1201032874}, {527995520, 2147483647, 1215591224}, {1154582780, 2147483647, 193267031}, {1321286464, 2147483647, 95844396}, {2147483645, 2147483647, 1073741823}, {2147483646, 2147483647, 2147483646}};
    for (/*synthetic*/ int[][] arr$ = goodCases, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int[] cs = arr$[i$];
        Assert.assertEquals(cs[2], Library.reciprocalMod(cs[0], cs[1]));
    }
    int[][] badCases = {{Integer.MIN_VALUE, Integer.MIN_VALUE}, {-1, -1}, {0, -1}, {-1, 0}, {0, 0}, {1, 1}, {3, 2}, {Integer.MAX_VALUE, 1}, {2, 4}, {2, 6}, {3, 6}, {44100, 48000}, {77, 2147483646}, {30783, 2147483646}};
    for (/*synthetic*/ int[][] arr$ = badCases, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int[] cs = arr$[i$];
        {
            try {
                Library.reciprocalMod(cs[0], cs[1]);
                Assert.fail();
            } catch (IllegalArgumentException e) {
            }
        }
    }
}

@Test()
public void testReciprocalModRandomly() {
    final int trials = 100000;
    for (int i = 0; i < trials; ++i) {
        int mod = rand.nextInt() >>> 1;
        if (mod < 2) continue;
        int x = rand.nextInt(mod);
        if (Library.gcd(x, mod) == 1) {
            int y = Library.reciprocalMod(x, mod);
            Assert.assertTrue(1 <= y && y < mod);
            Assert.assertEquals(1, (long)x * y % mod);
            Assert.assertEquals(x, Library.reciprocalMod(y, mod));
        } else {
            try {
                Library.reciprocalMod(x, mod);
                Assert.fail();
            } catch (IllegalArgumentException e) {
            }
        }
    }
}

@Test()
public void testFactorial() {
    Assert.assertEquals(new BigInteger("1"), Library.factorial(0));
    Assert.assertEquals(new BigInteger("1"), Library.factorial(1));
    Assert.assertEquals(new BigInteger("2"), Library.factorial(2));
    Assert.assertEquals(new BigInteger("6"), Library.factorial(3));
    Assert.assertEquals(new BigInteger("24"), Library.factorial(4));
    Assert.assertEquals(new BigInteger("120"), Library.factorial(5));
    Assert.assertEquals(new BigInteger("720"), Library.factorial(6));
    Assert.assertEquals(new BigInteger("6227020800"), Library.factorial(13));
    Assert.assertEquals(new BigInteger("51090942171709440000"), Library.factorial(21));
    Assert.assertEquals(new BigInteger("265252859812191058636308480000000"), Library.factorial(30));
}

@Test(expected = IllegalArgumentException.class)
public void testFactorialInvalid0() {
    Library.factorial(-1);
}

@Test(expected = IllegalArgumentException.class)
public void testFactorialInvalid1() {
    Library.factorial(-563);
}

@Test(expected = IllegalArgumentException.class)
public void testFactorialInvalid2() {
    Library.factorial(Integer.MIN_VALUE);
}

@Test()
public void testBinomial() {
    Assert.assertEquals(new BigInteger("1"), Library.binomial(0, 0));
    Assert.assertEquals(new BigInteger("1"), Library.binomial(1, 0));
    Assert.assertEquals(new BigInteger("1"), Library.binomial(1, 1));
    Assert.assertEquals(new BigInteger("1"), Library.binomial(2, 0));
    Assert.assertEquals(new BigInteger("2"), Library.binomial(2, 1));
    Assert.assertEquals(new BigInteger("1"), Library.binomial(2, 2));
    Assert.assertEquals(new BigInteger("1"), Library.binomial(3, 0));
    Assert.assertEquals(new BigInteger("3"), Library.binomial(3, 1));
    Assert.assertEquals(new BigInteger("3"), Library.binomial(3, 2));
    Assert.assertEquals(new BigInteger("1"), Library.binomial(3, 3));
    Assert.assertEquals(new BigInteger("35"), Library.binomial(7, 4));
    Assert.assertEquals(new BigInteger("120"), Library.binomial(10, 7));
    Assert.assertEquals(new BigInteger("21"), Library.binomial(21, 20));
    Assert.assertEquals(new BigInteger("88749815264600"), Library.binomial(50, 28));
}

@Test()
public void testGcd() {
    Assert.assertEquals(0, Library.gcd(0, 0));
    Assert.assertEquals(1, Library.gcd(0, 1));
    Assert.assertEquals(1, Library.gcd(1, 0));
    Assert.assertEquals(6, Library.gcd(0, 6));
    Assert.assertEquals(6, Library.gcd(6, 0));
    Assert.assertEquals(1, Library.gcd(1, 1));
    Assert.assertEquals(2, Library.gcd(2, 2));
    Assert.assertEquals(1, Library.gcd(2, 3));
    Assert.assertEquals(1, Library.gcd(10, 3));
    Assert.assertEquals(3, Library.gcd(9, 3));
    Assert.assertEquals(2, Library.gcd(6, 4));
    Assert.assertEquals(2, Library.gcd(18, 14));
    Assert.assertEquals(300, Library.gcd(44100, 48000));
    Assert.assertEquals(2147483647, Library.gcd(0, 2147483647));
    Assert.assertEquals(2147483647, Library.gcd(2147483647, 2147483647));
    Assert.assertEquals(1, Library.gcd(2147483646, 2147483647));
}

@Test()
public void testGcdRandomly() {
    final int trials = 1000000;
    for (int i = 0; i < trials; ++i) {
        int x = rand.nextInt() >>> 1;
        int y = rand.nextInt() >>> 1;
        int z = Library.gcd(x, y);
        if (x == 0) Assert.assertEquals(y, z); else if (y == 0) Assert.assertEquals(x, z); else Assert.assertTrue(0 < z && z <= x && z <= y && x % z == 0 && y % z == 0);
    }
}

@Test()
public void testIsPrime() {
    Assert.assertFalse(Library.isPrime(0));
    Assert.assertFalse(Library.isPrime(1));
    Assert.assertTrue(Library.isPrime(2));
    Assert.assertTrue(Library.isPrime(3));
    Assert.assertFalse(Library.isPrime(4));
    Assert.assertTrue(Library.isPrime(5));
    Assert.assertFalse(Library.isPrime(6));
    Assert.assertTrue(Library.isPrime(7));
    Assert.assertFalse(Library.isPrime(8));
    Assert.assertFalse(Library.isPrime(9));
    Assert.assertFalse(Library.isPrime(10));
    Assert.assertTrue(Library.isPrime(11));
    Assert.assertFalse(Library.isPrime(12));
    Assert.assertTrue(Library.isPrime(13));
    Assert.assertFalse(Library.isPrime(14));
    Assert.assertFalse(Library.isPrime(15));
    Assert.assertFalse(Library.isPrime(16));
    Assert.assertTrue(Library.isPrime(17));
    Assert.assertFalse(Library.isPrime(18));
    Assert.assertTrue(Library.isPrime(19));
    Assert.assertFalse(Library.isPrime(20));
}

@Test(expected = IllegalArgumentException.class)
public void testIsPrimeInvalid0() {
    Library.isPrime(-1);
}

@Test(expected = IllegalArgumentException.class)
public void testIsPrimeInvalid1() {
    Library.isPrime(-3000);
}

@Test()
public void testListPrimality() {
    boolean[] isPrime = Library.listPrimality(1000);
    for (int i = 0; i < isPrime.length; ++i) Assert.assertEquals(Boolean.valueOf(Library.isPrime(i)), Boolean.valueOf(isPrime[i]));
}

@Test(expected = IllegalArgumentException.class)
public void testListPrimalityInvalid0() {
    Library.listPrimality(-1);
}

@Test(expected = IllegalArgumentException.class)
public void testListPrimalityInvalid1() {
    Library.listPrimality(-3000);
}

@Test()
public void testListPrimes() {
    int limit = 1000;
    int[] primes = Library.listPrimes(limit);
    for (int i = 0; i < primes.length - 1; ++i) Assert.assertTrue(primes[i] < primes[i + 1]);
    for (int i = 0; i <= limit; ++i) Assert.assertEquals(Boolean.valueOf(Library.isPrime(i)), Boolean.valueOf(Arrays.binarySearch(primes, i) >= 0));
}

@Test(expected = IllegalArgumentException.class)
public void testListPrimesInvalid0() {
    Library.listPrimes(-1);
}

@Test(expected = IllegalArgumentException.class)
public void testListPrimesInvalid1() {
    Library.listPrimes(-3000);
}

@Test()
public void testTotient() {
    Assert.assertEquals(1, Library.totient(1));
    Assert.assertEquals(1, Library.totient(2));
    Assert.assertEquals(2, Library.totient(3));
    Assert.assertEquals(2, Library.totient(4));
    Assert.assertEquals(4, Library.totient(5));
    Assert.assertEquals(2, Library.totient(6));
    Assert.assertEquals(6, Library.totient(7));
    Assert.assertEquals(4, Library.totient(8));
    Assert.assertEquals(6, Library.totient(9));
    Assert.assertEquals(4, Library.totient(10));
    Assert.assertEquals(10, Library.totient(11));
    Assert.assertEquals(4, Library.totient(12));
    Assert.assertEquals(12, Library.totient(13));
    Assert.assertEquals(6, Library.totient(14));
    Assert.assertEquals(8, Library.totient(15));
    Assert.assertEquals(8, Library.totient(16));
    Assert.assertEquals(16, Library.totient(17));
    Assert.assertEquals(6, Library.totient(18));
    Assert.assertEquals(18, Library.totient(19));
    Assert.assertEquals(8, Library.totient(20));
}

@Test()
public void testTotientRandomly() {
    final int trials = 100;
    for (int i = 0; i < trials; ++i) {
        int n = rand.nextInt(100000) + 1;
        int tot = 0;
        for (int j = 1; j <= n; ++j) {
            if (Library.gcd(j, n) == 1) ++tot;
        }
        Assert.assertEquals(tot, Library.totient(n));
    }
}

@Test(expected = IllegalArgumentException.class)
public void testTotientInvalid0() {
    Library.totient(-1);
}

@Test(expected = IllegalArgumentException.class)
public void testTotientInvalid1() {
    Library.totient(-3000);
}

@Test()
public void testListTotients() {
    int[] totients = Library.listTotients(1000);
    for (int i = 1; i < totients.length; ++i) Assert.assertEquals(Library.totient(i), totients[i]);
}

@Test(expected = IllegalArgumentException.class)
public void testListTotientsInvalid0() {
    Library.listTotients(-1);
}

@Test(expected = IllegalArgumentException.class)
public void testListTotientsInvalid1() {
    Library.listTotients(-3000);
}

@Test()
public void testNextPermutation() {
    int[] arr;
    Assert.assertFalse(Library.nextPermutation(new int[0]));
    arr = new int[]{0, 0, 1};
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{0, 1, 0}, arr);
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 0, 0}, arr);
    Assert.assertFalse(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 0, 0}, arr);
    arr = new int[]{1, 2, 3, 5, 9};
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 2, 3, 9, 5}, arr);
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 2, 5, 3, 9}, arr);
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 2, 5, 9, 3}, arr);
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 2, 9, 3, 5}, arr);
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 2, 9, 5, 3}, arr);
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 3, 2, 5, 9}, arr);
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 3, 2, 9, 5}, arr);
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 3, 5, 2, 9}, arr);
    Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{1, 3, 5, 9, 2}, arr);
    for (int i = 0; i < 110; ++i) Assert.assertTrue(Library.nextPermutation(arr));
    Assert.assertFalse(Library.nextPermutation(arr));
    Assert.assertArrayEquals(new int[]{9, 5, 3, 2, 1}, arr);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p001().run());
}

public String run() {
    int sum = 0;
    for (int i = 0; i < 1000; ++i) {
        if (i % 3 == 0 || i % 5 == 0) sum += i;
    }
    return Integer.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p002().run());
}

public String run() {
    int sum = 0;
    int x = 1;
    int y = 2;
    while (x <= 4000000) {
        if (x % 2 == 0) sum += x;
        int z = x + y;
        x = y;
        y = z;
    }
    return Integer.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p003().run());
}

public String run() {
    long n = 600851475143L;
    while (true) {
        long p = smallestFactor(n);
        if (p < n) n /= p; else return Long.toString(n);
    }
}

private static long smallestFactor(long n) {
    if (n <= 1) throw new IllegalArgumentException();
    for (long i = 2, end = Library.sqrt(n); i <= end; ++i) {
        if (n % i == 0) return i;
    }
    return n;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p004().run());
}

public String run() {
    int maxPalin = -1;
    for (int i = 100; i < 1000; ++i) {
        for (int j = 100; j < 1000; ++j) {
            int prod = i * j;
            if (Library.isPalindrome(prod) && prod > maxPalin) maxPalin = prod;
        }
    }
    return Integer.toString(maxPalin);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p005().run());
}

public String run() {
    BigInteger allLcm = BigInteger.ONE;
    for (int i = 1; i <= 20; ++i) allLcm = lcm(BigInteger.valueOf(i), allLcm);
    return allLcm.toString();
}

private static BigInteger lcm(BigInteger x, BigInteger y) {
    return x.divide(x.gcd(y)).multiply(y);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p006().run());
}

public String run() {
    int sum = 0;
    int sum2 = 0;
    for (int i = 1; i <= N; ++i) {
        sum += i;
        sum2 += i * i;
    }
    return Integer.toString(sum * sum - sum2);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p007().run());
}

public String run() {
    for (int i = 2, count = 0; ; ++i) {
        if (Library.isPrime(i)) {
            ++count;
            if (count == 10001) return Integer.toString(i);
        }
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p008().run());
}

public String run() {
    long maxProd = -1;
    for (int i = 0; i + ADJACENT <= NUMBER.length(); ++i) {
        long prod = 1;
        for (int j = 0; j < ADJACENT; ++j) prod *= NUMBER.charAt(i + j) - '0';
        maxProd = Math.max(prod, maxProd);
    }
    return Long.toString(maxProd);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p009().run());
}

public String run() {
    for (int a = 1; a < PERIMETER; ++a) {
        for (int b = a + 1; b < PERIMETER; ++b) {
            int c = PERIMETER - a - b;
            if (a * a + b * b == c * c) {
                return Integer.toString(a * b * c);
            }
        }
    }
    throw new AssertionError("Not found");
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p010().run());
}

public String run() {
    long sum = 0;
    for (/*synthetic*/ int[] arr$ = Library.listPrimes(LIMIT - 1), len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int p = arr$[i$];
        sum += p;
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p011().run());
}

public String run() {
    int max = -1;
    for (int y = 0; y < SQUARE.length; ++y) {
        for (int x = 0; x < SQUARE[y].length; ++x) {
            max = Math.max(product(x, y, 1, 0, CONSECUTIVE), max);
            max = Math.max(product(x, y, 0, 1, CONSECUTIVE), max);
            max = Math.max(product(x, y, 1, 1, CONSECUTIVE), max);
            max = Math.max(product(x, y, 1, -1, CONSECUTIVE), max);
        }
    }
    return Integer.toString(max);
}

private static int product(int x, int y, int dx, int dy, int n) {
    if (!isInBounds(x + (n - 1) * dx, y + (n - 1) * dy)) return -1;
    int prod = 1;
    for (int i = 0; i < n; ++i, x += dx, y += dy) prod *= SQUARE[y][x];
    return prod;
}

private static boolean isInBounds(int x, int y) {
    return 0 <= y && y < SQUARE.length && 0 <= x && x < SQUARE[y].length;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p012().run());
}

public String run() {
    int triangle = 0;
    for (int i = 1; ; ++i) {
        if (Integer.MAX_VALUE - triangle < i) throw new ArithmeticException("Overflow");
        triangle += i;
        if (countDivisors(triangle) > 500) return Integer.toString(triangle);
    }
}

private static int countDivisors(int n) {
    int count = 0;
    int end = Library.sqrt(n);
    for (int i = 1; i < end; ++i) {
        if (n % i == 0) count += 2;
    }
    if (end * end == n) ++count;
    return count;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p013().run());
}

public String run() {
    BigInteger sum = BigInteger.ZERO;
    for (/*synthetic*/ String[] arr$ = NUMBERS, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        String num = arr$[i$];
        sum = sum.add(new BigInteger(num));
    }
    return sum.toString().substring(0, 10);
}

public <init>() {
    super();
    collatzChainLength = new int[CACHE_SIZE.intValue()];
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p014().run());
}

public String run() {
    int maxArg = -1;
    int maxChain = 0;
    for (int i = 1; i < LIMIT; ++i) {
        int chainLen = collatzChainLength(BigInteger.valueOf(i));
        if (chainLen > maxChain) {
            maxArg = i;
            maxChain = chainLen;
        }
    }
    return Integer.toString(maxArg);
}

private int collatzChainLength(BigInteger n) {
    if (n.signum() < 0) throw new IllegalArgumentException();
    if (n.compareTo(CACHE_SIZE) >= 0) return collatzChainLengthDirect(n);
    int index = n.intValue();
    if (collatzChainLength[index] == 0) collatzChainLength[index] = collatzChainLengthDirect(n);
    return collatzChainLength[index];
}

private int collatzChainLengthDirect(BigInteger n) {
    if (n.equals(BigInteger.ONE)) return 1; else if (!n.testBit(0)) return collatzChainLength(n.shiftRight(1)) + 1; else return collatzChainLength(n.multiply(BigInteger.valueOf(3)).add(BigInteger.ONE)) + 1;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p015().run());
}

public String run() {
    return Library.binomial(40, 20).toString();
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p016().run());
}

public String run() {
    String temp = BigInteger.ONE.shiftLeft(1000).toString();
    int sum = 0;
    for (int i = 0; i < temp.length(); ++i) sum += temp.charAt(i) - '0';
    return Integer.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p017().run());
}

public String run() {
    int sum = 0;
    for (int i = 1; i <= 1000; ++i) sum += toEnglish(i).length();
    return Integer.toString(sum);
}

private static String toEnglish(int n) {
    if (0 <= n && n < 20) return ONES[n]; else if (20 <= n && n < 100) return TENS[n / 10] + (n % 10 != 0 ? ONES[n % 10] : ""); else if (100 <= n && n < 1000) return ONES[n / 100] + "hundred" + (n % 100 != 0 ? "and" + toEnglish(n % 100) : ""); else if (1000 <= n && n < 1000000) return toEnglish(n / 1000) + "thousand" + (n % 1000 != 0 ? toEnglish(n % 1000) : ""); else throw new IllegalArgumentException();
}

public <init>() {
    super();
    triangle = {{75}, {95, 64}, {17, 47, 82}, {18, 35, 87, 10}, {20, 4, 82, 47, 65}, {19, 1, 23, 75, 3, 34}, {88, 2, 77, 73, 7, 63, 67}, {99, 65, 4, 28, 6, 16, 70, 92}, {41, 41, 26, 56, 83, 40, 80, 70, 33}, {41, 48, 72, 33, 47, 32, 37, 16, 94, 29}, {53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14}, {70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57}, {91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48}, {63, 66, 4, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31}, {4, 62, 98, 27, 23, 9, 70, 98, 73, 93, 38, 53, 60, 4, 23}};
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p018().run());
}

public String run() {
    for (int i = triangle.length - 2; i >= 0; --i) {
        for (int j = 0; j < triangle[i].length; ++j) triangle[i][j] += Math.max(triangle[i + 1][j], triangle[i + 1][j + 1]);
    }
    return Integer.toString(triangle[0][0]);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p019().run());
}

public String run() {
    int count = 0;
    for (int y = 1901; y <= 2000; ++y) {
        for (int m = 1; m <= 12; ++m) {
            if (dayOfWeek(y, m, 1) == 0) ++count;
        }
    }
    return Integer.toString(count);
}

private static int dayOfWeek(int year, int month, int day) {
    if (year < 0 || year > 10000 || month < 1 || month > 12 || day < 1 || day > 31) throw new IllegalArgumentException();
    int m = (month - 3 + 4800) % 4800;
    int y = (year + m / 12) % 400;
    m %= 12;
    return (y + y / 4 - y / 100 + (13 * m + 2) / 5 + day + 2) % 7;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p020().run());
}

public String run() {
    String temp = Library.factorial(100).toString();
    int sum = 0;
    for (int i = 0; i < temp.length(); ++i) sum += temp.charAt(i) - '0';
    return Integer.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p021().run());
}

public String run() {
    int sum = 0;
    for (int i = 1; i < 10000; ++i) {
        if (isAmicable(i)) sum += i;
    }
    return Integer.toString(sum);
}

private static boolean isAmicable(int n) {
    int m = divisorSum(n);
    return m != n && divisorSum(m) == n;
}

private static int divisorSum(int n) {
    int sum = 0;
    for (int i = 1; i < n; ++i) {
        if (n % i == 0) sum += i;
    }
    return sum;
}

public <init>() {
    super();
    names = {"MARY", "PATRICIA", "LINDA", "BARBARA", "ELIZABETH", "JENNIFER", "MARIA", "SUSAN", "MARGARET", "DOROTHY", "LISA", "NANCY", "KAREN", "BETTY", "HELEN", "SANDRA", "DONNA", "CAROL", "RUTH", "SHARON", "MICHELLE", "LAURA", "SARAH", "KIMBERLY", "DEBORAH", "JESSICA", "SHIRLEY", "CYNTHIA", "ANGELA", "MELISSA", "BRENDA", "AMY", "ANNA", "REBECCA", "VIRGINIA", "KATHLEEN", "PAMELA", "MARTHA", "DEBRA", "AMANDA", "STEPHANIE", "CAROLYN", "CHRISTINE", "MARIE", "JANET", "CATHERINE", "FRANCES", "ANN", "JOYCE", "DIANE", "ALICE", "JULIE", "HEATHER", "TERESA", "DORIS", "GLORIA", "EVELYN", "JEAN", "CHERYL", "MILDRED", "KATHERINE", "JOAN", "ASHLEY", "JUDITH", "ROSE", "JANICE", "KELLY", "NICOLE", "JUDY", "CHRISTINA", "KATHY", "THERESA", "BEVERLY", "DENISE", "TAMMY", "IRENE", "JANE", "LORI", "RACHEL", "MARILYN", "ANDREA", "KATHRYN", "LOUISE", "SARA", "ANNE", "JACQUELINE", "WANDA", "BONNIE", "JULIA", "RUBY", "LOIS", "TINA", "PHYLLIS", "NORMA", "PAULA", "DIANA", "ANNIE", "LILLIAN", "EMILY", "ROBIN", "PEGGY", "CRYSTAL", "GLADYS", "RITA", "DAWN", "CONNIE", "FLORENCE", "TRACY", "EDNA", "TIFFANY", "CARMEN", "ROSA", "CINDY", "GRACE", "WENDY", "VICTORIA", "EDITH", "KIM", "SHERRY", "SYLVIA", "JOSEPHINE", "THELMA", "SHANNON", "SHEILA", "ETHEL", "ELLEN", "ELAINE", "MARJORIE", "CARRIE", "CHARLOTTE", "MONICA", "ESTHER", "PAULINE", "EMMA", "JUANITA", "ANITA", "RHONDA", "HAZEL", "AMBER", "EVA", "DEBBIE", "APRIL", "LESLIE", "CLARA", "LUCILLE", "JAMIE", "JOANNE", "ELEANOR", "VALERIE", "DANIELLE", "MEGAN", "ALICIA", "SUZANNE", "MICHELE", "GAIL", "BERTHA", "DARLENE", "VERONICA", "JILL", "ERIN", "GERALDINE", "LAUREN", "CATHY", "JOANN", "LORRAINE", "LYNN", "SALLY", "REGINA", "ERICA", "BEATRICE", "DOLORES", "BERNICE", "AUDREY", "YVONNE", "ANNETTE", "JUNE", "SAMANTHA", "MARION", "DANA", "STACY", "ANA", "RENEE", "IDA", "VIVIAN", "ROBERTA", "HOLLY", "BRITTANY", "MELANIE", "LORETTA", "YOLANDA", "JEANETTE", "LAURIE", "KATIE", "KRISTEN", "VANESSA", "ALMA", "SUE", "ELSIE", "BETH", "JEANNE", "VICKI", "CARLA", "TARA", "ROSEMARY", "EILEEN", "TERRI", "GERTRUDE", "LUCY", "TONYA", "ELLA", "STACEY", "WILMA", "GINA", "KRISTIN", "JESSIE", "NATALIE", "AGNES", "VERA", "WILLIE", "CHARLENE", "BESSIE", "DELORES", "MELINDA", "PEARL", "ARLENE", "MAUREEN", "COLLEEN", "ALLISON", "TAMARA", "JOY", "GEORGIA", "CONSTANCE", "LILLIE", "CLAUDIA", "JACKIE", "MARCIA", "TANYA", "NELLIE", "MINNIE", "MARLENE", "HEIDI", "GLENDA", "LYDIA", "VIOLA", "COURTNEY", "MARIAN", "STELLA", "CAROLINE", "DORA", "JO", "VICKIE", "MATTIE", "TERRY", "MAXINE", "IRMA", "MABEL", "MARSHA", "MYRTLE", "LENA", "CHRISTY", "DEANNA", "PATSY", "HILDA", "GWENDOLYN", "JENNIE", "NORA", "MARGIE", "NINA", "CASSANDRA", "LEAH", "PENNY", "KAY", "PRISCILLA", "NAOMI", "CAROLE", "BRANDY", "OLGA", "BILLIE", "DIANNE", "TRACEY", "LEONA", "JENNY", "FELICIA", "SONIA", "MIRIAM", "VELMA", "BECKY", "BOBBIE", "VIOLET", "KRISTINA", "TONI", "MISTY", "MAE", "SHELLY", "DAISY", "RAMONA", "SHERRI", "ERIKA", "KATRINA", "CLAIRE", "LINDSEY", "LINDSAY", "GENEVA", "GUADALUPE", "BELINDA", "MARGARITA", "SHERYL", "CORA", "FAYE", "ADA", "NATASHA", "SABRINA", "ISABEL", "MARGUERITE", "HATTIE", "HARRIET", "MOLLY", "CECILIA", "KRISTI", "BRANDI", "BLANCHE", "SANDY", "ROSIE", "JOANNA", "IRIS", "EUNICE", "ANGIE", "INEZ", "LYNDA", "MADELINE", "AMELIA", "ALBERTA", "GENEVIEVE", "MONIQUE", "JODI", "JANIE", "MAGGIE", "KAYLA", "SONYA", "JAN", "LEE", "KRISTINE", "CANDACE", "FANNIE", "MARYANN", "OPAL", "ALISON", "YVETTE", "MELODY", "LUZ", "SUSIE", "OLIVIA", "FLORA", "SHELLEY", "KRISTY", "MAMIE", "LULA", "LOLA", "VERNA", "BEULAH", "ANTOINETTE", "CANDICE", "JUANA", "JEANNETTE", "PAM", "KELLI", "HANNAH", "WHITNEY", "BRIDGET", "KARLA", "CELIA", "LATOYA", "PATTY", "SHELIA", "GAYLE", "DELLA", "VICKY", "LYNNE", "SHERI", "MARIANNE", "KARA", "JACQUELYN", "ERMA", "BLANCA", "MYRA", "LETICIA", "PAT", "KRISTA", "ROXANNE", "ANGELICA", "JOHNNIE", "ROBYN", "FRANCIS", "ADRIENNE", "ROSALIE", "ALEXANDRA", "BROOKE", "BETHANY", "SADIE", "BERNADETTE", "TRACI", "JODY", "KENDRA", "JASMINE", "NICHOLE", "RACHAEL", "CHELSEA", "MABLE", "ERNESTINE", "MURIEL", "MARCELLA", "ELENA", "KRYSTAL", "ANGELINA", "NADINE", "KARI", "ESTELLE", "DIANNA", "PAULETTE", "LORA", "MONA", "DOREEN", "ROSEMARIE", "ANGEL", "DESIREE", "ANTONIA", "HOPE", "GINGER", "JANIS", "BETSY", "CHRISTIE", "FREDA", "MERCEDES", "MEREDITH", "LYNETTE", "TERI", "CRISTINA", "EULA", "LEIGH", "MEGHAN", "SOPHIA", "ELOISE", "ROCHELLE", "GRETCHEN", "CECELIA", "RAQUEL", "HENRIETTA", "ALYSSA", "JANA", "KELLEY", "GWEN", "KERRY", "JENNA", "TRICIA", "LAVERNE", "OLIVE", "ALEXIS", "TASHA", "SILVIA", "ELVIRA", "CASEY", "DELIA", "SOPHIE", "KATE", "PATTI", "LORENA", "KELLIE", "SONJA", "LILA", "LANA", "DARLA", "MAY", "MINDY", "ESSIE", "MANDY", "LORENE", "ELSA", "JOSEFINA", "JEANNIE", "MIRANDA", "DIXIE", "LUCIA", "MARTA", "FAITH", "LELA", "JOHANNA", "SHARI", "CAMILLE", "TAMI", "SHAWNA", "ELISA", "EBONY", "MELBA", "ORA", "NETTIE", "TABITHA", "OLLIE", "JAIME", "WINIFRED", "KRISTIE", "MARINA", "ALISHA", "AIMEE", "RENA", "MYRNA", "MARLA", "TAMMIE", "LATASHA", "BONITA", "PATRICE", "RONDA", "SHERRIE", "ADDIE", "FRANCINE", "DELORIS", "STACIE", "ADRIANA", "CHERI", "SHELBY", "ABIGAIL", "CELESTE", "JEWEL", "CARA", "ADELE", "REBEKAH", "LUCINDA", "DORTHY", "CHRIS", "EFFIE", "TRINA", "REBA", "SHAWN", "SALLIE", "AURORA", "LENORA", "ETTA", "LOTTIE", "KERRI", "TRISHA", "NIKKI", "ESTELLA", "FRANCISCA", "JOSIE", "TRACIE", "MARISSA", "KARIN", "BRITTNEY", "JANELLE", "LOURDES", "LAUREL", "HELENE", "FERN", "ELVA", "CORINNE", "KELSEY", "INA", "BETTIE", "ELISABETH", "AIDA", "CAITLIN", "INGRID", "IVA", "EUGENIA", "CHRISTA", "GOLDIE", "CASSIE", "MAUDE", "JENIFER", "THERESE", "FRANKIE", "DENA", "LORNA", "JANETTE", "LATONYA", "CANDY", "MORGAN", "CONSUELO", "TAMIKA", "ROSETTA", "DEBORA", "CHERIE", "POLLY", "DINA", "JEWELL", "FAY", "JILLIAN", "DOROTHEA", "NELL", "TRUDY", "ESPERANZA", "PATRICA", "KIMBERLEY", "SHANNA", "HELENA", "CAROLINA", "CLEO", "STEFANIE", "ROSARIO", "OLA", "JANINE", "MOLLIE", "LUPE", "ALISA", "LOU", "MARIBEL", "SUSANNE", "BETTE", "SUSANA", "ELISE", "CECILE", "ISABELLE", "LESLEY", "JOCELYN", "PAIGE", "JONI", "RACHELLE", "LEOLA", "DAPHNE", "ALTA", "ESTER", "PETRA", "GRACIELA", "IMOGENE", "JOLENE", "KEISHA", "LACEY", "GLENNA", "GABRIELA", "KERI", "URSULA", "LIZZIE", "KIRSTEN", "SHANA", "ADELINE", "MAYRA", "JAYNE", "JACLYN", "GRACIE", "SONDRA", "CARMELA", "MARISA", "ROSALIND", "CHARITY", "TONIA", "BEATRIZ", "MARISOL", "CLARICE", "JEANINE", "SHEENA", "ANGELINE", "FRIEDA", "LILY", "ROBBIE", "SHAUNA", "MILLIE", "CLAUDETTE", "CATHLEEN", "ANGELIA", "GABRIELLE", "AUTUMN", "KATHARINE", "SUMMER", "JODIE", "STACI", "LEA", "CHRISTI", "JIMMIE", "JUSTINE", "ELMA", "LUELLA", "MARGRET", "DOMINIQUE", "SOCORRO", "RENE", "MARTINA", "MARGO", "MAVIS", "CALLIE", "BOBBI", "MARITZA", "LUCILE", "LEANNE", "JEANNINE", "DEANA", "AILEEN", "LORIE", "LADONNA", "WILLA", "MANUELA", "GALE", "SELMA", "DOLLY", "SYBIL", "ABBY", "LARA", "DALE", "IVY", "DEE", "WINNIE", "MARCY", "LUISA", "JERI", "MAGDALENA", "OFELIA", "MEAGAN", "AUDRA", "MATILDA", "LEILA", "CORNELIA", "BIANCA", "SIMONE", "BETTYE", "RANDI", "VIRGIE", "LATISHA", "BARBRA", "GEORGINA", "ELIZA", "LEANN", "BRIDGETTE", "RHODA", "HALEY", "ADELA", "NOLA", "BERNADINE", "FLOSSIE", "ILA", "GRETA", "RUTHIE", "NELDA", "MINERVA", "LILLY", "TERRIE", "LETHA", "HILARY", "ESTELA", "VALARIE", "BRIANNA", "ROSALYN", "EARLINE", "CATALINA", "AVA", "MIA", "CLARISSA", "LIDIA", "CORRINE", "ALEXANDRIA", "CONCEPCION", "TIA", "SHARRON", "RAE", "DONA", "ERICKA", "JAMI", "ELNORA", "CHANDRA", "LENORE", "NEVA", "MARYLOU", "MELISA", "TABATHA", "SERENA", "AVIS", "ALLIE", "SOFIA", "JEANIE", "ODESSA", "NANNIE", "HARRIETT", "LORAINE", "PENELOPE", "MILAGROS", "EMILIA", "BENITA", "ALLYSON", "ASHLEE", "TANIA", "TOMMIE", "ESMERALDA", "KARINA", "EVE", "PEARLIE", "ZELMA", "MALINDA", "NOREEN", "TAMEKA", "SAUNDRA", "HILLARY", "AMIE", "ALTHEA", "ROSALINDA", "JORDAN", "LILIA", "ALANA", "GAY", "CLARE", "ALEJANDRA", "ELINOR", "MICHAEL", "LORRIE", "JERRI", "DARCY", "EARNESTINE", "CARMELLA", "TAYLOR", "NOEMI", "MARCIE", "LIZA", "ANNABELLE", "LOUISA", "EARLENE", "MALLORY", "CARLENE", "NITA", "SELENA", "TANISHA", "KATY", "JULIANNE", "JOHN", "LAKISHA", "EDWINA", "MARICELA", "MARGERY", "KENYA", "DOLLIE", "ROXIE", "ROSLYN", "KATHRINE", "NANETTE", "CHARMAINE", "LAVONNE", "ILENE", "KRIS", "TAMMI", "SUZETTE", "CORINE", "KAYE", "JERRY", "MERLE", "CHRYSTAL", "LINA", "DEANNE", "LILIAN", "JULIANA", "ALINE", "LUANN", "KASEY", "MARYANNE", "EVANGELINE", "COLETTE", "MELVA", "LAWANDA", "YESENIA", "NADIA", "MADGE", "KATHIE", "EDDIE", "OPHELIA", "VALERIA", "NONA", "MITZI", "MARI", "GEORGETTE", "CLAUDINE", "FRAN", "ALISSA", "ROSEANN", "LAKEISHA", "SUSANNA", "REVA", "DEIDRE", "CHASITY", "SHEREE", "CARLY", "JAMES", "ELVIA", "ALYCE", "DEIRDRE", "GENA", "BRIANA", "ARACELI", "KATELYN", "ROSANNE", "WENDI", "TESSA", "BERTA", "MARVA", "IMELDA", "MARIETTA", "MARCI", "LEONOR", "ARLINE", "SASHA", "MADELYN", "JANNA", "JULIETTE", "DEENA", "AURELIA", "JOSEFA", "AUGUSTA", "LILIANA", "YOUNG", "CHRISTIAN", "LESSIE", "AMALIA", "SAVANNAH", "ANASTASIA", "VILMA", "NATALIA", "ROSELLA", "LYNNETTE", "CORINA", "ALFREDA", "LEANNA", "CAREY", "AMPARO", "COLEEN", "TAMRA", "AISHA", "WILDA", "KARYN", "CHERRY", "QUEEN", "MAURA", "MAI", "EVANGELINA", "ROSANNA", "HALLIE", "ERNA", "ENID", "MARIANA", "LACY", "JULIET", "JACKLYN", "FREIDA", "MADELEINE", "MARA", "HESTER", "CATHRYN", "LELIA", "CASANDRA", "BRIDGETT", "ANGELITA", "JANNIE", "DIONNE", "ANNMARIE", "KATINA", "BERYL", "PHOEBE", "MILLICENT", "KATHERYN", "DIANN", "CARISSA", "MARYELLEN", "LIZ", "LAURI", "HELGA", "GILDA", "ADRIAN", "RHEA", "MARQUITA", "HOLLIE", "TISHA", "TAMERA", "ANGELIQUE", "FRANCESCA", "BRITNEY", "KAITLIN", "LOLITA", "FLORINE", "ROWENA", "REYNA", "TWILA", "FANNY", "JANELL", "INES", "CONCETTA", "BERTIE", "ALBA", "BRIGITTE", "ALYSON", "VONDA", "PANSY", "ELBA", "NOELLE", "LETITIA", "KITTY", "DEANN", "BRANDIE", "LOUELLA", "LETA", "FELECIA", "SHARLENE", "LESA", "BEVERLEY", "ROBERT", "ISABELLA", "HERMINIA", "TERRA", "CELINA", "TORI", "OCTAVIA", "JADE", "DENICE", "GERMAINE", "SIERRA", "MICHELL", "CORTNEY", "NELLY", "DORETHA", "SYDNEY", "DEIDRA", "MONIKA", "LASHONDA", "JUDI", "CHELSEY", "ANTIONETTE", "MARGOT", "BOBBY", "ADELAIDE", "NAN", "LEEANN", "ELISHA", "DESSIE", "LIBBY", "KATHI", "GAYLA", "LATANYA", "MINA", "MELLISA", "KIMBERLEE", "JASMIN", "RENAE", "ZELDA", "ELDA", "MA", "JUSTINA", "GUSSIE", "EMILIE", "CAMILLA", "ABBIE", "ROCIO", "KAITLYN", "JESSE", "EDYTHE", "ASHLEIGH", "SELINA", "LAKESHA", "GERI", "ALLENE", "PAMALA", "MICHAELA", "DAYNA", "CARYN", "ROSALIA", "SUN", "JACQULINE", "REBECA", "MARYBETH", "KRYSTLE", "IOLA", "DOTTIE", "BENNIE", "BELLE", "AUBREY", "GRISELDA", "ERNESTINA", "ELIDA", "ADRIANNE", "DEMETRIA", "DELMA", "CHONG", "JAQUELINE", "DESTINY", "ARLEEN", "VIRGINA", "RETHA", "FATIMA", "TILLIE", "ELEANORE", "CARI", "TREVA", "BIRDIE", "WILHELMINA", "ROSALEE", "MAURINE", "LATRICE", "YONG", "JENA", "TARYN", "ELIA", "DEBBY", "MAUDIE", "JEANNA", "DELILAH", "CATRINA", "SHONDA", "HORTENCIA", "THEODORA", "TERESITA", "ROBBIN", "DANETTE", "MARYJANE", "FREDDIE", "DELPHINE", "BRIANNE", "NILDA", "DANNA", "CINDI", "BESS", "IONA", "HANNA", "ARIEL", "WINONA", "VIDA", "ROSITA", "MARIANNA", "WILLIAM", "RACHEAL", "GUILLERMINA", "ELOISA", "CELESTINE", "CAREN", "MALISSA", "LONA", "CHANTEL", "SHELLIE", "MARISELA", "LEORA", "AGATHA", "SOLEDAD", "MIGDALIA", "IVETTE", "CHRISTEN", "ATHENA", "JANEL", "CHLOE", "VEDA", "PATTIE", "TESSIE", "TERA", "MARILYNN", "LUCRETIA", "KARRIE", "DINAH", "DANIELA", "ALECIA", "ADELINA", "VERNICE", "SHIELA", "PORTIA", "MERRY", "LASHAWN", "DEVON", "DARA", "TAWANA", "OMA", "VERDA", "CHRISTIN", "ALENE", "ZELLA", "SANDI", "RAFAELA", "MAYA", "KIRA", "CANDIDA", "ALVINA", "SUZAN", "SHAYLA", "LYN", "LETTIE", "ALVA", "SAMATHA", "ORALIA", "MATILDE", "MADONNA", "LARISSA", "VESTA", "RENITA", "INDIA", "DELOIS", "SHANDA", "PHILLIS", "LORRI", "ERLINDA", "CRUZ", "CATHRINE", "BARB", "ZOE", "ISABELL", "IONE", "GISELA", "CHARLIE", "VALENCIA", "ROXANNA", "MAYME", "KISHA", "ELLIE", "MELLISSA", "DORRIS", "DALIA", "BELLA", "ANNETTA", "ZOILA", "RETA", "REINA", "LAURETTA", "KYLIE", "CHRISTAL", "PILAR", "CHARLA", "ELISSA", "TIFFANI", "TANA", "PAULINA", "LEOTA", "BREANNA", "JAYME", "CARMEL", "VERNELL", "TOMASA", "MANDI", "DOMINGA", "SANTA", "MELODIE", "LURA", "ALEXA", "TAMELA", "RYAN", "MIRNA", "KERRIE", "VENUS", "NOEL", "FELICITA", "CRISTY", "CARMELITA", "BERNIECE", "ANNEMARIE", "TIARA", "ROSEANNE", "MISSY", "CORI", "ROXANA", "PRICILLA", "KRISTAL", "JUNG", "ELYSE", "HAYDEE", "ALETHA", "BETTINA", "MARGE", "GILLIAN", "FILOMENA", "CHARLES", "ZENAIDA", "HARRIETTE", "CARIDAD", "VADA", "UNA", "ARETHA", "PEARLINE", "MARJORY", "MARCELA", "FLOR", "EVETTE", "ELOUISE", "ALINA", "TRINIDAD", "DAVID", "DAMARIS", "CATHARINE", "CARROLL", "BELVA", "NAKIA", "MARLENA", "LUANNE", "LORINE", "KARON", "DORENE", "DANITA", "BRENNA", "TATIANA", "SAMMIE", "LOUANN", "LOREN", "JULIANNA", "ANDRIA", "PHILOMENA", "LUCILA", "LEONORA", "DOVIE", "ROMONA", "MIMI", "JACQUELIN", "GAYE", "TONJA", "MISTI", "JOE", "GENE", "CHASTITY", "STACIA", "ROXANN", "MICAELA", "NIKITA", "MEI", "VELDA", "MARLYS", "JOHNNA", "AURA", "LAVERN", "IVONNE", "HAYLEY", "NICKI", "MAJORIE", "HERLINDA", "GEORGE", "ALPHA", "YADIRA", "PERLA", "GREGORIA", "DANIEL", "ANTONETTE", "SHELLI", "MOZELLE", "MARIAH", "JOELLE", "CORDELIA", "JOSETTE", "CHIQUITA", "TRISTA", "LOUIS", "LAQUITA", "GEORGIANA", "CANDI", "SHANON", "LONNIE", "HILDEGARD", "CECIL", "VALENTINA", "STEPHANY", "MAGDA", "KAROL", "GERRY", "GABRIELLA", "TIANA", "ROMA", "RICHELLE", "RAY", "PRINCESS", "OLETA", "JACQUE", "IDELLA", "ALAINA", "SUZANNA", "JOVITA", "BLAIR", "TOSHA", "RAVEN", "NEREIDA", "MARLYN", "KYLA", "JOSEPH", "DELFINA", "TENA", "STEPHENIE", "SABINA", "NATHALIE", "MARCELLE", "GERTIE", "DARLEEN", "THEA", "SHARONDA", "SHANTEL", "BELEN", "VENESSA", "ROSALINA", "ONA", "GENOVEVA", "COREY", "CLEMENTINE", "ROSALBA", "RENATE", "RENATA", "MI", "IVORY", "GEORGIANNA", "FLOY", "DORCAS", "ARIANA", "TYRA", "THEDA", "MARIAM", "JULI", "JESICA", "DONNIE", "VIKKI", "VERLA", "ROSELYN", "MELVINA", "JANNETTE", "GINNY", "DEBRAH", "CORRIE", "ASIA", "VIOLETA", "MYRTIS", "LATRICIA", "COLLETTE", "CHARLEEN", "ANISSA", "VIVIANA", "TWYLA", "PRECIOUS", "NEDRA", "LATONIA", "LAN", "HELLEN", "FABIOLA", "ANNAMARIE", "ADELL", "SHARYN", "CHANTAL", "NIKI", "MAUD", "LIZETTE", "LINDY", "KIA", "KESHA", "JEANA", "DANELLE", "CHARLINE", "CHANEL", "CARROL", "VALORIE", "LIA", "DORTHA", "CRISTAL", "SUNNY", "LEONE", "LEILANI", "GERRI", "DEBI", "ANDRA", "KESHIA", "IMA", "EULALIA", "EASTER", "DULCE", "NATIVIDAD", "LINNIE", "KAMI", "GEORGIE", "CATINA", "BROOK", "ALDA", "WINNIFRED", "SHARLA", "RUTHANN", "MEAGHAN", "MAGDALENE", "LISSETTE", "ADELAIDA", "VENITA", "TRENA", "SHIRLENE", "SHAMEKA", "ELIZEBETH", "DIAN", "SHANTA", "MICKEY", "LATOSHA", "CARLOTTA", "WINDY", "SOON", "ROSINA", "MARIANN", "LEISA", "JONNIE", "DAWNA", "CATHIE", "BILLY", "ASTRID", "SIDNEY", "LAUREEN", "JANEEN", "HOLLI", "FAWN", "VICKEY", "TERESSA", "SHANTE", "RUBYE", "MARCELINA", "CHANDA", "CARY", "TERESE", "SCARLETT", "MARTY", "MARNIE", "LULU", "LISETTE", "JENIFFER", "ELENOR", "DORINDA", "DONITA", "CARMAN", "BERNITA", "ALTAGRACIA", "ALETA", "ADRIANNA", "ZORAIDA", "RONNIE", "NICOLA", "LYNDSEY", "KENDALL", "JANINA", "CHRISSY", "AMI", "STARLA", "PHYLIS", "PHUONG", "KYRA", "CHARISSE", "BLANCH", "SANJUANITA", "RONA", "NANCI", "MARILEE", "MARANDA", "CORY", "BRIGETTE", "SANJUANA", "MARITA", "KASSANDRA", "JOYCELYN", "IRA", "FELIPA", "CHELSIE", "BONNY", "MIREYA", "LORENZA", "KYONG", "ILEANA", "CANDELARIA", "TONY", "TOBY", "SHERIE", "OK", "MARK", "LUCIE", "LEATRICE", "LAKESHIA", "GERDA", "EDIE", "BAMBI", "MARYLIN", "LAVON", "HORTENSE", "GARNET", "EVIE", "TRESSA", "SHAYNA", "LAVINA", "KYUNG", "JEANETTA", "SHERRILL", "SHARA", "PHYLISS", "MITTIE", "ANABEL", "ALESIA", "THUY", "TAWANDA", "RICHARD", "JOANIE", "TIFFANIE", "LASHANDA", "KARISSA", "ENRIQUETA", "DARIA", "DANIELLA", "CORINNA", "ALANNA", "ABBEY", "ROXANE", "ROSEANNA", "MAGNOLIA", "LIDA", "KYLE", "JOELLEN", "ERA", "CORAL", "CARLEEN", "TRESA", "PEGGIE", "NOVELLA", "NILA", "MAYBELLE", "JENELLE", "CARINA", "NOVA", "MELINA", "MARQUERITE", "MARGARETTE", "JOSEPHINA", "EVONNE", "DEVIN", "CINTHIA", "ALBINA", "TOYA", "TAWNYA", "SHERITA", "SANTOS", "MYRIAM", "LIZABETH", "LISE", "KEELY", "JENNI", "GISELLE", "CHERYLE", "ARDITH", "ARDIS", "ALESHA", "ADRIANE", "SHAINA", "LINNEA", "KAROLYN", "HONG", "FLORIDA", "FELISHA", "DORI", "DARCI", "ARTIE", "ARMIDA", "ZOLA", "XIOMARA", "VERGIE", "SHAMIKA", "NENA", "NANNETTE", "MAXIE", "LOVIE", "JEANE", "JAIMIE", "INGE", "FARRAH", "ELAINA", "CAITLYN", "STARR", "FELICITAS", "CHERLY", "CARYL", "YOLONDA", "YASMIN", "TEENA", "PRUDENCE", "PENNIE", "NYDIA", "MACKENZIE", "ORPHA", "MARVEL", "LIZBETH", "LAURETTE", "JERRIE", "HERMELINDA", "CAROLEE", "TIERRA", "MIRIAN", "META", "MELONY", "KORI", "JENNETTE", "JAMILA", "ENA", "ANH", "YOSHIKO", "SUSANNAH", "SALINA", "RHIANNON", "JOLEEN", "CRISTINE", "ASHTON", "ARACELY", "TOMEKA", "SHALONDA", "MARTI", "LACIE", "KALA", "JADA", "ILSE", "HAILEY", "BRITTANI", "ZONA", "SYBLE", "SHERRYL", "RANDY", "NIDIA", "MARLO", "KANDICE", "KANDI", "DEB", "DEAN", "AMERICA", "ALYCIA", "TOMMY", "RONNA", "NORENE", "MERCY", "JOSE", "INGEBORG", "GIOVANNA", "GEMMA", "CHRISTEL", "AUDRY", "ZORA", "VITA", "VAN", "TRISH", "STEPHAINE", "SHIRLEE", "SHANIKA", "MELONIE", "MAZIE", "JAZMIN", "INGA", "HOA", "HETTIE", "GERALYN", "FONDA", "ESTRELLA", "ADELLA", "SU", "SARITA", "RINA", "MILISSA", "MARIBETH", "GOLDA", "EVON", "ETHELYN", "ENEDINA", "CHERISE", "CHANA", "VELVA", "TAWANNA", "SADE", "MIRTA", "LI", "KARIE", "JACINTA", "ELNA", "DAVINA", "CIERRA", "ASHLIE", "ALBERTHA", "TANESHA", "STEPHANI", "NELLE", "MINDI", "LU", "LORINDA", "LARUE", "FLORENE", "DEMETRA", "DEDRA", "CIARA", "CHANTELLE", "ASHLY", "SUZY", "ROSALVA", "NOELIA", "LYDA", "LEATHA", "KRYSTYNA", "KRISTAN", "KARRI", "DARLINE", "DARCIE", "CINDA", "CHEYENNE", "CHERRIE", "AWILDA", "ALMEDA", "ROLANDA", "LANETTE", "JERILYN", "GISELE", "EVALYN", "CYNDI", "CLETA", "CARIN", "ZINA", "ZENA", "VELIA", "TANIKA", "PAUL", "CHARISSA", "THOMAS", "TALIA", "MARGARETE", "LAVONDA", "KAYLEE", "KATHLENE", "JONNA", "IRENA", "ILONA", "IDALIA", "CANDIS", "CANDANCE", "BRANDEE", "ANITRA", "ALIDA", "SIGRID", "NICOLETTE", "MARYJO", "LINETTE", "HEDWIG", "CHRISTIANA", "CASSIDY", "ALEXIA", "TRESSIE", "MODESTA", "LUPITA", "LITA", "GLADIS", "EVELIA", "DAVIDA", "CHERRI", "CECILY", "ASHELY", "ANNABEL", "AGUSTINA", "WANITA", "SHIRLY", "ROSAURA", "HULDA", "EUN", "BAILEY", "YETTA", "VERONA", "THOMASINA", "SIBYL", "SHANNAN", "MECHELLE", "LUE", "LEANDRA", "LANI", "KYLEE", "KANDY", "JOLYNN", "FERNE", "EBONI", "CORENE", "ALYSIA", "ZULA", "NADA", "MOIRA", "LYNDSAY", "LORRETTA", "JUAN", "JAMMIE", "HORTENSIA", "GAYNELL", "CAMERON", "ADRIA", "VINA", "VICENTA", "TANGELA", "STEPHINE", "NORINE", "NELLA", "LIANA", "LESLEE", "KIMBERELY", "ILIANA", "GLORY", "FELICA", "EMOGENE", "ELFRIEDE", "EDEN", "EARTHA", "CARMA", "BEA", "OCIE", "MARRY", "LENNIE", "KIARA", "JACALYN", "CARLOTA", "ARIELLE", "YU", "STAR", "OTILIA", "KIRSTIN", "KACEY", "JOHNETTA", "JOEY", "JOETTA", "JERALDINE", "JAUNITA", "ELANA", "DORTHEA", "CAMI", "AMADA", "ADELIA", "VERNITA", "TAMAR", "SIOBHAN", "RENEA", "RASHIDA", "OUIDA", "ODELL", "NILSA", "MERYL", "KRISTYN", "JULIETA", "DANICA", "BREANNE", "AUREA", "ANGLEA", "SHERRON", "ODETTE", "MALIA", "LORELEI", "LIN", "LEESA", "KENNA", "KATHLYN", "FIONA", "CHARLETTE", "SUZIE", "SHANTELL", "SABRA", "RACQUEL", "MYONG", "MIRA", "MARTINE", "LUCIENNE", "LAVADA", "JULIANN", "JOHNIE", "ELVERA", "DELPHIA", "CLAIR", "CHRISTIANE", "CHAROLETTE", "CARRI", "AUGUSTINE", "ASHA", "ANGELLA", "PAOLA", "NINFA", "LEDA", "LAI", "EDA", "SUNSHINE", "STEFANI", "SHANELL", "PALMA", "MACHELLE", "LISSA", "KECIA", "KATHRYNE", "KARLENE", "JULISSA", "JETTIE", "JENNIFFER", "HUI", "CORRINA", "CHRISTOPHER", "CAROLANN", "ALENA", "TESS", "ROSARIA", "MYRTICE", "MARYLEE", "LIANE", "KENYATTA", "JUDIE", "JANEY", "IN", "ELMIRA", "ELDORA", "DENNA", "CRISTI", "CATHI", "ZAIDA", "VONNIE", "VIVA", "VERNIE", "ROSALINE", "MARIELA", "LUCIANA", "LESLI", "KARAN", "FELICE", "DENEEN", "ADINA", "WYNONA", "TARSHA", "SHERON", "SHASTA", "SHANITA", "SHANI", "SHANDRA", "RANDA", "PINKIE", "PARIS", "NELIDA", "MARILOU", "LYLA", "LAURENE", "LACI", "JOI", "JANENE", "DOROTHA", "DANIELE", "DANI", "CAROLYNN", "CARLYN", "BERENICE", "AYESHA", "ANNELIESE", "ALETHEA", "THERSA", "TAMIKO", "RUFINA", "OLIVA", "MOZELL", "MARYLYN", "MADISON", "KRISTIAN", "KATHYRN", "KASANDRA", "KANDACE", "JANAE", "GABRIEL", "DOMENICA", "DEBBRA", "DANNIELLE", "CHUN", "BUFFY", "BARBIE", "ARCELIA", "AJA", "ZENOBIA", "SHAREN", "SHAREE", "PATRICK", "PAGE", "MY", "LAVINIA", "KUM", "KACIE", "JACKELINE", "HUONG", "FELISA", "EMELIA", "ELEANORA", "CYTHIA", "CRISTIN", "CLYDE", "CLARIBEL", "CARON", "ANASTACIA", "ZULMA", "ZANDRA", "YOKO", "TENISHA", "SUSANN", "SHERILYN", "SHAY", "SHAWANDA", "SABINE", "ROMANA", "MATHILDA", "LINSEY", "KEIKO", "JOANA", "ISELA", "GRETTA", "GEORGETTA", "EUGENIE", "DUSTY", "DESIRAE", "DELORA", "CORAZON", "ANTONINA", "ANIKA", "WILLENE", "TRACEE", "TAMATHA", "REGAN", "NICHELLE", "MICKIE", "MAEGAN", "LUANA", "LANITA", "KELSIE", "EDELMIRA", "BREE", "AFTON", "TEODORA", "TAMIE", "SHENA", "MEG", "LINH", "KELI", "KACI", "DANYELLE", "BRITT", "ARLETTE", "ALBERTINE", "ADELLE", "TIFFINY", "STORMY", "SIMONA", "NUMBERS", "NICOLASA", "NICHOL", "NIA", "NAKISHA", "MEE", "MAIRA", "LOREEN", "KIZZY", "JOHNNY", "JAY", "FALLON", "CHRISTENE", "BOBBYE", "ANTHONY", "YING", "VINCENZA", "TANJA", "RUBIE", "RONI", "QUEENIE", "MARGARETT", "KIMBERLI", "IRMGARD", "IDELL", "HILMA", "EVELINA", "ESTA", "EMILEE", "DENNISE", "DANIA", "CARL", "CARIE", "ANTONIO", "WAI", "SANG", "RISA", "RIKKI", "PARTICIA", "MUI", "MASAKO", "MARIO", "LUVENIA", "LOREE", "LONI", "LIEN", "KEVIN", "GIGI", "FLORENCIA", "DORIAN", "DENITA", "DALLAS", "CHI", "BILLYE", "ALEXANDER", "TOMIKA", "SHARITA", "RANA", "NIKOLE", "NEOMA", "MARGARITE", "MADALYN", "LUCINA", "LAILA", "KALI", "JENETTE", "GABRIELE", "EVELYNE", "ELENORA", "CLEMENTINA", "ALEJANDRINA", "ZULEMA", "VIOLETTE", "VANNESSA", "THRESA", "RETTA", "PIA", "PATIENCE", "NOELLA", "NICKIE", "JONELL", "DELTA", "CHUNG", "CHAYA", "CAMELIA", "BETHEL", "ANYA", "ANDREW", "THANH", "SUZANN", "SPRING", "SHU", "MILA", "LILLA", "LAVERNA", "KEESHA", "KATTIE", "GIA", "GEORGENE", "EVELINE", "ESTELL", "ELIZBETH", "VIVIENNE", "VALLIE", "TRUDIE", "STEPHANE", "MICHEL", "MAGALY", "MADIE", "KENYETTA", "KARREN", "JANETTA", "HERMINE", "HARMONY", "DRUCILLA", "DEBBI", "CELESTINA", "CANDIE", "BRITNI", "BECKIE", "AMINA", "ZITA", "YUN", "YOLANDE", "VIVIEN", "VERNETTA", "TRUDI", "SOMMER", "PEARLE", "PATRINA", "OSSIE", "NICOLLE", "LOYCE", "LETTY", "LARISA", "KATHARINA", "JOSELYN", "JONELLE", "JENELL", "IESHA", "HEIDE", "FLORINDA", "FLORENTINA", "FLO", "ELODIA", "DORINE", "BRUNILDA", "BRIGID", "ASHLI", "ARDELLA", "TWANA", "THU", "TARAH", "SUNG", "SHEA", "SHAVON", "SHANE", "SERINA", "RAYNA", "RAMONITA", "NGA", "MARGURITE", "LUCRECIA", "KOURTNEY", "KATI", "JESUS", "JESENIA", "DIAMOND", "CRISTA", "AYANA", "ALICA", "ALIA", "VINNIE", "SUELLEN", "ROMELIA", "RACHELL", "PIPER", "OLYMPIA", "MICHIKO", "KATHALEEN", "JOLIE", "JESSI", "JANESSA", "HANA", "HA", "ELEASE", "CARLETTA", "BRITANY", "SHONA", "SALOME", "ROSAMOND", "REGENA", "RAINA", "NGOC", "NELIA", "LOUVENIA", "LESIA", "LATRINA", "LATICIA", "LARHONDA", "JINA", "JACKI", "HOLLIS", "HOLLEY", "EMMY", "DEEANN", "CORETTA", "ARNETTA", "VELVET", "THALIA", "SHANICE", "NETA", "MIKKI", "MICKI", "LONNA", "LEANA", "LASHUNDA", "KILEY", "JOYE", "JACQULYN", "IGNACIA", "HYUN", "HIROKO", "HENRY", "HENRIETTE", "ELAYNE", "DELINDA", "DARNELL", "DAHLIA", "COREEN", "CONSUELA", "CONCHITA", "CELINE", "BABETTE", "AYANNA", "ANETTE", "ALBERTINA", "SKYE", "SHAWNEE", "SHANEKA", "QUIANA", "PAMELIA", "MIN", "MERRI", "MERLENE", "MARGIT", "KIESHA", "KIERA", "KAYLENE", "JODEE", "JENISE", "ERLENE", "EMMIE", "ELSE", "DARYL", "DALILA", "DAISEY", "CODY", "CASIE", "BELIA", "BABARA", "VERSIE", "VANESA", "SHELBA", "SHAWNDA", "SAM", "NORMAN", "NIKIA", "NAOMA", "MARNA", "MARGERET", "MADALINE", "LAWANA", "KINDRA", "JUTTA", "JAZMINE", "JANETT", "HANNELORE", "GLENDORA", "GERTRUD", "GARNETT", "FREEDA", "FREDERICA", "FLORANCE", "FLAVIA", "DENNIS", "CARLINE", "BEVERLEE", "ANJANETTE", "VALDA", "TRINITY", "TAMALA", "STEVIE", "SHONNA", "SHA", "SARINA", "ONEIDA", "MICAH", "MERILYN", "MARLEEN", "LURLINE", "LENNA", "KATHERIN", "JIN", "JENI", "HAE", "GRACIA", "GLADY", "FARAH", "ERIC", "ENOLA", "EMA", "DOMINQUE", "DEVONA", "DELANA", "CECILA", "CAPRICE", "ALYSHA", "ALI", "ALETHIA", "VENA", "THERESIA", "TAWNY", "SONG", "SHAKIRA", "SAMARA", "SACHIKO", "RACHELE", "PAMELLA", "NICKY", "MARNI", "MARIEL", "MAREN", "MALISA", "LIGIA", "LERA", "LATORIA", "LARAE", "KIMBER", "KATHERN", "KAREY", "JENNEFER", "JANETH", "HALINA", "FREDIA", "DELISA", "DEBROAH", "CIERA", "CHIN", "ANGELIKA", "ANDREE", "ALTHA", "YEN", "VIVAN", "TERRESA", "TANNA", "SUK", "SUDIE", "SOO", "SIGNE", "SALENA", "RONNI", "REBBECCA", "MYRTIE", "MCKENZIE", "MALIKA", "MAIDA", "LOAN", "LEONARDA", "KAYLEIGH", "FRANCE", "ETHYL", "ELLYN", "DAYLE", "CAMMIE", "BRITTNI", "BIRGIT", "AVELINA", "ASUNCION", "ARIANNA", "AKIKO", "VENICE", "TYESHA", "TONIE", "TIESHA", "TAKISHA", "STEFFANIE", "SINDY", "SANTANA", "MEGHANN", "MANDA", "MACIE", "LADY", "KELLYE", "KELLEE", "JOSLYN", "JASON", "INGER", "INDIRA", "GLINDA", "GLENNIS", "FERNANDA", "FAUSTINA", "ENEIDA", "ELICIA", "DOT", "DIGNA", "DELL", "ARLETTA", "ANDRE", "WILLIA", "TAMMARA", "TABETHA", "SHERRELL", "SARI", "REFUGIO", "REBBECA", "PAULETTA", "NIEVES", "NATOSHA", "NAKITA", "MAMMIE", "KENISHA", "KAZUKO", "KASSIE", "GARY", "EARLEAN", "DAPHINE", "CORLISS", "CLOTILDE", "CAROLYNE", "BERNETTA", "AUGUSTINA", "AUDREA", "ANNIS", "ANNABELL", "YAN", "TENNILLE", "TAMICA", "SELENE", "SEAN", "ROSANA", "REGENIA", "QIANA", "MARKITA", "MACY", "LEEANNE", "LAURINE", "KYM", "JESSENIA", "JANITA", "GEORGINE", "GENIE", "EMIKO", "ELVIE", "DEANDRA", "DAGMAR", "CORIE", "COLLEN", "CHERISH", "ROMAINE", "PORSHA", "PEARLENE", "MICHELINE", "MERNA", "MARGORIE", "MARGARETTA", "LORE", "KENNETH", "JENINE", "HERMINA", "FREDERICKA", "ELKE", "DRUSILLA", "DORATHY", "DIONE", "DESIRE", "CELENA", "BRIGIDA", "ANGELES", "ALLEGRA", "THEO", "TAMEKIA", "SYNTHIA", "STEPHEN", "SOOK", "SLYVIA", "ROSANN", "REATHA", "RAYE", "MARQUETTA", "MARGART", "LING", "LAYLA", "KYMBERLY", "KIANA", "KAYLEEN", "KATLYN", "KARMEN", "JOELLA", "IRINA", "EMELDA", "ELENI", "DETRA", "CLEMMIE", "CHERYLL", "CHANTELL", "CATHEY", "ARNITA", "ARLA", "ANGLE", "ANGELIC", "ALYSE", "ZOFIA", "THOMASINE", "TENNIE", "SON", "SHERLY", "SHERLEY", "SHARYL", "REMEDIOS", "PETRINA", "NICKOLE", "MYUNG", "MYRLE", "MOZELLA", "LOUANNE", "LISHA", "LATIA", "LANE", "KRYSTA", "JULIENNE", "JOEL", "JEANENE", "JACQUALINE", "ISAURA", "GWENDA", "EARLEEN", "DONALD", "CLEOPATRA", "CARLIE", "AUDIE", "ANTONIETTA", "ALISE", "ALEX", "VERDELL", "VAL", "TYLER", "TOMOKO", "THAO", "TALISHA", "STEVEN", "SO", "SHEMIKA", "SHAUN", "SCARLET", "SAVANNA", "SANTINA", "ROSIA", "RAEANN", "ODILIA", "NANA", "MINNA", "MAGAN", "LYNELLE", "LE", "KARMA", "JOEANN", "IVANA", "INELL", "ILANA", "HYE", "HONEY", "HEE", "GUDRUN", "FRANK", "DREAMA", "CRISSY", "CHANTE", "CARMELINA", "ARVILLA", "ARTHUR", "ANNAMAE", "ALVERA", "ALEIDA", "AARON", "YEE", "YANIRA", "VANDA", "TIANNA", "TAM", "STEFANIA", "SHIRA", "PERRY", "NICOL", "NANCIE", "MONSERRATE", "MINH", "MELYNDA", "MELANY", "MATTHEW", "LOVELLA", "LAURE", "KIRBY", "KACY", "JACQUELYNN", "HYON", "GERTHA", "FRANCISCO", "ELIANA", "CHRISTENA", "CHRISTEEN", "CHARISE", "CATERINA", "CARLEY", "CANDYCE", "ARLENA", "AMMIE", "YANG", "WILLETTE", "VANITA", "TUYET", "TINY", "SYREETA", "SILVA", "SCOTT", "RONALD", "PENNEY", "NYLA", "MICHAL", "MAURICE", "MARYAM", "MARYA", "MAGEN", "LUDIE", "LOMA", "LIVIA", "LANELL", "KIMBERLIE", "JULEE", "DONETTA", "DIEDRA", "DENISHA", "DEANE", "DAWNE", "CLARINE", "CHERRYL", "BRONWYN", "BRANDON", "ALLA", "VALERY", "TONDA", "SUEANN", "SORAYA", "SHOSHANA", "SHELA", "SHARLEEN", "SHANELLE", "NERISSA", "MICHEAL", "MERIDITH", "MELLIE", "MAYE", "MAPLE", "MAGARET", "LUIS", "LILI", "LEONILA", "LEONIE", "LEEANNA", "LAVONIA", "LAVERA", "KRISTEL", "KATHEY", "KATHE", "JUSTIN", "JULIAN", "JIMMY", "JANN", "ILDA", "HILDRED", "HILDEGARDE", "GENIA", "FUMIKO", "EVELIN", "ERMELINDA", "ELLY", "DUNG", "DOLORIS", "DIONNA", "DANAE", "BERNEICE", "ANNICE", "ALIX", "VERENA", "VERDIE", "TRISTAN", "SHAWNNA", "SHAWANA", "SHAUNNA", "ROZELLA", "RANDEE", "RANAE", "MILAGRO", "LYNELL", "LUISE", "LOUIE", "LOIDA", "LISBETH", "KARLEEN", "JUNITA", "JONA", "ISIS", "HYACINTH", "HEDY", "GWENN", "ETHELENE", "ERLINE", "EDWARD", "DONYA", "DOMONIQUE", "DELICIA", "DANNETTE", "CICELY", "BRANDA", "BLYTHE", "BETHANN", "ASHLYN", "ANNALEE", "ALLINE", "YUKO", "VELLA", "TRANG", "TOWANDA", "TESHA", "SHERLYN", "NARCISA", "MIGUELINA", "MERI", "MAYBELL", "MARLANA", "MARGUERITA", "MADLYN", "LUNA", "LORY", "LORIANN", "LIBERTY", "LEONORE", "LEIGHANN", "LAURICE", "LATESHA", "LARONDA", "KATRICE", "KASIE", "KARL", "KALEY", "JADWIGA", "GLENNIE", "GEARLDINE", "FRANCINA", "EPIFANIA", "DYAN", "DORIE", "DIEDRE", "DENESE", "DEMETRICE", "DELENA", "DARBY", "CRISTIE", "CLEORA", "CATARINA", "CARISA", "BERNIE", "BARBERA", "ALMETA", "TRULA", "TEREASA", "SOLANGE", "SHEILAH", "SHAVONNE", "SANORA", "ROCHELL", "MATHILDE", "MARGARETA", "MAIA", "LYNSEY", "LAWANNA", "LAUNA", "KENA", "KEENA", "KATIA", "JAMEY", "GLYNDA", "GAYLENE", "ELVINA", "ELANOR", "DANUTA", "DANIKA", "CRISTEN", "CORDIE", "COLETTA", "CLARITA", "CARMON", "BRYNN", "AZUCENA", "AUNDREA", "ANGELE", "YI", "WALTER", "VERLIE", "VERLENE", "TAMESHA", "SILVANA", "SEBRINA", "SAMIRA", "REDA", "RAYLENE", "PENNI", "PANDORA", "NORAH", "NOMA", "MIREILLE", "MELISSIA", "MARYALICE", "LARAINE", "KIMBERY", "KARYL", "KARINE", "KAM", "JOLANDA", "JOHANA", "JESUSA", "JALEESA", "JAE", "JACQUELYNE", "IRISH", "ILUMINADA", "HILARIA", "HANH", "GENNIE", "FRANCIE", "FLORETTA", "EXIE", "EDDA", "DREMA", "DELPHA", "BEV", "BARBAR", "ASSUNTA", "ARDELL", "ANNALISA", "ALISIA", "YUKIKO", "YOLANDO", "WONDA", "WEI", "WALTRAUD", "VETA", "TEQUILA", "TEMEKA", "TAMEIKA", "SHIRLEEN", "SHENITA", "PIEDAD", "OZELLA", "MIRTHA", "MARILU", "KIMIKO", "JULIANE", "JENICE", "JEN", "JANAY", "JACQUILINE", "HILDE", "FE", "FAE", "EVAN", "EUGENE", "ELOIS", "ECHO", "DEVORAH", "CHAU", "BRINDA", "BETSEY", "ARMINDA", "ARACELIS", "APRYL", "ANNETT", "ALISHIA", "VEOLA", "USHA", "TOSHIKO", "THEOLA", "TASHIA", "TALITHA", "SHERY", "RUDY", "RENETTA", "REIKO", "RASHEEDA", "OMEGA", "OBDULIA", "MIKA", "MELAINE", "MEGGAN", "MARTIN", "MARLEN", "MARGET", "MARCELINE", "MANA", "MAGDALEN", "LIBRADA", "LEZLIE", "LEXIE", "LATASHIA", "LASANDRA", "KELLE", "ISIDRA", "ISA", "INOCENCIA", "GWYN", "FRANCOISE", "ERMINIA", "ERINN", "DIMPLE", "DEVORA", "CRISELDA", "ARMANDA", "ARIE", "ARIANE", "ANGELO", "ANGELENA", "ALLEN", "ALIZA", "ADRIENE", "ADALINE", "XOCHITL", "TWANNA", "TRAN", "TOMIKO", "TAMISHA", "TAISHA", "SUSY", "SIU", "RUTHA", "ROXY", "RHONA", "RAYMOND", "OTHA", "NORIKO", "NATASHIA", "MERRIE", "MELVIN", "MARINDA", "MARIKO", "MARGERT", "LORIS", "LIZZETTE", "LEISHA", "KAILA", "KA", "JOANNIE", "JERRICA", "JENE", "JANNET", "JANEE", "JACINDA", "HERTA", "ELENORE", "DORETTA", "DELAINE", "DANIELL", "CLAUDIE", "CHINA", "BRITTA", "APOLONIA", "AMBERLY", "ALEASE", "YURI", "YUK", "WEN", "WANETA", "UTE", "TOMI", "SHARRI", "SANDIE", "ROSELLE", "REYNALDA", "RAGUEL", "PHYLICIA", "PATRIA", "OLIMPIA", "ODELIA", "MITZIE", "MITCHELL", "MISS", "MINDA", "MIGNON", "MICA", "MENDY", "MARIVEL", "MAILE", "LYNETTA", "LAVETTE", "LAURYN", "LATRISHA", "LAKIESHA", "KIERSTEN", "KARY", "JOSPHINE", "JOLYN", "JETTA", "JANISE", "JACQUIE", "IVELISSE", "GLYNIS", "GIANNA", "GAYNELLE", "EMERALD", "DEMETRIUS", "DANYELL", "DANILLE", "DACIA", "CORALEE", "CHER", "CEOLA", "BRETT", "BELL", "ARIANNE", "ALESHIA", "YUNG", "WILLIEMAE", "TROY", "TRINH", "THORA", "TAI", "SVETLANA", "SHERIKA", "SHEMEKA", "SHAUNDA", "ROSELINE", "RICKI", "MELDA", "MALLIE", "LAVONNA", "LATINA", "LARRY", "LAQUANDA", "LALA", "LACHELLE", "KLARA", "KANDIS", "JOHNA", "JEANMARIE", "JAYE", "HANG", "GRAYCE", "GERTUDE", "EMERITA", "EBONIE", "CLORINDA", "CHING", "CHERY", "CAROLA", "BREANN", "BLOSSOM", "BERNARDINE", "BECKI", "ARLETHA", "ARGELIA", "ARA", "ALITA", "YULANDA", "YON", "YESSENIA", "TOBI", "TASIA", "SYLVIE", "SHIRL", "SHIRELY", "SHERIDAN", "SHELLA", "SHANTELLE", "SACHA", "ROYCE", "REBECKA", "REAGAN", "PROVIDENCIA", "PAULENE", "MISHA", "MIKI", "MARLINE", "MARICA", "LORITA", "LATOYIA", "LASONYA", "KERSTIN", "KENDA", "KEITHA", "KATHRIN", "JAYMIE", "JACK", "GRICELDA", "GINETTE", "ERYN", "ELINA", "ELFRIEDA", "DANYEL", "CHEREE", "CHANELLE", "BARRIE", "AVERY", "AURORE", "ANNAMARIA", "ALLEEN", "AILENE", "AIDE", "YASMINE", "VASHTI", "VALENTINE", "TREASA", "TORY", "TIFFANEY", "SHERYLL", "SHARIE", "SHANAE", "SAU", "RAISA", "PA", "NEDA", "MITSUKO", "MIRELLA", "MILDA", "MARYANNA", "MARAGRET", "MABELLE", "LUETTA", "LORINA", "LETISHA", "LATARSHA", "LANELLE", "LAJUANA", "KRISSY", "KARLY", "KARENA", "JON", "JESSIKA", "JERICA", "JEANELLE", "JANUARY", "JALISA", "JACELYN", "IZOLA", "IVEY", "GREGORY", "EUNA", "ETHA", "DREW", "DOMITILA", "DOMINICA", "DAINA", "CREOLA", "CARLI", "CAMIE", "BUNNY", "BRITTNY", "ASHANTI", "ANISHA", "ALEEN", "ADAH", "YASUKO", "WINTER", "VIKI", "VALRIE", "TONA", "TINISHA", "THI", "TERISA", "TATUM", "TANEKA", "SIMONNE", "SHALANDA", "SERITA", "RESSIE", "REFUGIA", "PAZ", "OLENE", "NA", "MERRILL", "MARGHERITA", "MANDIE", "MAN", "MAIRE", "LYNDIA", "LUCI", "LORRIANE", "LORETA", "LEONIA", "LAVONA", "LASHAWNDA", "LAKIA", "KYOKO", "KRYSTINA", "KRYSTEN", "KENIA", "KELSI", "JUDE", "JEANICE", "ISOBEL", "GEORGIANN", "GENNY", "FELICIDAD", "EILENE", "DEON", "DELOISE", "DEEDEE", "DANNIE", "CONCEPTION", "CLORA", "CHERILYN", "CHANG", "CALANDRA", "BERRY", "ARMANDINA", "ANISA", "ULA", "TIMOTHY", "TIERA", "THERESSA", "STEPHANIA", "SIMA", "SHYLA", "SHONTA", "SHERA", "SHAQUITA", "SHALA", "SAMMY", "ROSSANA", "NOHEMI", "NERY", "MORIAH", "MELITA", "MELIDA", "MELANI", "MARYLYNN", "MARISHA", "MARIETTE", "MALORIE", "MADELENE", "LUDIVINA", "LORIA", "LORETTE", "LORALEE", "LIANNE", "LEON", "LAVENIA", "LAURINDA", "LASHON", "KIT", "KIMI", "KEILA", "KATELYNN", "KAI", "JONE", "JOANE", "JI", "JAYNA", "JANELLA", "JA", "HUE", "HERTHA", "FRANCENE", "ELINORE", "DESPINA", "DELSIE", "DEEDRA", "CLEMENCIA", "CARRY", "CAROLIN", "CARLOS", "BULAH", "BRITTANIE", "BOK", "BLONDELL", "BIBI", "BEAULAH", "BEATA", "ANNITA", "AGRIPINA", "VIRGEN", "VALENE", "UN", "TWANDA", "TOMMYE", "TOI", "TARRA", "TARI", "TAMMERA", "SHAKIA", "SADYE", "RUTHANNE", "ROCHEL", "RIVKA", "PURA", "NENITA", "NATISHA", "MING", "MERRILEE", "MELODEE", "MARVIS", "LUCILLA", "LEENA", "LAVETA", "LARITA", "LANIE", "KEREN", "ILEEN", "GEORGEANN", "GENNA", "GENESIS", "FRIDA", "EWA", "EUFEMIA", "EMELY", "ELA", "EDYTH", "DEONNA", "DEADRA", "DARLENA", "CHANELL", "CHAN", "CATHERN", "CASSONDRA", "CASSAUNDRA", "BERNARDA", "BERNA", "ARLINDA", "ANAMARIA", "ALBERT", "WESLEY", "VERTIE", "VALERI", "TORRI", "TATYANA", "STASIA", "SHERISE", "SHERILL", "SEASON", "SCOTTIE", "SANDA", "RUTHE", "ROSY", "ROBERTO", "ROBBI", "RANEE", "QUYEN", "PEARLY", "PALMIRA", "ONITA", "NISHA", "NIESHA", "NIDA", "NEVADA", "NAM", "MERLYN", "MAYOLA", "MARYLOUISE", "MARYLAND", "MARX", "MARTH", "MARGENE", "MADELAINE", "LONDA", "LEONTINE", "LEOMA", "LEIA", "LAWRENCE", "LAURALEE", "LANORA", "LAKITA", "KIYOKO", "KETURAH", "KATELIN", "KAREEN", "JONIE", "JOHNETTE", "JENEE", "JEANETT", "IZETTA", "HIEDI", "HEIKE", "HASSIE", "HAROLD", "GIUSEPPINA", "GEORGANN", "FIDELA", "FERNANDE", "ELWANDA", "ELLAMAE", "ELIZ", "DUSTI", "DOTTY", "CYNDY", "CORALIE", "CELESTA", "ARGENTINA", "ALVERTA", "XENIA", "WAVA", "VANETTA", "TORRIE", "TASHINA", "TANDY", "TAMBRA", "TAMA", "STEPANIE", "SHILA", "SHAUNTA", "SHARAN", "SHANIQUA", "SHAE", "SETSUKO", "SERAFINA", "SANDEE", "ROSAMARIA", "PRISCILA", "OLINDA", "NADENE", "MUOI", "MICHELINA", "MERCEDEZ", "MARYROSE", "MARIN", "MARCENE", "MAO", "MAGALI", "MAFALDA", "LOGAN", "LINN", "LANNIE", "KAYCE", "KAROLINE", "KAMILAH", "KAMALA", "JUSTA", "JOLINE", "JENNINE", "JACQUETTA", "IRAIDA", "GERALD", "GEORGEANNA", "FRANCHESCA", "FAIRY", "EMELINE", "ELANE", "EHTEL", "EARLIE", "DULCIE", "DALENE", "CRIS", "CLASSIE", "CHERE", "CHARIS", "CAROYLN", "CARMINA", "CARITA", "BRIAN", "BETHANIE", "AYAKO", "ARICA", "AN", "ALYSA", "ALESSANDRA", "AKILAH", "ADRIEN", "ZETTA", "YOULANDA", "YELENA", "YAHAIRA", "XUAN", "WENDOLYN", "VICTOR", "TIJUANA", "TERRELL", "TERINA", "TERESIA", "SUZI", "SUNDAY", "SHERELL", "SHAVONDA", "SHAUNTE", "SHARDA", "SHAKITA", "SENA", "RYANN", "RUBI", "RIVA", "REGINIA", "REA", "RACHAL", "PARTHENIA", "PAMULA", "MONNIE", "MONET", "MICHAELE", "MELIA", "MARINE", "MALKA", "MAISHA", "LISANDRA", "LEO", "LEKISHA", "LEAN", "LAURENCE", "LAKENDRA", "KRYSTIN", "KORTNEY", "KIZZIE", "KITTIE", "KERA", "KENDAL", "KEMBERLY", "KANISHA", "JULENE", "JULE", "JOSHUA", "JOHANNE", "JEFFREY", "JAMEE", "HAN", "HALLEY", "GIDGET", "GALINA", "FREDRICKA", "FLETA", "FATIMAH", "EUSEBIA", "ELZA", "ELEONORE", "DORTHEY", "DORIA", "DONELLA", "DINORAH", "DELORSE", "CLARETHA", "CHRISTINIA", "CHARLYN", "BONG", "BELKIS", "AZZIE", "ANDERA", "AIKO", "ADENA", "YER", "YAJAIRA", "WAN", "VANIA", "ULRIKE", "TOSHIA", "TIFANY", "STEFANY", "SHIZUE", "SHENIKA", "SHAWANNA", "SHAROLYN", "SHARILYN", "SHAQUANA", "SHANTAY", "SEE", "ROZANNE", "ROSELEE", "RICKIE", "REMONA", "REANNA", "RAELENE", "QUINN", "PHUNG", "PETRONILA", "NATACHA", "NANCEY", "MYRL", "MIYOKO", "MIESHA", "MERIDETH", "MARVELLA", "MARQUITTA", "MARHTA", "MARCHELLE", "LIZETH", "LIBBIE", "LAHOMA", "LADAWN", "KINA", "KATHELEEN", "KATHARYN", "KARISA", "KALEIGH", "JUNIE", "JULIEANN", "JOHNSIE", "JANEAN", "JAIMEE", "JACKQUELINE", "HISAKO", "HERMA", "HELAINE", "GWYNETH", "GLENN", "GITA", "EUSTOLIA", "EMELINA", "ELIN", "EDRIS", "DONNETTE", "DONNETTA", "DIERDRE", "DENAE", "DARCEL", "CLAUDE", "CLARISA", "CINDERELLA", "CHIA", "CHARLESETTA", "CHARITA", "CELSA", "CASSY", "CASSI", "CARLEE", "BRUNA", "BRITTANEY", "BRANDE", "BILLI", "BAO", "ANTONETTA", "ANGLA", "ANGELYN", "ANALISA", "ALANE", "WENONA", "WENDIE", "VERONIQUE", "VANNESA", "TOBIE", "TEMPIE", "SUMIKO", "SULEMA", "SPARKLE", "SOMER", "SHEBA", "SHAYNE", "SHARICE", "SHANEL", "SHALON", "SAGE", "ROY", "ROSIO", "ROSELIA", "RENAY", "REMA", "REENA", "PORSCHE", "PING", "PEG", "OZIE", "ORETHA", "ORALEE", "ODA", "NU", "NGAN", "NAKESHA", "MILLY", "MARYBELLE", "MARLIN", "MARIS", "MARGRETT", "MARAGARET", "MANIE", "LURLENE", "LILLIA", "LIESELOTTE", "LAVELLE", "LASHAUNDA", "LAKEESHA", "KEITH", "KAYCEE", "KALYN", "JOYA", "JOETTE", "JENAE", "JANIECE", "ILLA", "GRISEL", "GLAYDS", "GENEVIE", "GALA", "FREDDA", "FRED", "ELMER", "ELEONOR", "DEBERA", "DEANDREA", "DAN", "CORRINNE", "CORDIA", "CONTESSA", "COLENE", "CLEOTILDE", "CHARLOTT", "CHANTAY", "CECILLE", "BEATRIS", "AZALEE", "ARLEAN", "ARDATH", "ANJELICA", "ANJA", "ALFREDIA", "ALEISHA", "ADAM", "ZADA", "YUONNE", "XIAO", "WILLODEAN", "WHITLEY", "VENNIE", "VANNA", "TYISHA", "TOVA", "TORIE", "TONISHA", "TILDA", "TIEN", "TEMPLE", "SIRENA", "SHERRIL", "SHANTI", "SHAN", "SENAIDA", "SAMELLA", "ROBBYN", "RENDA", "REITA", "PHEBE", "PAULITA", "NOBUKO", "NGUYET", "NEOMI", "MOON", "MIKAELA", "MELANIA", "MAXIMINA", "MARG", "MAISIE", "LYNNA", "LILLI", "LAYNE", "LASHAUN", "LAKENYA", "LAEL", "KIRSTIE", "KATHLINE", "KASHA", "KARLYN", "KARIMA", "JOVAN", "JOSEFINE", "JENNELL", "JACQUI", "JACKELYN", "HYO", "HIEN", "GRAZYNA", "FLORRIE", "FLORIA", "ELEONORA", "DWANA", "DORLA", "DONG", "DELMY", "DEJA", "DEDE", "DANN", "CRYSTA", "CLELIA", "CLARIS", "CLARENCE", "CHIEKO", "CHERLYN", "CHERELLE", "CHARMAIN", "CHARA", "CAMMY", "BEE", "ARNETTE", "ARDELLE", "ANNIKA", "AMIEE", "AMEE", "ALLENA", "YVONE", "YUKI", "YOSHIE", "YEVETTE", "YAEL", "WILLETTA", "VONCILE", "VENETTA", "TULA", "TONETTE", "TIMIKA", "TEMIKA", "TELMA", "TEISHA", "TAREN", "TA", "STACEE", "SHIN", "SHAWNTA", "SATURNINA", "RICARDA", "POK", "PASTY", "ONIE", "NUBIA", "MORA", "MIKE", "MARIELLE", "MARIELLA", "MARIANELA", "MARDELL", "MANY", "LUANNA", "LOISE", "LISABETH", "LINDSY", "LILLIANA", "LILLIAM", "LELAH", "LEIGHA", "LEANORA", "LANG", "KRISTEEN", "KHALILAH", "KEELEY", "KANDRA", "JUNKO", "JOAQUINA", "JERLENE", "JANI", "JAMIKA", "JAME", "HSIU", "HERMILA", "GOLDEN", "GENEVIVE", "EVIA", "EUGENA", "EMMALINE", "ELFREDA", "ELENE", "DONETTE", "DELCIE", "DEEANNA", "DARCEY", "CUC", "CLARINDA", "CIRA", "CHAE", "CELINDA", "CATHERYN", "CATHERIN", "CASIMIRA", "CARMELIA", "CAMELLIA", "BREANA", "BOBETTE", "BERNARDINA", "BEBE", "BASILIA", "ARLYNE", "AMAL", "ALAYNA", "ZONIA", "ZENIA", "YURIKO", "YAEKO", "WYNELL", "WILLOW", "WILLENA", "VERNIA", "TU", "TRAVIS", "TORA", "TERRILYN", "TERICA", "TENESHA", "TAWNA", "TAJUANA", "TAINA", "STEPHNIE", "SONA", "SOL", "SINA", "SHONDRA", "SHIZUKO", "SHERLENE", "SHERICE", "SHARIKA", "ROSSIE", "ROSENA", "RORY", "RIMA", "RIA", "RHEBA", "RENNA", "PETER", "NATALYA", "NANCEE", "MELODI", "MEDA", "MAXIMA", "MATHA", "MARKETTA", "MARICRUZ", "MARCELENE", "MALVINA", "LUBA", "LOUETTA", "LEIDA", "LECIA", "LAURAN", "LASHAWNA", "LAINE", "KHADIJAH", "KATERINE", "KASI", "KALLIE", "JULIETTA", "JESUSITA", "JESTINE", "JESSIA", "JEREMY", "JEFFIE", "JANYCE", "ISADORA", "GEORGIANNE", "FIDELIA", "EVITA", "EURA", "EULAH", "ESTEFANA", "ELSY", "ELIZABET", "ELADIA", "DODIE", "DION", "DIA", "DENISSE", "DELORAS", "DELILA", "DAYSI", "DAKOTA", "CURTIS", "CRYSTLE", "CONCHA", "COLBY", "CLARETTA", "CHU", "CHRISTIA", "CHARLSIE", "CHARLENA", "CARYLON", "BETTYANN", "ASLEY", "ASHLEA", "AMIRA", "AI", "AGUEDA", "AGNUS", "YUETTE", "VINITA", "VICTORINA", "TYNISHA", "TREENA", "TOCCARA", "TISH", "THOMASENA", "TEGAN", "SOILA", "SHILOH", "SHENNA", "SHARMAINE", "SHANTAE", "SHANDI", "SEPTEMBER", "SARAN", "SARAI", "SANA", "SAMUEL", "SALLEY", "ROSETTE", "ROLANDE", "REGINE", "OTELIA", "OSCAR", "OLEVIA", "NICHOLLE", "NECOLE", "NAIDA", "MYRTA", "MYESHA", "MITSUE", "MINTA", "MERTIE", "MARGY", "MAHALIA", "MADALENE", "LOVE", "LOURA", "LOREAN", "LEWIS", "LESHA", "LEONIDA", "LENITA", "LAVONE", "LASHELL", "LASHANDRA", "LAMONICA", "KIMBRA", "KATHERINA", "KARRY", "KANESHA", "JULIO", "JONG", "JENEVA", "JAQUELYN", "HWA", "GILMA", "GHISLAINE", "GERTRUDIS", "FRANSISCA", "FERMINA", "ETTIE", "ETSUKO", "ELLIS", "ELLAN", "ELIDIA", "EDRA", "DORETHEA", "DOREATHA", "DENYSE", "DENNY", "DEETTA", "DAINE", "CYRSTAL", "CORRIN", "CAYLA", "CARLITA", "CAMILA", "BURMA", "BULA", "BUENA", "BLAKE", "BARABARA", "AVRIL", "AUSTIN", "ALAINE", "ZANA", "WILHEMINA", "WANETTA", "VIRGIL", "VI", "VERONIKA", "VERNON", "VERLINE", "VASILIKI", "TONITA", "TISA", "TEOFILA", "TAYNA", "TAUNYA", "TANDRA", "TAKAKO", "SUNNI", "SUANNE", "SIXTA", "SHARELL", "SEEMA", "RUSSELL", "ROSENDA", "ROBENA", "RAYMONDE", "PEI", "PAMILA", "OZELL", "NEIDA", "NEELY", "MISTIE", "MICHA", "MERISSA", "MAURITA", "MARYLN", "MARYETTA", "MARSHALL", "MARCELL", "MALENA", "MAKEDA", "MADDIE", "LOVETTA", "LOURIE", "LORRINE", "LORILEE", "LESTER", "LAURENA", "LASHAY", "LARRAINE", "LAREE", "LACRESHA", "KRISTLE", "KRISHNA", "KEVA", "KEIRA", "KAROLE", "JOIE", "JINNY", "JEANNETTA", "JAMA", "HEIDY", "GILBERTE", "GEMA", "FAVIOLA", "EVELYNN", "ENDA", "ELLI", "ELLENA", "DIVINA", "DAGNY", "COLLENE", "CODI", "CINDIE", "CHASSIDY", "CHASIDY", "CATRICE", "CATHERINA", "CASSEY", "CAROLL", "CARLENA", "CANDRA", "CALISTA", "BRYANNA", "BRITTENY", "BEULA", "BARI", "AUDRIE", "AUDRIA", "ARDELIA", "ANNELLE", "ANGILA", "ALONA", "ALLYN", "DOUGLAS", "ROGER", "JONATHAN", "RALPH", "NICHOLAS", "BENJAMIN", "BRUCE", "HARRY", "WAYNE", "STEVE", "HOWARD", "ERNEST", "PHILLIP", "TODD", "CRAIG", "ALAN", "PHILIP", "EARL", "DANNY", "BRYAN", "STANLEY", "LEONARD", "NATHAN", "MANUEL", "RODNEY", "MARVIN", "VINCENT", "JEFFERY", "JEFF", "CHAD", "JACOB", "ALFRED", "BRADLEY", "HERBERT", "FREDERICK", "EDWIN", "DON", "RICKY", "RANDALL", "BARRY", "BERNARD", "LEROY", "MARCUS", "THEODORE", "CLIFFORD", "MIGUEL", "JIM", "TOM", "CALVIN", "BILL", "LLOYD", "DEREK", "WARREN", "DARRELL", "JEROME", "FLOYD", "ALVIN", "TIM", "GORDON", "GREG", "JORGE", "DUSTIN", "PEDRO", "DERRICK", "ZACHARY", "HERMAN", "GLEN", "HECTOR", "RICARDO", "RICK", "BRENT", "RAMON", "GILBERT", "MARC", "REGINALD", "RUBEN", "NATHANIEL", "RAFAEL", "EDGAR", "MILTON", "RAUL", "BEN", "CHESTER", "DUANE", "FRANKLIN", "BRAD", "RON", "ROLAND", "ARNOLD", "HARVEY", "JARED", "ERIK", "DARRYL", "NEIL", "JAVIER", "FERNANDO", "CLINTON", "TED", "MATHEW", "TYRONE", "DARREN", "LANCE", "KURT", "ALLAN", "NELSON", "GUY", "CLAYTON", "HUGH", "MAX", "DWAYNE", "DWIGHT", "ARMANDO", "FELIX", "EVERETT", "IAN", "WALLACE", "KEN", "BOB", "ALFREDO", "ALBERTO", "DAVE", "IVAN", "BYRON", "ISAAC", "MORRIS", "CLIFTON", "WILLARD", "ROSS", "ANDY", "SALVADOR", "KIRK", "SERGIO", "SETH", "KENT", "TERRANCE", "EDUARDO", "TERRENCE", "ENRIQUE", "WADE", "STUART", "FREDRICK", "ARTURO", "ALEJANDRO", "NICK", "LUTHER", "WENDELL", "JEREMIAH", "JULIUS", "OTIS", "TREVOR", "OLIVER", "LUKE", "HOMER", "GERARD", "DOUG", "KENNY", "HUBERT", "LYLE", "MATT", "ALFONSO", "ORLANDO", "REX", "CARLTON", "ERNESTO", "NEAL", "PABLO", "LORENZO", "OMAR", "WILBUR", "GRANT", "HORACE", "RODERICK", "ABRAHAM", "WILLIS", "RICKEY", "ANDRES", "CESAR", "JOHNATHAN", "MALCOLM", "RUDOLPH", "DAMON", "KELVIN", "PRESTON", "ALTON", "ARCHIE", "MARCO", "WM", "PETE", "RANDOLPH", "GARRY", "GEOFFREY", "JONATHON", "FELIPE", "GERARDO", "ED", "DOMINIC", "DELBERT", "COLIN", "GUILLERMO", "EARNEST", "LUCAS", "BENNY", "SPENCER", "RODOLFO", "MYRON", "EDMUND", "GARRETT", "SALVATORE", "CEDRIC", "LOWELL", "GREGG", "SHERMAN", "WILSON", "SYLVESTER", "ROOSEVELT", "ISRAEL", "JERMAINE", "FORREST", "WILBERT", "LELAND", "SIMON", "CLARK", "IRVING", "BRYANT", "OWEN", "RUFUS", "WOODROW", "KRISTOPHER", "MACK", "LEVI", "MARCOS", "GUSTAVO", "JAKE", "LIONEL", "GILBERTO", "CLINT", "NICOLAS", "ISMAEL", "ORVILLE", "ERVIN", "DEWEY", "AL", "WILFRED", "JOSH", "HUGO", "IGNACIO", "CALEB", "TOMAS", "SHELDON", "ERICK", "STEWART", "DOYLE", "DARREL", "ROGELIO", "TERENCE", "SANTIAGO", "ALONZO", "ELIAS", "BERT", "ELBERT", "RAMIRO", "CONRAD", "NOAH", "GRADY", "PHIL", "CORNELIUS", "LAMAR", "ROLANDO", "CLAY", "PERCY", "DEXTER", "BRADFORD", "DARIN", "AMOS", "MOSES", "IRVIN", "SAUL", "ROMAN", "RANDAL", "TIMMY", "DARRIN", "WINSTON", "BRENDAN", "ABEL", "DOMINICK", "BOYD", "EMILIO", "ELIJAH", "DOMINGO", "EMMETT", "MARLON", "EMANUEL", "JERALD", "EDMOND", "EMIL", "DEWAYNE", "WILL", "OTTO", "TEDDY", "REYNALDO", "BRET", "JESS", "TRENT", "HUMBERTO", "EMMANUEL", "STEPHAN", "VICENTE", "LAMONT", "GARLAND", "MILES", "EFRAIN", "HEATH", "RODGER", "HARLEY", "ETHAN", "ELDON", "ROCKY", "PIERRE", "JUNIOR", "FREDDY", "ELI", "BRYCE", "ANTOINE", "STERLING", "CHASE", "GROVER", "ELTON", "CLEVELAND", "DYLAN", "CHUCK", "DAMIAN", "REUBEN", "STAN", "AUGUST", "LEONARDO", "JASPER", "RUSSEL", "ERWIN", "BENITO", "HANS", "MONTE", "BLAINE", "ERNIE", "CURT", "QUENTIN", "AGUSTIN", "MURRAY", "JAMAL", "ADOLFO", "HARRISON", "TYSON", "BURTON", "BRADY", "ELLIOTT", "WILFREDO", "BART", "JARROD", "VANCE", "DENIS", "DAMIEN", "JOAQUIN", "HARLAN", "DESMOND", "ELLIOT", "DARWIN", "GREGORIO", "BUDDY", "XAVIER", "KERMIT", "ROSCOE", "ESTEBAN", "ANTON", "SOLOMON", "SCOTTY", "NORBERT", "ELVIN", "WILLIAMS", "NOLAN", "ROD", "QUINTON", "HAL", "BRAIN", "ROB", "ELWOOD", "KENDRICK", "DARIUS", "MOISES", "FIDEL", "THADDEUS", "CLIFF", "MARCEL", "JACKSON", "RAPHAEL", "BRYON", "ARMAND", "ALVARO", "JEFFRY", "DANE", "JOESPH", "THURMAN", "NED", "RUSTY", "MONTY", "FABIAN", "REGGIE", "MASON", "GRAHAM", "ISAIAH", "VAUGHN", "GUS", "LOYD", "DIEGO", "ADOLPH", "NORRIS", "MILLARD", "ROCCO", "GONZALO", "DERICK", "RODRIGO", "WILEY", "RIGOBERTO", "ALPHONSO", "TY", "NOE", "VERN", "REED", "JEFFERSON", "ELVIS", "BERNARDO", "MAURICIO", "HIRAM", "DONOVAN", "BASIL", "RILEY", "NICKOLAS", "MAYNARD", "SCOT", "VINCE", "QUINCY", "EDDY", "SEBASTIAN", "FEDERICO", "ULYSSES", "HERIBERTO", "DONNELL", "COLE", "DAVIS", "GAVIN", "EMERY", "WARD", "ROMEO", "JAYSON", "DANTE", "CLEMENT", "COY", "MAXWELL", "JARVIS", "BRUNO", "ISSAC", "DUDLEY", "BROCK", "SANFORD", "CARMELO", "BARNEY", "NESTOR", "STEFAN", "DONNY", "ART", "LINWOOD", "BEAU", "WELDON", "GALEN", "ISIDRO", "TRUMAN", "DELMAR", "JOHNATHON", "SILAS", "FREDERIC", "DICK", "IRWIN", "MERLIN", "CHARLEY", "MARCELINO", "HARRIS", "CARLO", "TRENTON", "KURTIS", "HUNTER", "AURELIO", "WINFRED", "VITO", "COLLIN", "DENVER", "CARTER", "LEONEL", "EMORY", "PASQUALE", "MOHAMMAD", "MARIANO", "DANIAL", "LANDON", "DIRK", "BRANDEN", "ADAN", "BUFORD", "GERMAN", "WILMER", "EMERSON", "ZACHERY", "FLETCHER", "JACQUES", "ERROL", "DALTON", "MONROE", "JOSUE", "EDWARDO", "BOOKER", "WILFORD", "SONNY", "SHELTON", "CARSON", "THERON", "RAYMUNDO", "DAREN", "HOUSTON", "ROBBY", "LINCOLN", "GENARO", "BENNETT", "OCTAVIO", "CORNELL", "HUNG", "ARRON", "ANTONY", "HERSCHEL", "GIOVANNI", "GARTH", "CYRUS", "CYRIL", "RONNY", "LON", "FREEMAN", "DUNCAN", "KENNITH", "CARMINE", "ERICH", "CHADWICK", "WILBURN", "RUSS", "REID", "MYLES", "ANDERSON", "MORTON", "JONAS", "FOREST", "MITCHEL", "MERVIN", "ZANE", "RICH", "JAMEL", "LAZARO", "ALPHONSE", "RANDELL", "MAJOR", "JARRETT", "BROOKS", "ABDUL", "LUCIANO", "SEYMOUR", "EUGENIO", "MOHAMMED", "VALENTIN", "CHANCE", "ARNULFO", "LUCIEN", "FERDINAND", "THAD", "EZRA", "ALDO", "RUBIN", "ROYAL", "MITCH", "EARLE", "ABE", "WYATT", "MARQUIS", "LANNY", "KAREEM", "JAMAR", "BORIS", "ISIAH", "EMILE", "ELMO", "ARON", "LEOPOLDO", "EVERETTE", "JOSEF", "ELOY", "RODRICK", "REINALDO", "LUCIO", "JERROD", "WESTON", "HERSHEL", "BARTON", "PARKER", "LEMUEL", "BURT", "JULES", "GIL", "ELISEO", "AHMAD", "NIGEL", "EFREN", "ANTWAN", "ALDEN", "MARGARITO", "COLEMAN", "DINO", "OSVALDO", "LES", "DEANDRE", "NORMAND", "KIETH", "TREY", "NORBERTO", "NAPOLEON", "JEROLD", "FRITZ", "ROSENDO", "MILFORD", "CHRISTOPER", "ALFONZO", "LYMAN", "JOSIAH", "BRANT", "WILTON", "RICO", "JAMAAL", "DEWITT", "BRENTON", "OLIN", "FOSTER", "FAUSTINO", "CLAUDIO", "JUDSON", "GINO", "EDGARDO", "ALEC", "TANNER", "JARRED", "DONN", "TAD", "PRINCE", "PORFIRIO", "ODIS", "LENARD", "CHAUNCEY", "TOD", "MEL", "MARCELO", "KORY", "AUGUSTUS", "KEVEN", "HILARIO", "BUD", "SAL", "ORVAL", "MAURO", "ZACHARIAH", "OLEN", "ANIBAL", "MILO", "JED", "DILLON", "AMADO", "NEWTON", "LENNY", "RICHIE", "HORACIO", "BRICE", "MOHAMED", "DELMER", "DARIO", "REYES", "MAC", "JONAH", "JERROLD", "ROBT", "HANK", "RUPERT", "ROLLAND", "KENTON", "DAMION", "ANTONE", "WALDO", "FREDRIC", "BRADLY", "KIP", "BURL", "WALKER", "TYREE", "JEFFEREY", "AHMED", "WILLY", "STANFORD", "OREN", "NOBLE", "MOSHE", "MIKEL", "ENOCH", "BRENDON", "QUINTIN", "JAMISON", "FLORENCIO", "DARRICK", "TOBIAS", "HASSAN", "GIUSEPPE", "DEMARCUS", "CLETUS", "TYRELL", "LYNDON", "KEENAN", "WERNER", "GERALDO", "COLUMBUS", "CHET", "BERTRAM", "MARKUS", "HUEY", "HILTON", "DWAIN", "DONTE", "TYRON", "OMER", "ISAIAS", "HIPOLITO", "FERMIN", "ADALBERTO", "BO", "BARRETT", "TEODORO", "MCKINLEY", "MAXIMO", "GARFIELD", "RALEIGH", "LAWERENCE", "ABRAM", "RASHAD", "KING", "EMMITT", "DARON", "SAMUAL", "MIQUEL", "EUSEBIO", "DOMENIC", "DARRON", "BUSTER", "WILBER", "RENATO", "JC", "HOYT", "HAYWOOD", "EZEKIEL", "CHAS", "FLORENTINO", "ELROY", "CLEMENTE", "ARDEN", "NEVILLE", "EDISON", "DESHAWN", "NATHANIAL", "JORDON", "DANILO", "CLAUD", "SHERWOOD", "RAYMON", "RAYFORD", "CRISTOBAL", "AMBROSE", "TITUS", "HYMAN", "FELTON", "EZEQUIEL", "ERASMO", "STANTON", "LONNY", "LEN", "IKE", "MILAN", "LINO", "JAROD", "HERB", "ANDREAS", "WALTON", "RHETT", "PALMER", "DOUGLASS", "CORDELL", "OSWALDO", "ELLSWORTH", "VIRGILIO", "TONEY", "NATHANAEL", "DEL", "BENEDICT", "MOSE", "JOHNSON", "ISREAL", "GARRET", "FAUSTO", "ASA", "ARLEN", "ZACK", "WARNER", "MODESTO", "FRANCESCO", "MANUAL", "GAYLORD", "GASTON", "FILIBERTO", "DEANGELO", "MICHALE", "GRANVILLE", "WES", "MALIK", "ZACKARY", "TUAN", "ELDRIDGE", "CRISTOPHER", "CORTEZ", "ANTIONE", "MALCOM", "LONG", "KOREY", "JOSPEH", "COLTON", "WAYLON", "VON", "HOSEA", "SHAD", "SANTO", "RUDOLF", "ROLF", "REY", "RENALDO", "MARCELLUS", "LUCIUS", "KRISTOFER", "BOYCE", "BENTON", "HAYDEN", "HARLAND", "ARNOLDO", "RUEBEN", "LEANDRO", "KRAIG", "JERRELL", "JEROMY", "HOBERT", "CEDRICK", "ARLIE", "WINFORD", "WALLY", "LUIGI", "KENETH", "JACINTO", "GRAIG", "FRANKLYN", "EDMUNDO", "SID", "PORTER", "LEIF", "JERAMY", "BUCK", "WILLIAN", "VINCENZO", "SHON", "LYNWOOD", "JERE", "HAI", "ELDEN", "DORSEY", "DARELL", "BRODERICK", "ALONSO"};
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p022().run());
}

public String run() {
    Arrays.sort(names);
    long sum = 0;
    for (int i = 0; i < names.length; ++i) {
        int value = 0;
        for (int j = 0; j < names[i].length(); ++j) value += names[i].charAt(j) - 'A' + 1;
        sum += value * (i + 1);
    }
    return Long.toString(sum);
}

public <init>() {
    super();
    isAbundant = new boolean[LIMIT + 1];
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p023().run());
}

public String run() {
    for (int i = 1; i < isAbundant.length; ++i) isAbundant[i] = isAbundant(i);
    int sum = 0;
    for (int i = 1; i <= LIMIT; ++i) {
        if (!isSumOf2Abundants(i)) sum += i;
    }
    return Integer.toString(sum);
}

private boolean isSumOf2Abundants(int n) {
    for (int i = 0; i <= n; ++i) {
        if (isAbundant[i] && isAbundant[n - i]) return true;
    }
    return false;
}

private static boolean isAbundant(int n) {
    if (n < 1) throw new IllegalArgumentException();
    int sum = 1;
    int end = Library.sqrt(n);
    for (int i = 2; i <= end; ++i) {
        if (n % i == 0) sum += i + n / i;
    }
    if (end * end == n) sum -= end;
    return sum > n;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p024().run());
}

public String run() {
    int[] array = new int[10];
    for (int i = 0; i < array.length; ++i) array[i] = i;
    for (int i = 0; i < 999999; ++i) {
        if (!Library.nextPermutation(array)) throw new AssertionError();
    }
    String ans = "";
    for (int i = 0; i < array.length; ++i) ans += array[i];
    return ans;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p025().run());
}

public String run() {
    BigInteger lowerThres = BigInteger.TEN.pow(DIGITS - 1);
    BigInteger upperThres = BigInteger.TEN.pow(DIGITS);
    BigInteger prev = BigInteger.ONE;
    BigInteger cur = BigInteger.ZERO;
    for (int i = 0; ; ++i) {
        if (cur.compareTo(upperThres) >= 0) throw new RuntimeException("Not found"); else if (cur.compareTo(lowerThres) >= 0) return Integer.toString(i);
        BigInteger temp = cur.add(prev);
        prev = cur;
        cur = temp;
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p026().run());
}

public String run() {
    int bestNumber = 0;
    int bestLength = 0;
    for (int i = 1; i <= 1000; ++i) {
        int len = getCycleLength(i);
        if (len > bestLength) {
            bestNumber = i;
            bestLength = len;
        }
    }
    return Integer.toString(bestNumber);
}

private static int getCycleLength(int n) {
    Map stateToIter = new HashMap();
    int state = 1;
    for (int iter = 0; ; ++iter) {
        if (stateToIter.containsKey(Integer.valueOf(state))) return iter - ((Integer)stateToIter.get(Integer.valueOf(state))).intValue(); else {
            stateToIter.put(Integer.valueOf(state), Integer.valueOf(iter));
            state = state * 10 % n;
        }
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p027().run());
}

public String run() {
    int bestNum = 0;
    int bestA = 0;
    int bestB = 0;
    for (int a = -1000; a <= 1000; ++a) {
        for (int b = -1000; b <= 1000; ++b) {
            int num = numberOfConsecutivePrimesGenerated(a, b);
            if (num > bestNum) {
                bestNum = num;
                bestA = a;
                bestB = b;
            }
        }
    }
    return Integer.toString(bestA * bestB);
}

private static int numberOfConsecutivePrimesGenerated(int a, int b) {
    for (int i = 0; ; ++i) {
        int n = i * i + i * a + b;
        if (n < 0 || !Library.isPrime(n)) return i;
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p028().run());
}

public String run() {
    long sum = 1;
    for (int n = 3; n <= SIZE; n += 2) sum += 4 * n * n - 6 * (n - 1);
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p029().run());
}

public String run() {
    Set generated = new HashSet();
    for (int a = 2; a <= 100; ++a) {
        for (int b = 2; b <= 100; ++b) generated.add(BigInteger.valueOf(a).pow(b));
    }
    return Integer.toString(generated.size());
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p030().run());
}

public String run() {
    int sum = 0;
    for (int i = 2; i < 1000000; ++i) {
        if (i == fifthPowerDigitSum(i)) sum += i;
    }
    return Integer.toString(sum);
}

private static int fifthPowerDigitSum(int x) {
    int sum = 0;
    while (x != 0) {
        int y = x % 10;
        sum += y * y * y * y * y;
        x /= 10;
    }
    return sum;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p031().run());
}

public String run() {
    int[][] ways = new int[COINS.length + 1][TOTAL + 1];
    ways[0][0] = 1;
    for (int i = 0; i < COINS.length; ++i) {
        int coin = COINS[i];
        for (int j = 0; j <= TOTAL; ++j) ways[i + 1][j] = ways[i][j] + (j >= coin ? ways[i + 1][j - coin] : 0);
    }
    return Integer.toString(ways[COINS.length][TOTAL]);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p032().run());
}

public String run() {
    int sum = 0;
    for (int i = 1; i < 10000; ++i) {
        if (hasPandigitalProduct(i)) sum += i;
    }
    return Integer.toString(sum);
}

private static boolean hasPandigitalProduct(int n) {
    for (int i = 1; i <= n; ++i) {
        if (n % i == 0 && isPandigital("" + n + i + n / i)) return true;
    }
    return false;
}

private static boolean isPandigital(String s) {
    if (s.length() != 9) return false;
    char[] temp = s.toCharArray();
    Arrays.sort(temp);
    return new String(temp).equals("123456789");
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p033().run());
}

public String run() {
    int numer = 1;
    int denom = 1;
    for (int d = 10; d < 100; ++d) {
        for (int n = 10; n < d; ++n) {
            int n0 = n % 10;
            int n1 = n / 10;
            int d0 = d % 10;
            int d1 = d / 10;
            if (n1 == d0 && n0 * d == n * d1 || n0 == d1 && n1 * d == n * d0) {
                numer *= n;
                denom *= d;
            }
        }
    }
    return Integer.toString(denom / Library.gcd(numer, denom));
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p034().run());
}

public String run() {
    int sum = 0;
    for (int i = 3; i < 10000000; ++i) {
        if (i == factorialDigitSum(i)) sum += i;
    }
    return Integer.toString(sum);
}

private static int factorialDigitSum(int x) {
    int sum = 0;
    while (x != 0) {
        sum += FACTORIAL[x % 10];
        x /= 10;
    }
    return sum;
}

public <init>() {
    super();
    isPrime = Library.listPrimality(LIMIT - 1);
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p035().run());
}

public String run() {
    int count = 0;
    for (int i = 0; i < isPrime.length; ++i) {
        if (isCircularPrime(i)) ++count;
    }
    return Integer.toString(count);
}

private boolean isCircularPrime(int n) {
    String s = Integer.toString(n);
    for (int i = 0; i < s.length(); ++i) {
        if (!isPrime[Integer.parseInt(s.substring(i) + s.substring(0, i))]) return false;
    }
    return true;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p036().run());
}

public String run() {
    long sum = 0;
    for (int i = 1; i < 1000000; ++i) {
        if (Library.isPalindrome(Integer.toString(i, 10)) && Library.isPalindrome(Integer.toString(i, 2))) sum += i;
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p037().run());
}

public String run() {
    long sum = 0;
    for (int count = 0, n = 10; count < 11; ++n) {
        if (isTruncatablePrime(n)) {
            sum += n;
            ++count;
        }
    }
    return Long.toString(sum);
}

private static boolean isTruncatablePrime(int n) {
    for (long i = 10; i <= n; i *= 10) {
        if (!Library.isPrime(n % (int)i)) return false;
    }
    for (; n != 0; n /= 10) {
        if (!Library.isPrime(n)) return false;
    }
    return true;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p038().run());
}

public String run() {
    int max = -1;
    for (int n = 2; n <= 9; ++n) {
        for (int i = 1; i < Library.pow(10, 9 / n); ++i) {
            String concat = "";
            for (int j = 1; j <= n; ++j) concat += i * j;
            if (isPandigital(concat)) max = Math.max(Integer.parseInt(concat), max);
        }
    }
    return Integer.toString(max);
}

private static boolean isPandigital(String s) {
    if (s.length() != 9) return false;
    char[] temp = s.toCharArray();
    Arrays.sort(temp);
    return new String(temp).equals("123456789");
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p039().run());
}

public String run() {
    int maxPerimeter = 0;
    int maxTriangles = 0;
    for (int p = 1; p <= 1000; ++p) {
        int triangles = countSolutions(p);
        if (triangles > maxTriangles) {
            maxTriangles = triangles;
            maxPerimeter = p;
        }
    }
    return Integer.toString(maxPerimeter);
}

private static int countSolutions(int p) {
    int count = 0;
    for (int a = 1; a <= p; ++a) {
        for (int b = a; b <= p; ++b) {
            int c = p - a - b;
            if (b <= c && a * a + b * b == c * c) ++count;
        }
    }
    return count;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p040().run());
}

public String run() {
    StringBuilder sb = new StringBuilder();
    for (int i = 1; i < 1000000; ++i) sb.append(i);
    int prod = 1;
    for (int i = 0; i <= 6; ++i) prod *= sb.charAt(Library.pow(10, i) - 1) - '0';
    return Integer.toString(prod);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p041().run());
}

public String run() {
    for (int n = 9; n >= 1; --n) {
        int[] digits = new int[n];
        for (int i = 0; i < digits.length; ++i) digits[i] = i + 1;
        int result = -1;
        do {
            if (Library.isPrime(toInteger(digits))) result = toInteger(digits);
        }         while (Library.nextPermutation(digits));
        if (result != -1) return Integer.toString(result);
    }
    throw new RuntimeException("Not found");
}

private static int toInteger(int[] digits) {
    int result = 0;
    for (/*synthetic*/ int[] arr$ = digits, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        result = result * 10 + x;
    }
    return result;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p042().run());
}

public String run() {
    int count = 0;
    for (/*synthetic*/ String[] arr$ = WORDS, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        String word = arr$[i$];
        {
            if (isTriangularNumber(wordValue(word))) ++count;
        }
    }
    return Integer.toString(count);
}

private static boolean isTriangularNumber(int x) {
    for (int i = 1; ; ++i) {
        int t = i * (i + 1) / 2;
        if (t == x) return true;
        if (t > x) return false;
    }
}

private static int wordValue(String s) {
    int sum = 0;
    for (int i = 0; i < s.length(); ++i) {
        char c = s.charAt(i);
        if (c < 'A' || c > 'Z') throw new IllegalArgumentException();
        sum += c - 'A' + 1;
    }
    return sum;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p043().run());
}

public String run() {
    long sum = 0;
    int[] digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    outer: do {
        for (int i = 0; i < DIVISIBILITY_TESTS.length; ++i) {
            if (toInteger(digits, i + 1, 3) % DIVISIBILITY_TESTS[i] != 0) continue outer;
        }
        sum += toInteger(digits, 0, digits.length);
    }     while (Library.nextPermutation(digits));
    return Long.toString(sum);
}

private static long toInteger(int[] digits, int off, int len) {
    long result = 0;
    for (int i = off; i < off + len; ++i) result = result * 10 + digits[i];
    return result;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p044().run());
}

public String run() {
    long minD = -1;
    for (int i = 2; ; ++i) {
        long pentI = pentagonalNumber(i);
        if (minD != -1 && pentI - pentagonalNumber(i - 1) >= minD) break;
        for (int j = i - 1; j >= 1; --j) {
            long pentJ = pentagonalNumber(j);
            long diff = pentI - pentJ;
            if (minD != -1 && diff >= minD) break; else if (isPentagonalNumber(pentI + pentJ) && isPentagonalNumber(diff)) minD = diff;
        }
    }
    return Long.toString(minD);
}

private static long pentagonalNumber(int x) {
    if (x <= 0) throw new IllegalArgumentException();
    return (long)x * (x * 3 - 1) >>> 1;
}

private static boolean isPentagonalNumber(long y) {
    if (y <= 0) return false;
    long temp = y * 24 + 1;
    long sqrt = Library.sqrt(temp);
    return sqrt * sqrt == temp && sqrt % 6 == 5;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p045().run());
}

public String run() {
    int i = 286;
    int j = 166;
    int k = 144;
    while (true) {
        long triangle = (long)i * (i + 1) / 2;
        long pentagon = (long)j * (j * 3 - 1) / 2;
        long hexagon = (long)k * (k * 2 - 1);
        long min = Math.min(Math.min(triangle, pentagon), hexagon);
        if (min == triangle && min == pentagon && min == hexagon) return Long.toString(min);
        if (min == triangle) ++i;
        if (min == pentagon) ++j;
        if (min == hexagon) ++k;
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p046().run());
}

public String run() {
    for (int i = 9; ; i += 2) {
        if (!satisfiesConjecture(i)) return Integer.toString(i);
    }
}

private static boolean satisfiesConjecture(int n) {
    if (n % 2 == 0 || Library.isPrime(n)) return true;
    for (int i = 1; i * i * 2 <= n; ++i) {
        if (Library.isPrime(n - i * i * 2)) return true;
    }
    return false;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p047().run());
}

public String run() {
    for (int i = 2; ; ++i) {
        if (has4PrimeFactors(i + 0) && has4PrimeFactors(i + 1) && has4PrimeFactors(i + 2) && has4PrimeFactors(i + 3)) return Integer.toString(i);
    }
}

private static boolean has4PrimeFactors(int n) {
    return countDistinctPrimeFactors(n) == 4;
}

private static int countDistinctPrimeFactors(int n) {
    int count = 0;
    for (int i = 2, end = Library.sqrt(n); i <= end; ++i) {
        if (n % i == 0) {
            do n /= i;             while (n % i == 0);
            ++count;
            end = Library.sqrt(n);
        }
    }
    if (n > 1) ++count;
    return count;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p048().run());
}

public String run() {
    BigInteger modulus = BigInteger.TEN.pow(10);
    BigInteger sum = BigInteger.ZERO;
    for (int i = 1; i <= 1000; ++i) sum = sum.add(BigInteger.valueOf(i).modPow(BigInteger.valueOf(i), modulus));
    return sum.mod(modulus).toString();
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p049().run());
}

public String run() {
    boolean[] isPrime = Library.listPrimality(LIMIT - 1);
    for (int base = 1000; base < LIMIT; ++base) {
        if (isPrime[base]) {
            for (int step = 1; step < LIMIT; ++step) {
                int a = base + step;
                int b = a + step;
                if (a < LIMIT && isPrime[a] && hasSameDigits(a, base) && b < LIMIT && isPrime[b] && hasSameDigits(b, base) && (base != 1487 || a != 4817)) return "" + base + a + b;
            }
        }
    }
    throw new RuntimeException("Not found");
}

private static boolean hasSameDigits(int x, int y) {
    char[] xdigits = Integer.toString(x).toCharArray();
    char[] ydigits = Integer.toString(y).toCharArray();
    Arrays.sort(xdigits);
    Arrays.sort(ydigits);
    return Arrays.equals(xdigits, ydigits);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p050().run());
}

public String run() {
    boolean[] isPrime = Library.listPrimality(LIMIT);
    int[] primes = Library.listPrimes(LIMIT);
    long maxSum = 0;
    int maxRun = -1;
    for (int i = 0; i < primes.length; ++i) {
        int sum = 0;
        for (int j = i; j < primes.length; ++j) {
            sum += primes[j];
            if (sum > LIMIT) break; else if (j - i > maxRun && sum > maxSum && isPrime[sum]) {
                maxSum = sum;
                maxRun = j - i;
            }
        }
    }
    return Long.toString(maxSum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p051().run());
}

public String run() {
    boolean[] isPrime = Library.listPrimality(1000000);
    for (int i = 0; i < isPrime.length; ++i) {
        if (!isPrime[i]) continue;
        int[] n = toDigits(i);
        for (int mask = 0; mask < (1 << n.length); ++mask) {
            int[] digits = doMask(n, mask);
            int count = 0;
            for (int j = 0; j < 10; ++j) {
                if (digits[0] != 0 && isPrime[toNumber(digits)]) ++count;
                digits = addMask(digits, mask);
            }
            if (count == 8) {
                digits = doMask(n, mask);
                for (int j = 0; j < 10; ++j) {
                    if (digits[0] != 0 && isPrime[toNumber(digits)]) return Integer.toString(toNumber(digits));
                    digits = addMask(digits, mask);
                }
            }
        }
    }
    throw new RuntimeException("Not found");
}

private static int[] toDigits(int n) {
    int[] buf = new int[10];
    int i = buf.length;
    do {
        --i;
        buf[i] = n % 10;
        n /= 10;
    }     while (n != 0);
    return Arrays.copyOfRange(buf, i, buf.length);
}

private static int[] doMask(int[] digits, int mask) {
    int[] result = new int[digits.length];
    for (int i = 0; i < digits.length; ++i) result[i] = digits[i] * (~mask >>> i & 1);
    return result;
}

private static int[] addMask(int[] digits, int mask) {
    int[] result = new int[digits.length];
    for (int i = 0; i < digits.length; ++i) result[i] = digits[i] + (mask >>> i & 1);
    return result;
}

private static int toNumber(int[] digits) {
    int result = 0;
    for (/*synthetic*/ int[] arr$ = digits, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        result = result * 10 + x;
    }
    return result;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p052().run());
}

public String run() {
    outer: for (int i = 1; ; ++i) {
        for (int j = 2; j < 6; ++j) {
            if (!hasSameDigits(i * j, i * (j + 1))) continue outer;
        }
        return Integer.toString(i);
    }
}

private static boolean hasSameDigits(int x, int y) {
    char[] xdigits = Integer.toString(x).toCharArray();
    char[] ydigits = Integer.toString(y).toCharArray();
    Arrays.sort(xdigits);
    Arrays.sort(ydigits);
    return Arrays.equals(xdigits, ydigits);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p053().run());
}

public String run() {
    BigInteger MILLION = BigInteger.TEN.pow(6);
    int count = 0;
    for (int n = 1; n <= 100; ++n) {
        for (int r = 0; r <= n; ++r) {
            if (Library.binomial(n, r).compareTo(MILLION) > 0) ++count;
        }
    }
    return Integer.toString(count);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p054().run());
}

public String run() {
    int count = 0;
    for (/*synthetic*/ String[] arr$ = HANDS, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        String hand = arr$[i$];
        {
            String[] cards = hand.split(" ");
            if (cards.length != 10) throw new AssertionError();
            p054$Card[] player1 = new p054$Card[5];
            p054$Card[] player2 = new p054$Card[5];
            for (int i = 0; i < 5; ++i) {
                player1[i] = new p054$Card(cards[i + 0]);
                player2[i] = new p054$Card(cards[i + 5]);
            }
            if (getScore(player1) > getScore(player2)) ++count;
        }
    }
    return Integer.toString(count);
}

private static int getScore(p054$Card[] hand) {
    if (hand.length != 5) throw new IllegalArgumentException();
    int[] rankCounts = new int[13];
    int flushSuit = hand[0].suit;
    for (/*synthetic*/ p054$Card[] arr$ = hand, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        p054$Card card = arr$[i$];
        {
            ++rankCounts[card.rank];
            if (card.suit != flushSuit) flushSuit = -1;
        }
    }
    int[] rankCountHist = new int[6];
    for (/*synthetic*/ int[] arr$ = rankCounts, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int count = arr$[i$];
        ++rankCountHist[count];
    }
    int bestCards = get5FrequentHighestCards(rankCounts, rankCountHist);
    int straightHighRank = getStraightHighRank(rankCounts);
    if (straightHighRank != -1 && flushSuit != -1) return 8 << 20 | straightHighRank; else if (rankCountHist[4] == 1) return 7 << 20 | bestCards; else if (rankCountHist[3] == 1 && rankCountHist[2] == 1) return 6 << 20 | bestCards; else if (flushSuit != -1) return 5 << 20 | bestCards; else if (straightHighRank != -1) return 4 << 20 | straightHighRank; else if (rankCountHist[3] == 1) return 3 << 20 | bestCards; else if (rankCountHist[2] == 2) return 2 << 20 | bestCards; else if (rankCountHist[2] == 1) return 1 << 20 | bestCards; else return 0 << 20 | bestCards;
}

private static int get5FrequentHighestCards(int[] ranks, int[] ranksHist) {
    int result = 0;
    int count = 0;
    for (int i = ranksHist.length - 1; i >= 0; --i) {
        for (int j = ranks.length - 1; j >= 0; --j) {
            if (ranks[j] == i) {
                for (int k = 0; k < i && count < 5; ++k, ++count) result = result << 4 | j;
            }
        }
    }
    if (count != 5) throw new IllegalArgumentException();
    return result;
}

private static int getStraightHighRank(int[] ranks) {
    outer: for (int i = ranks.length - 1; i >= 3; --i) {
        for (int j = 0; j < 5; ++j) {
            if (ranks[(i - j + 13) % 13] == 0) continue outer;
        }
        return i;
    }
    return -1;
}

public <init>(int rank, int suit) {
    super();
    if (rank < 0 || rank >= 13 || suit < 0 || suit >= 4) throw new IllegalArgumentException();
    this.rank = rank;
    this.suit = suit;
}
STATEMENT:
super();
STATEMENT:
if (rank < 0 || rank >= 13 || suit < 0 || suit >= 4) throw new IllegalArgumentException();
STATEMENT:
this.rank = rank;
STATEMENT:
this.suit = suit;

public <init>(String str) {
    this("23456789TJQKA".indexOf(str.charAt(0)), "SHCD".indexOf(str.charAt(1)));
}
STATEMENT:
this("23456789TJQKA".indexOf(str.charAt(0)), "SHCD".indexOf(str.charAt(1)));

public boolean equals(Object obj) {
    if (!(obj instanceof p054$Card)) return false;
    p054$Card other = (p054$Card)(p054$Card)obj;
    return rank == other.rank && suit == other.suit;
}

public int hashCode() {
    return rank * 4 + suit;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p055().run());
}

public String run() {
    int count = 0;
    for (int i = 0; i < 10000; ++i) {
        if (isLychrel(i)) ++count;
    }
    return Integer.toString(count);
}

private static boolean isLychrel(int n) {
    BigInteger temp = BigInteger.valueOf(n);
    for (int i = 0; i < 49; ++i) {
        temp = temp.add(new BigInteger(Library.reverse(temp.toString())));
        if (Library.isPalindrome(temp.toString())) return false;
    }
    return true;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p056().run());
}

public String run() {
    int max = 0;
    for (int a = 1; a < 100; ++a) {
        for (int b = 1; b < 100; ++b) {
            BigInteger pow = BigInteger.valueOf(a).pow(b);
            max = Math.max(digitSum(pow), max);
        }
    }
    return Integer.toString(max);
}

private static int digitSum(BigInteger n) {
    int sum = 0;
    String s = n.toString();
    for (int i = 0; i < s.length(); ++i) sum += s.charAt(i) - '0';
    return sum;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p057().run());
}

public String run() {
    BigInteger n = BigInteger.ZERO;
    BigInteger d = BigInteger.ONE;
    int count = 0;
    for (int i = 0; i < 1000; ++i) {
        BigInteger temp = d.multiply(BigInteger.valueOf(2)).add(n);
        n = d;
        d = temp;
        if (n.add(d).toString().length() > d.toString().length()) ++count;
    }
    return Integer.toString(count);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p058().run());
}

public String run() {
    int numPrimes = 0;
    for (int n = 1; ; n += 2) {
        for (int i = 0; i < 4; ++i) {
            if (Library.isPrime(n * n - i * (n - 1))) ++numPrimes;
        }
        if (n > 1 && numPrimes * 10 < n * 2 - 1) return Integer.toString(n);
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p059().run());
}

public String run() {
    byte[] bestKey = null;
    byte[] bestDecrypted = null;
    double bestScore = Double.NaN;
    for (byte x = 'a'; x <= 'z'; ++x) {
        for (byte y = 'a'; y <= 'z'; ++y) {
            for (byte z = 'a'; z <= 'z'; ++z) {
                byte[] key = {x, y, z};
                byte[] decrypted = decrypt(CIPHERTEXT, key);
                double score = score(decrypted);
                if (bestKey == null || score > bestScore) {
                    bestKey = key;
                    bestDecrypted = decrypted;
                    bestScore = score;
                }
            }
        }
    }
    int sum = 0;
    for (int i = 0; i < bestDecrypted.length; ++i) sum += bestDecrypted[i];
    return Integer.toString(sum);
}

private static double score(byte[] b) {
    double sum = 0;
    for (int i = 0; i < b.length; ++i) {
        char c = (char)b[i];
        if (c >= 'A' && c <= 'Z') sum += 1; else if (c >= 'a' && c <= 'z') sum += 2; else if (c < 32 || c == 127) sum -= 10;
    }
    return sum;
}

private static byte[] decrypt(byte[] ciphertext, byte[] key) {
    byte[] plaintext = new byte[ciphertext.length];
    for (int i = 0; i < ciphertext.length; ++i) plaintext[i] = (byte)(ciphertext[i] ^ key[i % key.length]);
    return plaintext;
}

public <init>() {
    super();
    primes = Library.listPrimes(PRIME_LIMIT);
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p060().run());
}

public String run() {
    isConcatPrimeKnown = new BitSet(primes.length * primes.length);
    isConcatPrime = new BitSet(primes.length * primes.length);
    int sumLimit = PRIME_LIMIT;
    while (true) {
        int sum = findSetSum(new int[]{}, 5, sumLimit - 1);
        if (sum == -1) return Integer.toString(sumLimit);
        sumLimit = sum;
    }
}

private int findSetSum(int[] prefix, int targetSize, int sumLimit) {
    if (prefix.length == targetSize) {
        int sum = 0;
        for (/*synthetic*/ int[] arr$ = prefix, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
            int i = arr$[i$];
            sum += primes[i];
        }
        return sum;
    } else {
        int i;
        if (prefix.length == 0) i = 0; else i = prefix[prefix.length - 1] + 1;
        outer: for (; i < primes.length && primes[i] <= sumLimit; ++i) {
            for (/*synthetic*/ int[] arr$ = prefix, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
                int j = arr$[i$];
                {
                    if (!isConcatPrime(i, j) || !isConcatPrime(j, i)) continue outer;
                }
            }
            int[] appended = Arrays.copyOf(prefix, prefix.length + 1);
            appended[appended.length - 1] = i;
            int sum = findSetSum(appended, targetSize, sumLimit - primes[i]);
            if (sum != -1) return sum;
        }
        return -1;
    }
}

private boolean isConcatPrime(int x, int y) {
    int index = x * primes.length + y;
    if (isConcatPrimeKnown.get(index)) return isConcatPrime.get(index);
    x = primes[x];
    y = primes[y];
    int mult = 1;
    for (int temp = y; temp != 0; temp /= 10) mult *= 10;
    boolean result = isPrime((long)x * mult + y);
    isConcatPrimeKnown.set(index);
    isConcatPrime.set(index, result);
    return result;
}

private boolean isPrime(long x) {
    if (x < 0) throw new IllegalArgumentException(); else if (x == 0 || x == 1) return false; else {
        long end = Library.sqrt(x);
        for (/*synthetic*/ int[] arr$ = primes, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
            int p = arr$[i$];
            {
                if (p > end) break;
                if (x % p == 0) return false;
            }
        }
        for (long i = primes[primes.length - 1] + 2; i <= end; i += 2) {
            if (x % i == 0) return false;
        }
        return true;
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p061().run());
}

@SuppressWarnings(value = "unchecked")
public String run() {
    numbers = new Set[9][100];
    for (int i = 0; i < numbers.length; ++i) {
        for (int j = 0; j < numbers[i].length; ++j) numbers[i][j] = new HashSet();
    }
    for (int sides = 3; sides <= 8; ++sides) {
        for (int n = 1; ; ++n) {
            int num = figurateNumber(sides, n);
            if (num >= 10000) break;
            if (num >= 1000) numbers[sides][num / 100].add(Integer.valueOf(num));
        }
    }
    for (int i = 10; i < 100; ++i) {
        for (/*synthetic*/ java.util.Iterator i$ = numbers[3][i].iterator(); i$.hasNext(); ) {
            int num = ((Integer)i$.next()).intValue();
            {
                int temp = findSolutionSum(num, num, 1 << 3, num);
                if (temp != -1) return Integer.toString(temp);
            }
        }
    }
    throw new AssertionError("No solution");
}

private int findSolutionSum(int begin, int current, int sidesUsed, int sum) {
    if (sidesUsed == 504) {
        if (current % 100 == begin / 100) return sum;
    } else {
        for (int sides = 4; sides <= 8; ++sides) {
            if (((sidesUsed >>> sides) & 1) != 0) continue;
            for (/*synthetic*/ java.util.Iterator i$ = numbers[sides][current % 100].iterator(); i$.hasNext(); ) {
                int num = ((Integer)i$.next()).intValue();
                {
                    int temp = findSolutionSum(begin, num, sidesUsed | (1 << sides), sum + num);
                    if (temp != -1) return temp;
                }
            }
        }
    }
    return -1;
}

private static int figurateNumber(int sides, int n) {
    return n * ((sides - 2) * n - (sides - 4)) / 2;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p062().run());
}

public String run() {
    int numDigits = 0;
    Map lowest = new HashMap();
    Map counts = new HashMap();
    for (int i = 0; ; ++i) {
        String numClass = getCubeNumberClass(i);
        if (numClass.length() > numDigits) {
            int min = Integer.MAX_VALUE;
            for (/*synthetic*/ java.util.Iterator i$ = counts.keySet().iterator(); i$.hasNext(); ) {
                String nc = (String)i$.next();
                {
                    if (((Integer)counts.get(nc)).intValue() == 5) min = Math.min(((Integer)lowest.get(nc)).intValue(), min);
                }
            }
            if (min != Integer.MAX_VALUE) return cube(min).toString();
            lowest.clear();
            counts.clear();
            numDigits = numClass.length();
        }
        if (!lowest.containsKey(numClass)) {
            lowest.put(numClass, Integer.valueOf(i));
            counts.put(numClass, Integer.valueOf(0));
        }
        counts.put(numClass, Integer.valueOf(((Integer)counts.get(numClass)).intValue() + 1));
    }
}

private static String getCubeNumberClass(int x) {
    char[] digits = cube(x).toString().toCharArray();
    Arrays.sort(digits);
    return new String(digits);
}

private static BigInteger cube(int x) {
    return BigInteger.valueOf(x).pow(3);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p063().run());
}

public String run() {
    int count = 0;
    for (int n = 1; n <= 9; ++n) {
        for (int k = 1; k <= 21; ++k) {
            if (BigInteger.valueOf(n).pow(k).toString().length() == k) ++count;
        }
    }
    return Integer.toString(count);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p064().run());
}

public String run() {
    int count = 0;
    for (int i = 1; i <= 10000; ++i) {
        if (!Library.isSquare(i) && getSqrtContinuedFractionPeriod(i) % 2 == 1) ++count;
    }
    return Integer.toString(count);
}

private static int getSqrtContinuedFractionPeriod(int n) {
    Map seen = new HashMap();
    p064$QuadraticSurd val = new p064$QuadraticSurd(BigInteger.ZERO, BigInteger.ONE, BigInteger.ONE, BigInteger.valueOf(n));
    do {
        seen.put(val, Integer.valueOf(seen.size()));
        val = val.subtract(new p064$QuadraticSurd(val.floor(), BigInteger.ZERO, BigInteger.ONE, val.d)).reciprocal();
    }     while (!seen.containsKey(val));
    return seen.size() - ((Integer)seen.get(val)).intValue();
}

public <init>(BigInteger a, BigInteger b, BigInteger c, BigInteger d) {
    super();
    if (c.signum() == 0) throw new IllegalArgumentException();
    if (c.signum() == -1) {
        a = a.negate();
        b = b.negate();
        c = c.negate();
    }
    BigInteger gcd = a.gcd(b).gcd(c);
    if (!gcd.equals(BigInteger.ONE)) {
        a = a.divide(gcd);
        b = b.divide(gcd);
        c = c.divide(gcd);
    }
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}
STATEMENT:
super();
STATEMENT:
if (c.signum() == 0) throw new IllegalArgumentException();
STATEMENT:
if (c.signum() == -1) {
    a = a.negate();
    b = b.negate();
    c = c.negate();
}
STATEMENT:
BigInteger gcd = a.gcd(b).gcd(c)
STATEMENT:
if (!gcd.equals(BigInteger.ONE)) {
    a = a.divide(gcd);
    b = b.divide(gcd);
    c = c.divide(gcd);
}
STATEMENT:
this.a = a;
STATEMENT:
this.b = b;
STATEMENT:
this.c = c;
STATEMENT:
this.d = d;

public p064$QuadraticSurd subtract(p064$QuadraticSurd other) {
    if (!d.equals(other.d)) throw new IllegalArgumentException();
    return new p064$QuadraticSurd(a.multiply(other.c).subtract(other.a.multiply(c)), b.multiply(other.c).subtract(other.b.multiply(c)), c.multiply(other.c), d);
}

public p064$QuadraticSurd reciprocal() {
    return new p064$QuadraticSurd(a.multiply(c).negate(), b.multiply(c), b.multiply(b).multiply(d).subtract(a.multiply(a)), d);
}

public BigInteger floor() {
    BigInteger temp = Library.sqrt(b.multiply(b).multiply(d));
    if (b.signum() == -1) temp = temp.add(BigInteger.ONE).negate();
    temp = temp.add(a);
    if (temp.signum() == -1) temp = temp.subtract(c.subtract(BigInteger.ONE));
    return temp.divide(c);
}

public boolean equals(Object obj) {
    if (!(obj instanceof p064$QuadraticSurd)) return false; else {
        p064$QuadraticSurd other = (p064$QuadraticSurd)(p064$QuadraticSurd)obj;
        return a.equals(other.a) && b.equals(other.b) && c.equals(other.c) && d.equals(other.d);
    }
}

public int hashCode() {
    return a.hashCode() + b.hashCode() + c.hashCode() + d.hashCode();
}

public String toString() {
    return String.format("(%d + %d*sqrt(%d)) / %d", new Object[]{a, b, d, c});
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p065().run());
}

public String run() {
    BigInteger n = BigInteger.ONE;
    BigInteger d = BigInteger.ZERO;
    for (int i = 99; i >= 0; --i) {
        BigInteger temp = BigInteger.valueOf(continuedFractionTerm(i)).multiply(n).add(d);
        d = n;
        n = temp;
    }
    int sum = 0;
    while (!n.equals(BigInteger.ZERO)) {
        BigInteger[] divrem = n.divideAndRemainder(BigInteger.TEN);
        sum += divrem[1].intValue();
        n = divrem[0];
    }
    return Integer.toString(sum);
}

private static int continuedFractionTerm(int i) {
    if (i == 0) return 2; else if (i % 3 == 2) return i / 3 * 2 + 2; else return 1;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p066().run());
}

public String run() {
    int minN = -1;
    BigInteger maxX = BigInteger.ZERO;
    for (int n = 2; n <= 1000; ++n) {
        if (Library.isSquare(n)) continue;
        BigInteger x = smallestSolutionX(n);
        if (x.compareTo(maxX) > 0) {
            minN = n;
            maxX = x;
        }
    }
    return Integer.toString(minN);
}

private static BigInteger smallestSolutionX(int n) {
    List[] contFrac = sqrtToContinuedFraction(n);
    List temp = new ArrayList();
    temp.addAll(contFrac[0]);
    temp.addAll(contFrac[1].subList(0, contFrac[1].size() - 1));
    Fraction val = new Fraction((BigInteger)temp.get(temp.size() - 1));
    for (int i = temp.size() - 2; i >= 0; --i) val = new Fraction(val.denominator, val.numerator).add(new Fraction((BigInteger)temp.get(i)));
    if (contFrac[1].size() % 2 == 0) return val.numerator; else return val.numerator.pow(2).add(val.denominator.pow(2).multiply(BigInteger.valueOf(n)));
}

@SuppressWarnings(value = "unchecked")
private static List[] sqrtToContinuedFraction(int n) {
    List terms = new ArrayList();
    Map seen = new HashMap();
    p066$QuadraticSurd val = new p066$QuadraticSurd(BigInteger.ZERO, BigInteger.ONE, BigInteger.ONE, BigInteger.valueOf(n));
    do {
        seen.put(val, Integer.valueOf(seen.size()));
        BigInteger flr = val.floor();
        terms.add(flr);
        val = val.subtract(new p066$QuadraticSurd(flr, BigInteger.ZERO, BigInteger.ONE, val.d)).reciprocal();
    }     while (!seen.containsKey(val));
    return new List[]{terms.subList(0, ((Integer)seen.get(val)).intValue()), terms.subList(((Integer)seen.get(val)).intValue(), terms.size())};
}

public <init>(BigInteger a, BigInteger b, BigInteger c, BigInteger d) {
    super();
    if (c.signum() == 0) throw new IllegalArgumentException();
    if (c.signum() == -1) {
        a = a.negate();
        b = b.negate();
        c = c.negate();
    }
    BigInteger gcd = a.gcd(b).gcd(c);
    if (!gcd.equals(BigInteger.ONE)) {
        a = a.divide(gcd);
        b = b.divide(gcd);
        c = c.divide(gcd);
    }
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}
STATEMENT:
super();
STATEMENT:
if (c.signum() == 0) throw new IllegalArgumentException();
STATEMENT:
if (c.signum() == -1) {
    a = a.negate();
    b = b.negate();
    c = c.negate();
}
STATEMENT:
BigInteger gcd = a.gcd(b).gcd(c)
STATEMENT:
if (!gcd.equals(BigInteger.ONE)) {
    a = a.divide(gcd);
    b = b.divide(gcd);
    c = c.divide(gcd);
}
STATEMENT:
this.a = a;
STATEMENT:
this.b = b;
STATEMENT:
this.c = c;
STATEMENT:
this.d = d;

public p066$QuadraticSurd subtract(p066$QuadraticSurd other) {
    if (!d.equals(other.d)) throw new IllegalArgumentException();
    return new p066$QuadraticSurd(a.multiply(other.c).subtract(other.a.multiply(c)), b.multiply(other.c).subtract(other.b.multiply(c)), c.multiply(other.c), d);
}

public p066$QuadraticSurd reciprocal() {
    return new p066$QuadraticSurd(a.multiply(c).negate(), b.multiply(c), b.multiply(b).multiply(d).subtract(a.multiply(a)), d);
}

public BigInteger floor() {
    BigInteger temp = Library.sqrt(b.multiply(b).multiply(d));
    if (b.signum() == -1) temp = temp.add(BigInteger.ONE).negate();
    temp = temp.add(a);
    if (temp.signum() == -1) temp = temp.subtract(c.subtract(BigInteger.ONE));
    return temp.divide(c);
}

public boolean equals(Object obj) {
    if (!(obj instanceof p066$QuadraticSurd)) return false; else {
        p066$QuadraticSurd other = (p066$QuadraticSurd)(p066$QuadraticSurd)obj;
        return a.equals(other.a) && b.equals(other.b) && c.equals(other.c) && d.equals(other.d);
    }
}

public int hashCode() {
    return a.hashCode() + b.hashCode() + c.hashCode() + d.hashCode();
}

public String toString() {
    return String.format("(%d + %d*sqrt(%d)) / %d", new Object[]{a, b, d, c});
}

public <init>() {
    super();
    triangle = {{59}, {73, 41}, {52, 40, 9}, {26, 53, 6, 34}, {10, 51, 87, 86, 81}, {61, 95, 66, 57, 25, 68}, {90, 81, 80, 38, 92, 67, 73}, {30, 28, 51, 76, 81, 18, 75, 44}, {84, 14, 95, 87, 62, 81, 17, 78, 58}, {21, 46, 71, 58, 2, 79, 62, 39, 31, 9}, {56, 34, 35, 53, 78, 31, 81, 18, 90, 93, 15}, {78, 53, 4, 21, 84, 93, 32, 13, 97, 11, 37, 51}, {45, 3, 81, 79, 5, 18, 78, 86, 13, 30, 63, 99, 95}, {39, 87, 96, 28, 3, 38, 42, 17, 82, 87, 58, 7, 22, 57}, {6, 17, 51, 17, 7, 93, 9, 7, 75, 97, 95, 78, 87, 8, 53}, {67, 66, 59, 60, 88, 99, 94, 65, 55, 77, 55, 34, 27, 53, 78, 28}, {76, 40, 41, 4, 87, 16, 9, 42, 75, 69, 23, 97, 30, 60, 10, 79, 87}, {12, 10, 44, 26, 21, 36, 32, 84, 98, 60, 13, 12, 36, 16, 63, 31, 91, 35}, {70, 39, 6, 5, 55, 27, 38, 48, 28, 22, 34, 35, 62, 62, 15, 14, 94, 89, 86}, {66, 56, 68, 84, 96, 21, 34, 34, 34, 81, 62, 40, 65, 54, 62, 5, 98, 3, 2, 60}, {38, 89, 46, 37, 99, 54, 34, 53, 36, 14, 70, 26, 2, 90, 45, 13, 31, 61, 83, 73, 47}, {36, 10, 63, 96, 60, 49, 41, 5, 37, 42, 14, 58, 84, 93, 96, 17, 9, 43, 5, 43, 6, 59}, {66, 57, 87, 57, 61, 28, 37, 51, 84, 73, 79, 15, 39, 95, 88, 87, 43, 39, 11, 86, 77, 74, 18}, {54, 42, 5, 79, 30, 49, 99, 73, 46, 37, 50, 2, 45, 9, 54, 52, 27, 95, 27, 65, 19, 45, 26, 45}, {71, 39, 17, 78, 76, 29, 52, 90, 18, 99, 78, 19, 35, 62, 71, 19, 23, 65, 93, 85, 49, 33, 75, 9, 2}, {33, 24, 47, 61, 60, 55, 32, 88, 57, 55, 91, 54, 46, 57, 7, 77, 98, 52, 80, 99, 24, 25, 46, 78, 79, 5}, {92, 9, 13, 55, 10, 67, 26, 78, 76, 82, 63, 49, 51, 31, 24, 68, 5, 57, 7, 54, 69, 21, 67, 43, 17, 63, 12}, {24, 59, 6, 8, 98, 74, 66, 26, 61, 60, 13, 3, 9, 9, 24, 30, 71, 8, 88, 70, 72, 70, 29, 90, 11, 82, 41, 34}, {66, 82, 67, 4, 36, 60, 92, 77, 91, 85, 62, 49, 59, 61, 30, 90, 29, 94, 26, 41, 89, 4, 53, 22, 83, 41, 9, 74, 90}, {48, 28, 26, 37, 28, 52, 77, 26, 51, 32, 18, 98, 79, 36, 62, 13, 17, 8, 19, 54, 89, 29, 73, 68, 42, 14, 8, 16, 70, 37}, {37, 60, 69, 70, 72, 71, 9, 59, 13, 60, 38, 13, 57, 36, 9, 30, 43, 89, 30, 39, 15, 2, 44, 73, 5, 73, 26, 63, 56, 86, 12}, {55, 55, 85, 50, 62, 99, 84, 77, 28, 85, 3, 21, 27, 22, 19, 26, 82, 69, 54, 4, 13, 7, 85, 14, 1, 15, 70, 59, 89, 95, 10, 19}, {4, 9, 31, 92, 91, 38, 92, 86, 98, 75, 21, 5, 64, 42, 62, 84, 36, 20, 73, 42, 21, 23, 22, 51, 51, 79, 25, 45, 85, 53, 3, 43, 22}, {75, 63, 2, 49, 14, 12, 89, 14, 60, 78, 92, 16, 44, 82, 38, 30, 72, 11, 46, 52, 90, 27, 8, 65, 78, 3, 85, 41, 57, 79, 39, 52, 33, 48}, {78, 27, 56, 56, 39, 13, 19, 43, 86, 72, 58, 95, 39, 7, 4, 34, 21, 98, 39, 15, 39, 84, 89, 69, 84, 46, 37, 57, 59, 35, 59, 50, 26, 15, 93}, {42, 89, 36, 27, 78, 91, 24, 11, 17, 41, 5, 94, 7, 69, 51, 96, 3, 96, 47, 90, 90, 45, 91, 20, 50, 56, 10, 32, 36, 49, 4, 53, 85, 92, 25, 65}, {52, 9, 61, 30, 61, 97, 66, 21, 96, 92, 98, 90, 6, 34, 96, 60, 32, 69, 68, 33, 75, 84, 18, 31, 71, 50, 84, 63, 3, 3, 19, 11, 28, 42, 75, 45, 45}, {61, 31, 61, 68, 96, 34, 49, 39, 5, 71, 76, 59, 62, 67, 6, 47, 96, 99, 34, 21, 32, 47, 52, 7, 71, 60, 42, 72, 94, 56, 82, 83, 84, 40, 94, 87, 82, 46}, {1, 20, 60, 14, 17, 38, 26, 78, 66, 81, 45, 95, 18, 51, 98, 81, 48, 16, 53, 88, 37, 52, 69, 95, 72, 93, 22, 34, 98, 20, 54, 27, 73, 61, 56, 63, 60, 34, 63}, {93, 42, 94, 83, 47, 61, 27, 51, 79, 79, 45, 1, 44, 73, 31, 70, 83, 42, 88, 25, 53, 51, 30, 15, 65, 94, 80, 44, 61, 84, 12, 77, 2, 62, 2, 65, 94, 42, 14, 94}, {32, 73, 9, 67, 68, 29, 74, 98, 10, 19, 85, 48, 38, 31, 85, 67, 53, 93, 93, 77, 47, 67, 39, 72, 94, 53, 18, 43, 77, 40, 78, 32, 29, 59, 24, 6, 2, 83, 50, 60, 66}, {32, 1, 44, 30, 16, 51, 15, 81, 98, 15, 10, 62, 86, 79, 50, 62, 45, 60, 70, 38, 31, 85, 65, 61, 64, 6, 69, 84, 14, 22, 56, 43, 9, 48, 66, 69, 83, 91, 60, 40, 36, 61}, {92, 48, 22, 99, 15, 95, 64, 43, 1, 16, 94, 2, 99, 19, 17, 69, 11, 58, 97, 56, 89, 31, 77, 45, 67, 96, 12, 73, 8, 20, 36, 47, 81, 44, 50, 64, 68, 85, 40, 81, 85, 52, 9}, {91, 35, 92, 45, 32, 84, 62, 15, 19, 64, 21, 66, 6, 1, 52, 80, 62, 59, 12, 25, 88, 28, 91, 50, 40, 16, 22, 99, 92, 79, 87, 51, 21, 77, 74, 77, 7, 42, 38, 42, 74, 83, 2, 5}, {46, 19, 77, 66, 24, 18, 5, 32, 2, 84, 31, 99, 92, 58, 96, 72, 91, 36, 62, 99, 55, 29, 53, 42, 12, 37, 26, 58, 89, 50, 66, 19, 82, 75, 12, 48, 24, 87, 91, 85, 2, 7, 3, 76, 86}, {99, 98, 84, 93, 7, 17, 33, 61, 92, 20, 66, 60, 24, 66, 40, 30, 67, 5, 37, 29, 24, 96, 3, 27, 70, 62, 13, 4, 45, 47, 59, 88, 43, 20, 66, 15, 46, 92, 30, 4, 71, 66, 78, 70, 53, 99}, {67, 60, 38, 6, 88, 4, 17, 72, 10, 99, 71, 7, 42, 25, 54, 5, 26, 64, 91, 50, 45, 71, 6, 30, 67, 48, 69, 82, 8, 56, 80, 67, 18, 46, 66, 63, 1, 20, 8, 80, 47, 7, 91, 16, 3, 79, 87}, {18, 54, 78, 49, 80, 48, 77, 40, 68, 23, 60, 88, 58, 80, 33, 57, 11, 69, 55, 53, 64, 2, 94, 49, 60, 92, 16, 35, 81, 21, 82, 96, 25, 24, 96, 18, 2, 5, 49, 3, 50, 77, 6, 32, 84, 27, 18, 38}, {68, 1, 50, 4, 3, 21, 42, 94, 53, 24, 89, 5, 92, 26, 52, 36, 68, 11, 85, 1, 4, 42, 2, 45, 15, 6, 50, 4, 53, 73, 25, 74, 81, 88, 98, 21, 67, 84, 79, 97, 99, 20, 95, 4, 40, 46, 2, 58, 87}, {94, 10, 2, 78, 88, 52, 21, 3, 88, 60, 6, 53, 49, 71, 20, 91, 12, 65, 7, 49, 21, 22, 11, 41, 58, 99, 36, 16, 9, 48, 17, 24, 52, 36, 23, 15, 72, 16, 84, 56, 2, 99, 43, 76, 81, 71, 29, 39, 49, 17}, {64, 39, 59, 84, 86, 16, 17, 66, 3, 9, 43, 6, 64, 18, 63, 29, 68, 6, 23, 7, 87, 14, 26, 35, 17, 12, 98, 41, 53, 64, 78, 18, 98, 27, 28, 84, 80, 67, 75, 62, 10, 11, 76, 90, 54, 10, 5, 54, 41, 39, 66}, {43, 83, 18, 37, 32, 31, 52, 29, 95, 47, 8, 76, 35, 11, 4, 53, 35, 43, 34, 10, 52, 57, 12, 36, 20, 39, 40, 55, 78, 44, 7, 31, 38, 26, 8, 15, 56, 88, 86, 1, 52, 62, 10, 24, 32, 5, 60, 65, 53, 28, 57, 99}, {3, 50, 3, 52, 7, 73, 49, 92, 66, 80, 1, 46, 8, 67, 25, 36, 73, 93, 7, 42, 25, 53, 13, 96, 76, 83, 87, 90, 54, 89, 78, 22, 78, 91, 73, 51, 69, 9, 79, 94, 83, 53, 9, 40, 69, 62, 10, 79, 49, 47, 3, 81, 30}, {71, 54, 73, 33, 51, 76, 59, 54, 79, 37, 56, 45, 84, 17, 62, 21, 98, 69, 41, 95, 65, 24, 39, 37, 62, 3, 24, 48, 54, 64, 46, 82, 71, 78, 33, 67, 9, 16, 96, 68, 52, 74, 79, 68, 32, 21, 13, 78, 96, 60, 9, 69, 20, 36}, {73, 26, 21, 44, 46, 38, 17, 83, 65, 98, 7, 23, 52, 46, 61, 97, 33, 13, 60, 31, 70, 15, 36, 77, 31, 58, 56, 93, 75, 68, 21, 36, 69, 53, 90, 75, 25, 82, 39, 50, 65, 94, 29, 30, 11, 33, 11, 13, 96, 2, 56, 47, 7, 49, 2}, {76, 46, 73, 30, 10, 20, 60, 70, 14, 56, 34, 26, 37, 39, 48, 24, 55, 76, 84, 91, 39, 86, 95, 61, 50, 14, 53, 93, 64, 67, 37, 31, 10, 84, 42, 70, 48, 20, 10, 72, 60, 61, 84, 79, 69, 65, 99, 73, 89, 25, 85, 48, 92, 56, 97, 16}, {3, 14, 80, 27, 22, 30, 44, 27, 67, 75, 79, 32, 51, 54, 81, 29, 65, 14, 19, 4, 13, 82, 4, 91, 43, 40, 12, 52, 29, 99, 7, 76, 60, 25, 1, 7, 61, 71, 37, 92, 40, 47, 99, 66, 57, 1, 43, 44, 22, 40, 53, 53, 9, 69, 26, 81, 7}, {49, 80, 56, 90, 93, 87, 47, 13, 75, 28, 87, 23, 72, 79, 32, 18, 27, 20, 28, 10, 37, 59, 21, 18, 70, 4, 79, 96, 3, 31, 45, 71, 81, 6, 14, 18, 17, 5, 31, 50, 92, 79, 23, 47, 9, 39, 47, 91, 43, 54, 69, 47, 42, 95, 62, 46, 32, 85}, {37, 18, 62, 85, 87, 28, 64, 5, 77, 51, 47, 26, 30, 65, 5, 70, 65, 75, 59, 80, 42, 52, 25, 20, 44, 10, 92, 17, 71, 95, 52, 14, 77, 13, 24, 55, 11, 65, 26, 91, 1, 30, 63, 15, 49, 48, 41, 17, 67, 47, 3, 68, 20, 90, 98, 32, 4, 40, 68}, {90, 51, 58, 60, 6, 55, 23, 68, 5, 19, 76, 94, 82, 36, 96, 43, 38, 90, 87, 28, 33, 83, 5, 17, 70, 83, 96, 93, 6, 4, 78, 47, 80, 6, 23, 84, 75, 23, 87, 72, 99, 14, 50, 98, 92, 38, 90, 64, 61, 58, 76, 94, 36, 66, 87, 80, 51, 35, 61, 38}, {57, 95, 64, 6, 53, 36, 82, 51, 40, 33, 47, 14, 7, 98, 78, 65, 39, 58, 53, 6, 50, 53, 4, 69, 40, 68, 36, 69, 75, 78, 75, 60, 3, 32, 39, 24, 74, 47, 26, 90, 13, 40, 44, 71, 90, 76, 51, 24, 36, 50, 25, 45, 70, 80, 61, 80, 61, 43, 90, 64, 11}, {18, 29, 86, 56, 68, 42, 79, 10, 42, 44, 30, 12, 96, 18, 23, 18, 52, 59, 2, 99, 67, 46, 60, 86, 43, 38, 55, 17, 44, 93, 42, 21, 55, 14, 47, 34, 55, 16, 49, 24, 23, 29, 96, 51, 55, 10, 46, 53, 27, 92, 27, 46, 63, 57, 30, 65, 43, 27, 21, 20, 24, 83}, {81, 72, 93, 19, 69, 52, 48, 1, 13, 83, 92, 69, 20, 48, 69, 59, 20, 62, 5, 42, 28, 89, 90, 99, 32, 72, 84, 17, 8, 87, 36, 3, 60, 31, 36, 36, 81, 26, 97, 36, 48, 54, 56, 56, 27, 16, 91, 8, 23, 11, 87, 99, 33, 47, 2, 14, 44, 73, 70, 99, 43, 35, 33}, {90, 56, 61, 86, 56, 12, 70, 59, 63, 32, 1, 15, 81, 47, 71, 76, 95, 32, 65, 80, 54, 70, 34, 51, 40, 45, 33, 4, 64, 55, 78, 68, 88, 47, 31, 47, 68, 87, 3, 84, 23, 44, 89, 72, 35, 8, 31, 76, 63, 26, 90, 85, 96, 67, 65, 91, 19, 14, 17, 86, 4, 71, 32, 95}, {37, 13, 4, 22, 64, 37, 37, 28, 56, 62, 86, 33, 7, 37, 10, 44, 52, 82, 52, 6, 19, 52, 57, 75, 90, 26, 91, 24, 6, 21, 14, 67, 76, 30, 46, 14, 35, 89, 89, 41, 3, 64, 56, 97, 87, 63, 22, 34, 3, 79, 17, 45, 11, 53, 25, 56, 96, 61, 23, 18, 63, 31, 37, 37, 47}, {77, 23, 26, 70, 72, 76, 77, 4, 28, 64, 71, 69, 14, 85, 96, 54, 95, 48, 6, 62, 99, 83, 86, 77, 97, 75, 71, 66, 30, 19, 57, 90, 33, 1, 60, 61, 14, 12, 90, 99, 32, 77, 56, 41, 18, 14, 87, 49, 10, 14, 90, 64, 18, 50, 21, 74, 14, 16, 88, 5, 45, 73, 82, 47, 74, 44}, {22, 97, 41, 13, 34, 31, 54, 61, 56, 94, 3, 24, 59, 27, 98, 77, 4, 9, 37, 40, 12, 26, 87, 9, 71, 70, 7, 18, 64, 57, 80, 21, 12, 71, 83, 94, 60, 39, 73, 79, 73, 19, 97, 32, 64, 29, 41, 7, 48, 84, 85, 67, 12, 74, 95, 20, 24, 52, 41, 67, 56, 61, 29, 93, 35, 72, 69}, {72, 23, 63, 66, 1, 11, 7, 30, 52, 56, 95, 16, 65, 26, 83, 90, 50, 74, 60, 18, 16, 48, 43, 77, 37, 11, 99, 98, 30, 94, 91, 26, 62, 73, 45, 12, 87, 73, 47, 27, 1, 88, 66, 99, 21, 41, 95, 80, 2, 53, 23, 32, 61, 48, 32, 43, 43, 83, 14, 66, 95, 91, 19, 81, 80, 67, 25, 88}, {8, 62, 32, 18, 92, 14, 83, 71, 37, 96, 11, 83, 39, 99, 5, 16, 23, 27, 10, 67, 2, 25, 44, 11, 55, 31, 46, 64, 41, 56, 44, 74, 26, 81, 51, 31, 45, 85, 87, 9, 81, 95, 22, 28, 76, 69, 46, 48, 64, 87, 67, 76, 27, 89, 31, 11, 74, 16, 62, 3, 60, 94, 42, 47, 9, 34, 94, 93, 72}, {56, 18, 90, 18, 42, 17, 42, 32, 14, 86, 6, 53, 33, 95, 99, 35, 29, 15, 44, 20, 49, 59, 25, 54, 34, 59, 84, 21, 23, 54, 35, 90, 78, 16, 93, 13, 37, 88, 54, 19, 86, 67, 68, 55, 66, 84, 65, 42, 98, 37, 87, 56, 33, 28, 58, 38, 28, 38, 66, 27, 52, 21, 81, 15, 8, 22, 97, 32, 85, 27}, {91, 53, 40, 28, 13, 34, 91, 25, 1, 63, 50, 37, 22, 49, 71, 58, 32, 28, 30, 18, 68, 94, 23, 83, 63, 62, 94, 76, 80, 41, 90, 22, 82, 52, 29, 12, 18, 56, 10, 8, 35, 14, 37, 57, 23, 65, 67, 40, 72, 39, 93, 39, 70, 89, 40, 34, 7, 46, 94, 22, 20, 5, 53, 64, 56, 30, 5, 56, 61, 88, 27}, {23, 95, 11, 12, 37, 69, 68, 24, 66, 10, 87, 70, 43, 50, 75, 7, 62, 41, 83, 58, 95, 93, 89, 79, 45, 39, 2, 22, 5, 22, 95, 43, 62, 11, 68, 29, 17, 40, 26, 44, 25, 71, 87, 16, 70, 85, 19, 25, 59, 94, 90, 41, 41, 80, 61, 70, 55, 60, 84, 33, 95, 76, 42, 63, 15, 9, 3, 40, 38, 12, 3, 32}, {9, 84, 56, 80, 61, 55, 85, 97, 16, 94, 82, 94, 98, 57, 84, 30, 84, 48, 93, 90, 71, 5, 95, 90, 73, 17, 30, 98, 40, 64, 65, 89, 7, 79, 9, 19, 56, 36, 42, 30, 23, 69, 73, 72, 7, 5, 27, 61, 24, 31, 43, 48, 71, 84, 21, 28, 26, 65, 65, 59, 65, 74, 77, 20, 10, 81, 61, 84, 95, 8, 52, 23, 70}, {47, 81, 28, 9, 98, 51, 67, 64, 35, 51, 59, 36, 92, 82, 77, 65, 80, 24, 72, 53, 22, 7, 27, 10, 21, 28, 30, 22, 48, 82, 80, 48, 56, 20, 14, 43, 18, 25, 50, 95, 90, 31, 77, 8, 9, 48, 44, 80, 90, 22, 93, 45, 82, 17, 13, 96, 25, 26, 8, 73, 34, 99, 6, 49, 24, 6, 83, 51, 40, 14, 15, 10, 25, 1}, {54, 25, 10, 81, 30, 64, 24, 74, 75, 80, 36, 75, 82, 60, 22, 69, 72, 91, 45, 67, 3, 62, 79, 54, 89, 74, 44, 83, 64, 96, 66, 73, 44, 30, 74, 50, 37, 5, 9, 97, 70, 1, 60, 46, 37, 91, 39, 75, 75, 18, 58, 52, 72, 78, 51, 81, 86, 52, 8, 97, 1, 46, 43, 66, 98, 62, 81, 18, 70, 93, 73, 8, 32, 46, 34}, {96, 80, 82, 7, 59, 71, 92, 53, 19, 20, 88, 66, 3, 26, 26, 10, 24, 27, 50, 82, 94, 73, 63, 8, 51, 33, 22, 45, 19, 13, 58, 33, 90, 15, 22, 50, 36, 13, 55, 6, 35, 47, 82, 52, 33, 61, 36, 27, 28, 46, 98, 14, 73, 20, 73, 32, 16, 26, 80, 53, 47, 66, 76, 38, 94, 45, 2, 1, 22, 52, 47, 96, 64, 58, 52, 39}, {88, 46, 23, 39, 74, 63, 81, 64, 20, 90, 33, 33, 76, 55, 58, 26, 10, 46, 42, 26, 74, 74, 12, 83, 32, 43, 9, 2, 73, 55, 86, 54, 85, 34, 28, 23, 29, 79, 91, 62, 47, 41, 82, 87, 99, 22, 48, 90, 20, 5, 96, 75, 95, 4, 43, 28, 81, 39, 81, 1, 28, 42, 78, 25, 39, 77, 90, 57, 58, 98, 17, 36, 73, 22, 63, 74, 51}, {29, 39, 74, 94, 95, 78, 64, 24, 38, 86, 63, 87, 93, 6, 70, 92, 22, 16, 80, 64, 29, 52, 20, 27, 23, 50, 14, 13, 87, 15, 72, 96, 81, 22, 8, 49, 72, 30, 70, 24, 79, 31, 16, 64, 59, 21, 89, 34, 96, 91, 48, 76, 43, 53, 88, 1, 57, 80, 23, 81, 90, 79, 58, 1, 80, 87, 17, 99, 86, 90, 72, 63, 32, 69, 14, 28, 88, 69}, {37, 17, 71, 95, 56, 93, 71, 35, 43, 45, 4, 98, 92, 94, 84, 96, 11, 30, 31, 27, 31, 60, 92, 3, 48, 5, 98, 91, 86, 94, 35, 90, 90, 8, 48, 19, 33, 28, 68, 37, 59, 26, 65, 96, 50, 68, 22, 7, 9, 49, 34, 31, 77, 49, 43, 6, 75, 17, 81, 87, 61, 79, 52, 26, 27, 72, 29, 50, 7, 98, 86, 1, 17, 10, 46, 64, 24, 18, 56}, {51, 30, 25, 94, 88, 85, 79, 91, 40, 33, 63, 84, 49, 67, 98, 92, 15, 26, 75, 19, 82, 5, 18, 78, 65, 93, 61, 48, 91, 43, 59, 41, 70, 51, 22, 15, 92, 81, 67, 91, 46, 98, 11, 11, 65, 31, 66, 10, 98, 65, 83, 21, 5, 56, 5, 98, 73, 67, 46, 74, 69, 34, 8, 30, 5, 52, 7, 98, 32, 95, 30, 94, 65, 50, 24, 63, 28, 81, 99, 57}, {19, 23, 61, 36, 9, 89, 71, 98, 65, 17, 30, 29, 89, 26, 79, 74, 94, 11, 44, 48, 97, 54, 81, 55, 39, 66, 69, 45, 28, 47, 13, 86, 15, 76, 74, 70, 84, 32, 36, 33, 79, 20, 78, 14, 41, 47, 89, 28, 81, 5, 99, 66, 81, 86, 38, 26, 6, 25, 13, 60, 54, 55, 23, 53, 27, 5, 89, 25, 23, 11, 13, 54, 59, 54, 56, 34, 16, 24, 53, 44, 6}, {13, 40, 57, 72, 21, 15, 60, 8, 4, 19, 11, 98, 34, 45, 9, 97, 86, 71, 3, 15, 56, 19, 15, 44, 97, 31, 90, 4, 87, 87, 76, 8, 12, 30, 24, 62, 84, 28, 12, 85, 82, 53, 99, 52, 13, 94, 6, 65, 97, 86, 9, 50, 94, 68, 69, 74, 30, 67, 87, 94, 63, 7, 78, 27, 80, 36, 69, 41, 6, 92, 32, 78, 37, 82, 30, 5, 18, 87, 99, 72, 19, 99}, {44, 20, 55, 77, 69, 91, 27, 31, 28, 81, 80, 27, 2, 7, 97, 23, 95, 98, 12, 25, 75, 29, 47, 71, 7, 47, 78, 39, 41, 59, 27, 76, 13, 15, 66, 61, 68, 35, 69, 86, 16, 53, 67, 63, 99, 85, 41, 56, 8, 28, 33, 40, 94, 76, 90, 85, 31, 70, 24, 65, 84, 65, 99, 82, 19, 25, 54, 37, 21, 46, 33, 2, 52, 99, 51, 33, 26, 4, 87, 2, 8, 18, 96}, {54, 42, 61, 45, 91, 6, 64, 79, 80, 82, 32, 16, 83, 63, 42, 49, 19, 78, 65, 97, 40, 42, 14, 61, 49, 34, 4, 18, 25, 98, 59, 30, 82, 72, 26, 88, 54, 36, 21, 75, 3, 88, 99, 53, 46, 51, 55, 78, 22, 94, 34, 40, 68, 87, 84, 25, 30, 76, 25, 8, 92, 84, 42, 61, 40, 38, 9, 99, 40, 23, 29, 39, 46, 55, 10, 90, 35, 84, 56, 70, 63, 23, 91, 39}, {52, 92, 3, 71, 89, 7, 9, 37, 68, 66, 58, 20, 44, 92, 51, 56, 13, 71, 79, 99, 26, 37, 2, 6, 16, 67, 36, 52, 58, 16, 79, 73, 56, 60, 59, 27, 44, 77, 94, 82, 20, 50, 98, 33, 9, 87, 94, 37, 40, 83, 64, 83, 58, 85, 17, 76, 53, 2, 83, 52, 22, 27, 39, 20, 48, 92, 45, 21, 9, 42, 24, 23, 12, 37, 52, 28, 50, 78, 79, 20, 86, 62, 73, 20, 59}, {54, 96, 80, 15, 91, 90, 99, 70, 10, 9, 58, 90, 93, 50, 81, 99, 54, 38, 36, 10, 30, 11, 35, 84, 16, 45, 82, 18, 11, 97, 36, 43, 96, 79, 97, 65, 40, 48, 23, 19, 17, 31, 64, 52, 65, 65, 37, 32, 65, 76, 99, 79, 34, 65, 79, 27, 55, 33, 3, 1, 33, 27, 61, 28, 66, 8, 4, 70, 49, 46, 48, 83, 1, 45, 19, 96, 13, 81, 14, 21, 31, 79, 93, 85, 50, 5}, {92, 92, 48, 84, 59, 98, 31, 53, 23, 27, 15, 22, 79, 95, 24, 76, 5, 79, 16, 93, 97, 89, 38, 89, 42, 83, 2, 88, 94, 95, 82, 21, 1, 97, 48, 39, 31, 78, 9, 65, 50, 56, 97, 61, 1, 7, 65, 27, 21, 23, 14, 15, 80, 97, 44, 78, 49, 35, 33, 45, 81, 74, 34, 5, 31, 57, 9, 38, 94, 7, 69, 54, 69, 32, 65, 68, 46, 68, 78, 90, 24, 28, 49, 51, 45, 86, 35}, {41, 63, 89, 76, 87, 31, 86, 9, 46, 14, 87, 82, 22, 29, 47, 16, 13, 10, 70, 72, 82, 95, 48, 64, 58, 43, 13, 75, 42, 69, 21, 12, 67, 13, 64, 85, 58, 23, 98, 9, 37, 76, 5, 22, 31, 12, 66, 50, 29, 99, 86, 72, 45, 25, 10, 28, 19, 6, 90, 43, 29, 31, 67, 79, 46, 25, 74, 14, 97, 35, 76, 37, 65, 46, 23, 82, 6, 22, 30, 76, 93, 66, 94, 17, 96, 13, 20, 72}, {63, 40, 78, 8, 52, 9, 90, 41, 70, 28, 36, 14, 46, 44, 85, 96, 24, 52, 58, 15, 87, 37, 5, 98, 99, 39, 13, 61, 76, 38, 44, 99, 83, 74, 90, 22, 53, 80, 56, 98, 30, 51, 63, 39, 44, 30, 91, 91, 4, 22, 27, 73, 17, 35, 53, 18, 35, 45, 54, 56, 27, 78, 48, 13, 69, 36, 44, 38, 71, 25, 30, 56, 15, 22, 73, 43, 32, 69, 59, 25, 93, 83, 45, 11, 34, 94, 44, 39, 92}, {12, 36, 56, 88, 13, 96, 16, 12, 55, 54, 11, 47, 19, 78, 17, 17, 68, 81, 77, 51, 42, 55, 99, 85, 66, 27, 81, 79, 93, 42, 65, 61, 69, 74, 14, 1, 18, 56, 12, 1, 58, 37, 91, 22, 42, 66, 83, 25, 19, 4, 96, 41, 25, 45, 18, 69, 96, 88, 36, 93, 10, 12, 98, 32, 44, 83, 83, 4, 72, 91, 4, 27, 73, 7, 34, 37, 71, 60, 59, 31, 1, 54, 54, 44, 96, 93, 83, 36, 4, 45}, {30, 18, 22, 20, 42, 96, 65, 79, 17, 41, 55, 69, 94, 81, 29, 80, 91, 31, 85, 25, 47, 26, 43, 49, 2, 99, 34, 67, 99, 76, 16, 14, 15, 93, 8, 32, 99, 44, 61, 77, 67, 50, 43, 55, 87, 55, 53, 72, 17, 46, 62, 25, 50, 99, 73, 5, 93, 48, 17, 31, 70, 80, 59, 9, 44, 59, 45, 13, 74, 66, 58, 94, 87, 73, 16, 14, 85, 38, 74, 99, 64, 23, 79, 28, 71, 42, 20, 37, 82, 31, 23}, {51, 96, 39, 65, 46, 71, 56, 13, 29, 68, 53, 86, 45, 33, 51, 49, 12, 91, 21, 21, 76, 85, 2, 17, 98, 15, 46, 12, 60, 21, 88, 30, 92, 83, 44, 59, 42, 50, 27, 88, 46, 86, 94, 73, 45, 54, 23, 24, 14, 10, 94, 21, 20, 34, 23, 51, 4, 83, 99, 75, 90, 63, 60, 16, 22, 33, 83, 70, 11, 32, 10, 50, 29, 30, 83, 46, 11, 5, 31, 17, 86, 42, 49, 1, 44, 63, 28, 60, 7, 78, 95, 40}, {44, 61, 89, 59, 4, 49, 51, 27, 69, 71, 46, 76, 44, 4, 9, 34, 56, 39, 15, 6, 94, 91, 75, 90, 65, 27, 56, 23, 74, 6, 23, 33, 36, 69, 14, 39, 5, 34, 35, 57, 33, 22, 76, 46, 56, 10, 61, 65, 98, 9, 16, 69, 4, 62, 65, 18, 99, 76, 49, 18, 72, 66, 73, 83, 82, 40, 76, 31, 89, 91, 27, 88, 17, 35, 41, 35, 32, 51, 32, 67, 52, 68, 74, 85, 80, 57, 7, 11, 62, 66, 47, 22, 67}, {65, 37, 19, 97, 26, 17, 16, 24, 24, 17, 50, 37, 64, 82, 24, 36, 32, 11, 68, 34, 69, 31, 32, 89, 79, 93, 96, 68, 49, 90, 14, 23, 4, 4, 67, 99, 81, 74, 70, 74, 36, 96, 68, 9, 64, 39, 88, 35, 54, 89, 96, 58, 66, 27, 88, 97, 32, 14, 6, 35, 78, 20, 71, 6, 85, 66, 57, 2, 58, 91, 72, 5, 29, 56, 73, 48, 86, 52, 9, 93, 22, 57, 79, 42, 12, 1, 31, 68, 17, 59, 63, 76, 7, 77}, {73, 81, 14, 13, 17, 20, 11, 9, 1, 83, 8, 85, 91, 70, 84, 63, 62, 77, 37, 7, 47, 1, 59, 95, 39, 69, 39, 21, 99, 9, 87, 2, 97, 16, 92, 36, 74, 71, 90, 66, 33, 73, 73, 75, 52, 91, 11, 12, 26, 53, 5, 26, 26, 48, 61, 50, 90, 65, 1, 87, 42, 47, 74, 35, 22, 73, 24, 26, 56, 70, 52, 5, 48, 41, 31, 18, 83, 27, 21, 39, 80, 85, 26, 8, 44, 2, 71, 7, 63, 22, 5, 52, 19, 8, 20}, {17, 25, 21, 11, 72, 93, 33, 49, 64, 23, 53, 82, 3, 13, 91, 65, 85, 2, 40, 5, 42, 31, 77, 42, 5, 36, 6, 54, 4, 58, 7, 76, 87, 83, 25, 57, 66, 12, 74, 33, 85, 37, 74, 32, 20, 69, 3, 97, 91, 68, 82, 44, 19, 14, 89, 28, 85, 85, 80, 53, 34, 87, 58, 98, 88, 78, 48, 65, 98, 40, 11, 57, 10, 67, 70, 81, 60, 79, 74, 72, 97, 59, 79, 47, 30, 20, 54, 80, 89, 91, 14, 5, 33, 36, 79, 39}, {60, 85, 59, 39, 60, 7, 57, 76, 77, 92, 6, 35, 15, 72, 23, 41, 45, 52, 95, 18, 64, 79, 86, 53, 56, 31, 69, 11, 91, 31, 84, 50, 44, 82, 22, 81, 41, 40, 30, 42, 30, 91, 48, 94, 74, 76, 64, 58, 74, 25, 96, 57, 14, 19, 3, 99, 28, 83, 15, 75, 99, 1, 89, 85, 79, 50, 3, 95, 32, 67, 44, 8, 7, 41, 62, 64, 29, 20, 14, 76, 26, 55, 48, 71, 69, 66, 19, 72, 44, 25, 14, 1, 48, 74, 12, 98, 7}, {64, 66, 84, 24, 18, 16, 27, 48, 20, 14, 47, 69, 30, 86, 48, 40, 23, 16, 61, 21, 51, 50, 26, 47, 35, 33, 91, 28, 78, 64, 43, 68, 4, 79, 51, 8, 19, 60, 52, 95, 6, 68, 46, 86, 35, 97, 27, 58, 4, 65, 30, 58, 99, 12, 12, 75, 91, 39, 50, 31, 42, 64, 70, 4, 46, 7, 98, 73, 98, 93, 37, 89, 77, 91, 64, 71, 64, 65, 66, 21, 78, 62, 81, 74, 42, 20, 83, 70, 73, 95, 78, 45, 92, 27, 34, 53, 71, 15}, {30, 11, 85, 31, 34, 71, 13, 48, 5, 14, 44, 3, 19, 67, 23, 73, 19, 57, 6, 90, 94, 72, 57, 69, 81, 62, 59, 68, 88, 57, 55, 69, 49, 13, 7, 87, 97, 80, 89, 5, 71, 5, 5, 26, 38, 40, 16, 62, 45, 99, 18, 38, 98, 24, 21, 26, 62, 74, 69, 4, 85, 57, 77, 35, 58, 67, 91, 79, 79, 57, 86, 28, 66, 34, 72, 51, 76, 78, 36, 95, 63, 90, 8, 78, 47, 63, 45, 31, 22, 70, 52, 48, 79, 94, 15, 77, 61, 67, 68}, {23, 33, 44, 81, 80, 92, 93, 75, 94, 88, 23, 61, 39, 76, 22, 3, 28, 94, 32, 6, 49, 65, 41, 34, 18, 23, 8, 47, 62, 60, 3, 63, 33, 13, 80, 52, 31, 54, 73, 43, 70, 26, 16, 69, 57, 87, 83, 31, 3, 93, 70, 81, 47, 95, 77, 44, 29, 68, 39, 51, 56, 59, 63, 7, 25, 70, 7, 77, 43, 53, 64, 3, 94, 42, 95, 39, 18, 1, 66, 21, 16, 97, 20, 50, 90, 16, 70, 10, 95, 69, 29, 6, 25, 61, 41, 26, 15, 59, 63, 35}};
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p067().run());
}

public String run() {
    for (int i = triangle.length - 2; i >= 0; --i) {
        for (int j = 0; j < triangle[i].length; ++j) triangle[i][j] += Math.max(triangle[i + 1][j], triangle[i + 1][j + 1]);
    }
    return Integer.toString(triangle[0][0]);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p068().run());
}

public String run() {
    int[] state = new int[10];
    for (int i = 0; i < state.length; ++i) state[i] = i + 1;
    String max = null;
    do {
        int sum = state[0] + state[5] + state[6];
        if (state[1] + state[6] + state[7] != sum || state[2] + state[7] + state[8] != sum || state[3] + state[8] + state[9] != sum || state[4] + state[9] + state[5] != sum) continue;
        int minOuterIndex = -1;
        int minOuter = Integer.MAX_VALUE;
        for (int i = 0; i < 5; ++i) {
            if (state[i] < minOuter) {
                minOuterIndex = i;
                minOuter = state[i];
            }
        }
        String s = "";
        for (int i = 0; i < 5; ++i) s += "" + state[(minOuterIndex + i) % 5] + state[(minOuterIndex + i) % 5 + 5] + state[(minOuterIndex + i + 1) % 5 + 5];
        if (s.length() == 16 && (max == null || s.compareTo(max) > 0)) max = s;
    }     while (Library.nextPermutation(state));
    if (max == null) throw new AssertionError();
    return max;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p069().run());
}

public String run() {
    int maxNumer = 0;
    int maxDenom = 1;
    int[] totients = Library.listTotients(LIMIT);
    for (int n = 1; n < totients.length; ++n) {
        if ((long)n * maxDenom > (long)maxNumer * totients[n]) {
            maxNumer = n;
            maxDenom = totients[n];
        }
    }
    return Integer.toString(maxNumer);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p070().run());
}

public String run() {
    int minNumer = 1;
    int minDenom = 0;
    int[] totients = Library.listTotients(LIMIT - 1);
    for (int n = 2; n < totients.length; ++n) {
        int tot = totients[n];
        if ((long)n * minDenom < (long)minNumer * tot && hasSameDigits(n, tot)) {
            minNumer = n;
            minDenom = tot;
        }
    }
    if (minDenom == 0) throw new RuntimeException("Not found");
    return Integer.toString(minNumer);
}

private static boolean hasSameDigits(int x, int y) {
    char[] xdigits = Integer.toString(x).toCharArray();
    char[] ydigits = Integer.toString(y).toCharArray();
    Arrays.sort(xdigits);
    Arrays.sort(ydigits);
    return Arrays.equals(xdigits, ydigits);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p071().run());
}

public String run() {
    int maxN = 0;
    int maxD = 1;
    for (int d = 2; d <= 1000000; ++d) {
        int n = d * 3 / 7;
        if (d % 7 == 0) --n;
        if ((long)n * maxD > (long)maxN * d) {
            maxN = n;
            maxD = d;
        }
    }
    return Integer.toString(maxN);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p072().run());
}

public String run() {
    long sum = 0;
    int[] totients = Library.listTotients(LIMIT);
    for (int i = 2; i < totients.length; ++i) sum += totients[i];
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p073().run());
}

public String run() {
    return Integer.toString(sternBrocotCount(1, 3, 1, 2));
}

private static int sternBrocotCount(int leftN, int leftD, int rightN, int rightD) {
    int n = leftN + rightN;
    int d = leftD + rightD;
    if (d > 12000) return 0; else return 1 + sternBrocotCount(leftN, leftD, n, d) + sternBrocotCount(n, d, rightN, rightD);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p074().run());
}

public String run() {
    int count = 0;
    for (int i = 0; i < LIMIT; ++i) {
        if (getChainLength(i) == 60) ++count;
    }
    return Integer.toString(count);
}

private static int getChainLength(int n) {
    Set seen = new HashSet();
    while (true) {
        if (!seen.add(Integer.valueOf(n))) return seen.size();
        n = factorialize(n);
    }
}

private static int factorialize(int n) {
    int sum = 0;
    for (; n != 0; n /= 10) sum += FACTORIAL[n % 10];
    return sum;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p075().run());
}

public String run() {
    Set triples = new HashSet();
    for (int s = 3; s * s <= LIMIT; s += 2) {
        for (int t = s - 2; t > 0; t -= 2) {
            if (Library.gcd(s, t) == 1) {
                int a = s * t;
                int b = (s * s - t * t) / 2;
                int c = (s * s + t * t) / 2;
                if (a + b + c <= LIMIT) triples.add(new p075$IntTriple(a, b, c));
            }
        }
    }
    byte[] ways = new byte[LIMIT + 1];
    for (/*synthetic*/ java.util.Iterator i$ = triples.iterator(); i$.hasNext(); ) {
        p075$IntTriple triple = (p075$IntTriple)i$.next();
        {
            int sum = triple.a + triple.b + triple.c;
            for (int i = sum; i < ways.length; i += sum) ways[i] = (byte)Math.min(ways[i] + 1, 2);
        }
    }
    int count = 0;
    for (/*synthetic*/ byte[] arr$ = ways, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        {
            if (x == 1) ++count;
        }
    }
    return Integer.toString(count);
}

public <init>(int a, int b, int c) {
    super();
    this.a = a;
    this.b = b;
    this.c = c;
}
STATEMENT:
super();
STATEMENT:
this.a = a;
STATEMENT:
this.b = b;
STATEMENT:
this.c = c;

public boolean equals(Object obj) {
    if (!(obj instanceof p075$IntTriple)) return false; else {
        p075$IntTriple other = (p075$IntTriple)(p075$IntTriple)obj;
        return a == other.a && b == other.b && c == other.c;
    }
}

public int hashCode() {
    return a + b + c;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p076().run());
}

public String run() {
    return partitions(100, 1).subtract(BigInteger.ONE).toString();
}

private static BigInteger partitions(int n, int k) {
    BigInteger[][] table = new BigInteger[n + 1][n + 1];
    for (int i = 0; i <= n; ++i) {
        for (int j = n; j >= 0; --j) {
            if (j == i) table[i][j] = BigInteger.ONE; else if (j > i) table[i][j] = BigInteger.ZERO; else if (j == 0) table[i][j] = table[i][j + 1]; else table[i][j] = table[i][j + 1].add(table[i - j][j]);
        }
    }
    return table[n][k];
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p077().run());
}

public String run() {
    for (int limit = 1; ; limit *= 2) {
        int result = search(limit, TARGET);
        if (result != -1) return Integer.toString(result);
    }
}

private static int search(int limit, int target) {
    int[] partitions = new int[limit];
    partitions[0] = 1;
    for (int i = 0; i < partitions.length; ++i) {
        if (!Library.isPrime(i)) continue;
        for (int j = i; j < partitions.length; ++j) partitions[j] += partitions[j - i];
    }
    for (int i = 0; i < limit; ++i) {
        if (partitions[i] > target) return i;
    }
    return -1;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p078().run());
}

public String run() {
    for (int limit = 1; ; limit *= 2) {
        int result = search(limit);
        if (result != -1) return Integer.toString(result);
    }
}

private static int search(int limit) {
    int[] partitions = new int[limit];
    partitions[0] = 1;
    for (int i = 1; i < limit; ++i) {
        for (int j = i; j < limit; ++j) partitions[j] = (partitions[j] + partitions[j - i]) % MODULUS;
    }
    for (int i = 0; i < limit; ++i) {
        if (partitions[i] == 0) return i;
    }
    return -1;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p079().run());
}

public String run() {
    packedSubseqs = new char[SUBSEQS.length * 3];
    for (int i = 0; i < packedSubseqs.length; ++i) packedSubseqs[i] = SUBSEQS[i / 3].charAt(i % 3);
    for (int len = 3; len <= 10; ++len) {
        int end = Library.pow(10, len);
        for (int guess = 0; guess < end; ++guess) {
            char[] guessChars = toChars(guess, len);
            if (isConsistent(guessChars)) return new String(guessChars);
        }
    }
    throw new RuntimeException("Not found");
}

private boolean isConsistent(char[] guess) {
    for (int i = 0; i < packedSubseqs.length; i += 3) {
        int j = 0;
        for (int k = 0; k < guess.length && j < 3; ++k) {
            if (guess[k] == packedSubseqs[i + j]) ++j;
        }
        if (j < 3) return false;
    }
    return true;
}

private static char[] toChars(int n, int len) {
    char[] result = new char[len];
    int i = 0;
    for (; i < result.length; ++i, n /= 10) result[i] = (char)('0' + (n % 10));
    if (n != 0) throw new IllegalArgumentException();
    for (; i < result.length; ++i) result[i] = '0';
    return result;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p080().run());
}

public String run() {
    int sum = 0;
    for (int i = 1; i <= 100; ++i) {
        BigInteger x = BigInteger.valueOf(i);
        x = x.multiply(BigInteger.TEN.pow(100 * 2));
        BigInteger y = sqrt(x);
        if (!y.multiply(y).equals(x)) {
            String s = y.toString().substring(0, 100);
            for (int j = 0; j < s.length(); ++j) sum += s.charAt(j) - '0';
        }
    }
    return Integer.toString(sum);
}

private static BigInteger sqrt(BigInteger x) {
    int i = 0;
    while (BigInteger.TEN.pow(i * 2).compareTo(x) <= 0) ++i;
    BigInteger y = BigInteger.ZERO;
    for (; i >= 0; --i) {
        int j;
        BigInteger delta = null;
        for (j = 9; j >= 0; --j) {
            BigInteger temp = BigInteger.valueOf(j).multiply(BigInteger.TEN.pow(i));
            delta = y.shiftLeft(1).add(temp).multiply(temp);
            if (delta.compareTo(x) <= 0) break;
        }
        if (j < 0) throw new AssertionError();
        x = x.subtract(delta);
        y = y.add(BigInteger.valueOf(j).multiply(BigInteger.TEN.pow(i)));
    }
    return y;
}

public <init>() {
    super();
    grid = {{4445, 2697, 5115, 718, 2209, 2212, 654, 4348, 3079, 6821, 7668, 3276, 8874, 4190, 3785, 2752, 9473, 7817, 9137, 496, 7338, 3434, 7152, 4355, 4552, 7917, 7827, 2460, 2350, 691, 3514, 5880, 3145, 7633, 7199, 3783, 5066, 7487, 3285, 1084, 8985, 760, 872, 8609, 8051, 1134, 9536, 5750, 9716, 9371, 7619, 5617, 275, 9721, 2997, 2698, 1887, 8825, 6372, 3014, 2113, 7122, 7050, 6775, 5948, 2758, 1219, 3539, 348, 7989, 2735, 9862, 1263, 8089, 6401, 9462, 3168, 2758, 3748, 5870}, {1096, 20, 1318, 7586, 5167, 2642, 1443, 5741, 7621, 7030, 5526, 4244, 2348, 4641, 9827, 2448, 6918, 5883, 3737, 300, 7116, 6531, 567, 5997, 3971, 6623, 820, 6148, 3287, 1874, 7981, 8424, 7672, 7575, 6797, 6717, 1078, 5008, 4051, 8795, 5820, 346, 1851, 6463, 2117, 6058, 3407, 8211, 117, 4822, 1317, 4377, 4434, 5925, 8341, 4800, 1175, 4173, 690, 8978, 7470, 1295, 3799, 8724, 3509, 9849, 618, 3320, 7068, 9633, 2384, 7175, 544, 6583, 1908, 9983, 481, 4187, 9353, 9377}, {9607, 7385, 521, 6084, 1364, 8983, 7623, 1585, 6935, 8551, 2574, 8267, 4781, 3834, 2764, 2084, 2669, 4656, 9343, 7709, 2203, 9328, 8004, 6192, 5856, 3555, 2260, 5118, 6504, 1839, 9227, 1259, 9451, 1388, 7909, 5733, 6968, 8519, 9973, 1663, 5315, 7571, 3035, 4325, 4283, 2304, 6438, 3815, 9213, 9806, 9536, 196, 5542, 6907, 2475, 1159, 5820, 9075, 9470, 2179, 9248, 1828, 4592, 9167, 3713, 4640, 47, 3637, 309, 7344, 6955, 346, 378, 9044, 8635, 7466, 5036, 9515, 6385, 9230}, {7206, 3114, 7760, 1094, 6150, 5182, 7358, 7387, 4497, 955, 101, 1478, 7777, 6966, 7010, 8417, 6453, 4955, 3496, 107, 449, 8271, 131, 2948, 6185, 784, 5937, 8001, 6104, 8282, 4165, 3642, 710, 2390, 575, 715, 3089, 6964, 4217, 192, 5949, 7006, 715, 3328, 1152, 66, 8044, 4319, 1735, 146, 4818, 5456, 6451, 4113, 1063, 4781, 6799, 602, 1504, 6245, 6550, 1417, 1343, 2363, 3785, 5448, 4545, 9371, 5420, 5068, 4613, 4882, 4241, 5043, 7873, 8042, 8434, 3939, 9256, 2187}, {3620, 8024, 577, 9997, 7377, 7682, 1314, 1158, 6282, 6310, 1896, 2509, 5436, 1732, 9480, 706, 496, 101, 6232, 7375, 2207, 2306, 110, 6772, 3433, 2878, 8140, 5933, 8688, 1399, 2210, 7332, 6172, 6403, 7333, 4044, 2291, 1790, 2446, 7390, 8698, 5723, 3678, 7104, 1825, 2040, 140, 3982, 4905, 4160, 2200, 5041, 2512, 1488, 2268, 1175, 7588, 8321, 8078, 7312, 977, 5257, 8465, 5068, 3453, 3096, 1651, 7906, 253, 9250, 6021, 8791, 8109, 6651, 3412, 345, 4778, 5152, 4883, 7505}, {1074, 5438, 9008, 2679, 5397, 5429, 2652, 3403, 770, 9188, 4248, 2493, 4361, 8327, 9587, 707, 9525, 5913, 93, 1899, 328, 2876, 3604, 673, 8576, 6908, 7659, 2544, 3359, 3883, 5273, 6587, 3065, 1749, 3223, 604, 9925, 6941, 2823, 8767, 7039, 3290, 3214, 1787, 7904, 3421, 7137, 9560, 8451, 2669, 9219, 6332, 1576, 5477, 6755, 8348, 4164, 4307, 2984, 4012, 6629, 1044, 2874, 6541, 4942, 903, 1404, 9125, 5160, 8836, 4345, 2581, 460, 8438, 1538, 5507, 668, 3352, 2678, 6942}, {4295, 1176, 5596, 1521, 3061, 9868, 7037, 7129, 8933, 6659, 5947, 5063, 3653, 9447, 9245, 2679, 767, 714, 116, 8558, 163, 3927, 8779, 158, 5093, 2447, 5782, 3967, 1716, 931, 7772, 8164, 1117, 9244, 5783, 7776, 3846, 8862, 6014, 2330, 6947, 1777, 3112, 6008, 3491, 1906, 5952, 314, 4602, 8994, 5919, 9214, 3995, 5026, 7688, 6809, 5003, 3128, 2509, 7477, 110, 8971, 3982, 8539, 2980, 4689, 6343, 5411, 2992, 5270, 5247, 9260, 2269, 7474, 1042, 7162, 5206, 1232, 4556, 4757}, {510, 3556, 5377, 1406, 5721, 4946, 2635, 7847, 4251, 8293, 8281, 6351, 4912, 287, 2870, 3380, 3948, 5322, 3840, 4738, 9563, 1906, 6298, 3234, 8959, 1562, 6297, 8835, 7861, 239, 6618, 1322, 2553, 2213, 5053, 5446, 4402, 6500, 5182, 8585, 6900, 5756, 9661, 903, 5186, 7687, 5998, 7997, 8081, 8955, 4835, 6069, 2621, 1581, 732, 9564, 1082, 1853, 5442, 1342, 520, 1737, 3703, 5321, 4793, 2776, 1508, 1647, 9101, 2499, 6891, 4336, 7012, 3329, 3212, 1442, 9993, 3988, 4930, 7706}, {9444, 3401, 5891, 9716, 1228, 7107, 109, 3563, 2700, 6161, 5039, 4992, 2242, 8541, 7372, 2067, 1294, 3058, 1306, 320, 8881, 5756, 9326, 411, 8650, 8824, 5495, 8282, 8397, 2000, 1228, 7817, 2099, 6473, 3571, 5994, 4447, 1299, 5991, 543, 7874, 2297, 1651, 101, 2093, 3463, 9189, 6872, 6118, 872, 1008, 1779, 2805, 9084, 4048, 2123, 5877, 55, 3075, 1737, 9459, 4535, 6453, 3644, 108, 5982, 4437, 5213, 1340, 6967, 9943, 5815, 669, 8074, 1838, 6979, 9132, 9315, 715, 5048}, {3327, 4030, 7177, 6336, 9933, 5296, 2621, 4785, 2755, 4832, 2512, 2118, 2244, 4407, 2170, 499, 7532, 9742, 5051, 7687, 970, 6924, 3527, 4694, 5145, 1306, 2165, 5940, 2425, 8910, 3513, 1909, 6983, 346, 6377, 4304, 9330, 7203, 6605, 3709, 3346, 970, 369, 9737, 5811, 4427, 9939, 3693, 8436, 5566, 1977, 3728, 2399, 3985, 8303, 2492, 5366, 9802, 9193, 7296, 1033, 5060, 9144, 2766, 1151, 7629, 5169, 5995, 58, 7619, 7565, 4208, 1713, 6279, 3209, 4908, 9224, 7409, 1325, 8540}, {6882, 1265, 1775, 3648, 4690, 959, 5837, 4520, 5394, 1378, 9485, 1360, 4018, 578, 9174, 2932, 9890, 3696, 116, 1723, 1178, 9355, 7063, 1594, 1918, 8574, 7594, 7942, 1547, 6166, 7888, 354, 6932, 4651, 1010, 7759, 6905, 661, 7689, 6092, 9292, 3845, 9605, 8443, 443, 8275, 5163, 7720, 7265, 6356, 7779, 1798, 1754, 5225, 6661, 1180, 8024, 5666, 88, 9153, 1840, 3508, 1193, 4445, 2648, 3538, 6243, 6375, 8107, 5902, 5423, 2520, 1122, 5015, 6113, 8859, 9370, 966, 8673, 2442}, {7338, 3423, 4723, 6533, 848, 8041, 7921, 8277, 4094, 5368, 7252, 8852, 9166, 2250, 2801, 6125, 8093, 5738, 4038, 9808, 7359, 9494, 601, 9116, 4946, 2702, 5573, 2921, 9862, 1462, 1269, 2410, 4171, 2709, 7508, 6241, 7522, 615, 2407, 8200, 4189, 5492, 5649, 7353, 2590, 5203, 4274, 710, 7329, 9063, 956, 8371, 3722, 4253, 4785, 1194, 4828, 4717, 4548, 940, 983, 2575, 4511, 2938, 1827, 2027, 2700, 1236, 841, 5760, 1680, 6260, 2373, 3851, 1841, 4968, 1172, 5179, 7175, 3509}, {4420, 1327, 3560, 2376, 6260, 2988, 9537, 4064, 4829, 8872, 9598, 3228, 1792, 7118, 9962, 9336, 4368, 9189, 6857, 1829, 9863, 6287, 7303, 7769, 2707, 8257, 2391, 2009, 3975, 4993, 3068, 9835, 3427, 341, 8412, 2134, 4034, 8511, 6421, 3041, 9012, 2983, 7289, 100, 1355, 7904, 9186, 6920, 5856, 2008, 6545, 8331, 3655, 5011, 839, 8041, 9255, 6524, 3862, 8788, 62, 7455, 3513, 5003, 8413, 3918, 2076, 7960, 6108, 3638, 6999, 3436, 1441, 4858, 4181, 1866, 8731, 7745, 3744, 1000}, {356, 8296, 8325, 1058, 1277, 4743, 3850, 2388, 6079, 6462, 2815, 5620, 8495, 5378, 75, 4324, 3441, 9870, 1113, 165, 1544, 1179, 2834, 562, 6176, 2313, 6836, 8839, 2986, 9454, 5199, 6888, 1927, 5866, 8760, 320, 1792, 8296, 7898, 6121, 7241, 5886, 5814, 2815, 8336, 1576, 4314, 3109, 2572, 6011, 2086, 9061, 9403, 3947, 5487, 9731, 7281, 3159, 1819, 1334, 3181, 5844, 5114, 9898, 4634, 2531, 4412, 6430, 4262, 8482, 4546, 4555, 6804, 2607, 9421, 686, 8649, 8860, 7794, 6672}, {9870, 152, 1558, 4963, 8750, 4754, 6521, 6256, 8818, 5208, 5691, 9659, 8377, 9725, 5050, 5343, 2539, 6101, 1844, 9700, 7750, 8114, 5357, 3001, 8830, 4438, 199, 9545, 8496, 43, 2078, 327, 9397, 106, 6090, 8181, 8646, 6414, 7499, 5450, 4850, 6273, 5014, 4131, 7639, 3913, 6571, 8534, 9703, 4391, 7618, 445, 1320, 5, 1894, 6771, 7383, 9191, 4708, 9706, 6939, 7937, 8726, 9382, 5216, 3685, 2247, 9029, 8154, 1738, 9984, 2626, 9438, 4167, 6351, 5060, 29, 1218, 1239, 4785}, {192, 5213, 8297, 8974, 4032, 6966, 5717, 1179, 6523, 4679, 9513, 1481, 3041, 5355, 9303, 9154, 1389, 8702, 6589, 7818, 6336, 3539, 5538, 3094, 6646, 6702, 6266, 2759, 4608, 4452, 617, 9406, 8064, 6379, 444, 5602, 4950, 1810, 8391, 1536, 316, 8714, 1178, 5182, 5863, 5110, 5372, 4954, 1978, 2971, 5680, 4863, 2255, 4630, 5723, 2168, 538, 1692, 1319, 7540, 440, 6430, 6266, 7712, 7385, 5702, 620, 641, 3136, 7350, 1478, 3155, 2820, 9109, 6261, 1122, 4470, 14, 8493, 2095}, {1046, 4301, 6082, 474, 4974, 7822, 2102, 5161, 5172, 6946, 8074, 9716, 6586, 9962, 9749, 5015, 2217, 995, 5388, 4402, 7652, 6399, 6539, 1349, 8101, 3677, 1328, 9612, 7922, 2879, 231, 5887, 2655, 508, 4357, 4964, 3554, 5930, 6236, 7384, 4614, 280, 3093, 9600, 2110, 7863, 2631, 6626, 6620, 68, 1311, 7198, 7561, 1768, 5139, 1431, 221, 230, 2940, 968, 5283, 6517, 2146, 1646, 869, 9402, 7068, 8645, 7058, 1765, 9690, 4152, 2926, 9504, 2939, 7504, 6074, 2944, 6470, 7859}, {4659, 736, 4951, 9344, 1927, 6271, 8837, 8711, 3241, 6579, 7660, 5499, 5616, 3743, 5801, 4682, 9748, 8796, 779, 1833, 4549, 8138, 4026, 775, 4170, 2432, 4174, 3741, 7540, 8017, 2833, 4027, 396, 811, 2871, 1150, 9809, 2719, 9199, 8504, 1224, 540, 2051, 3519, 7982, 7367, 2761, 308, 3358, 6505, 2050, 4836, 5090, 7864, 805, 2566, 2409, 6876, 3361, 8622, 5572, 5895, 3280, 441, 7893, 8105, 1634, 2929, 274, 3926, 7786, 6123, 8233, 9921, 2674, 5340, 1445, 203, 4585, 3837}, {5759, 338, 7444, 7968, 7742, 3755, 1591, 4839, 1705, 650, 7061, 2461, 9230, 9391, 9373, 2413, 1213, 431, 7801, 4994, 2380, 2703, 6161, 6878, 8331, 2538, 6093, 1275, 5065, 5062, 2839, 582, 1014, 8109, 3525, 1544, 1569, 8622, 7944, 2905, 6120, 1564, 1839, 5570, 7579, 1318, 2677, 5257, 4418, 5601, 7935, 7656, 5192, 1864, 5886, 6083, 5580, 6202, 8869, 1636, 7907, 4759, 9082, 5854, 3185, 7631, 6854, 5872, 5632, 5280, 1431, 2077, 9717, 7431, 4256, 8261, 9680, 4487, 4752, 4286}, {1571, 1428, 8599, 1230, 7772, 4221, 8523, 9049, 4042, 8726, 7567, 6736, 9033, 2104, 4879, 4967, 6334, 6716, 3994, 1269, 8995, 6539, 3610, 7667, 6560, 6065, 874, 848, 4597, 1711, 7161, 4811, 6734, 5723, 6356, 6026, 9183, 2586, 5636, 1092, 7779, 7923, 8747, 6887, 7505, 9909, 1792, 3233, 4526, 3176, 1508, 8043, 720, 5212, 6046, 4988, 709, 5277, 8256, 3642, 1391, 5803, 1468, 2145, 3970, 6301, 7767, 2359, 8487, 9771, 8785, 7520, 856, 1605, 8972, 2402, 2386, 991, 1383, 5963}, {1822, 4824, 5957, 6511, 9868, 4113, 301, 9353, 6228, 2881, 2966, 6956, 9124, 9574, 9233, 1601, 7340, 973, 9396, 540, 4747, 8590, 9535, 3650, 7333, 7583, 4806, 3593, 2738, 8157, 5215, 8472, 2284, 9473, 3906, 6982, 5505, 6053, 7936, 6074, 7179, 6688, 1564, 1103, 6860, 5839, 2022, 8490, 910, 7551, 7805, 881, 7024, 1855, 9448, 4790, 1274, 3672, 2810, 774, 7623, 4223, 4850, 6071, 9975, 4935, 1915, 9771, 6690, 3846, 517, 463, 7624, 4511, 614, 6394, 3661, 7409, 1395, 8127}, {8738, 3850, 9555, 3695, 4383, 2378, 87, 6256, 6740, 7682, 9546, 4255, 6105, 2000, 1851, 4073, 8957, 9022, 6547, 5189, 2487, 303, 9602, 7833, 1628, 4163, 6678, 3144, 8589, 7096, 8913, 5823, 4890, 7679, 1212, 9294, 5884, 2972, 3012, 3359, 7794, 7428, 1579, 4350, 7246, 4301, 7779, 7790, 3294, 9547, 4367, 3549, 1958, 8237, 6758, 3497, 3250, 3456, 6318, 1663, 708, 7714, 6143, 6890, 3428, 6853, 9334, 7992, 591, 6449, 9786, 1412, 8500, 722, 5468, 1371, 108, 3939, 4199, 2535}, {7047, 4323, 1934, 5163, 4166, 461, 3544, 2767, 6554, 203, 6098, 2265, 9078, 2075, 4644, 6641, 8412, 9183, 487, 101, 7566, 5622, 1975, 5726, 2920, 5374, 7779, 5631, 3753, 3725, 2672, 3621, 4280, 1162, 5812, 345, 8173, 9785, 1525, 955, 5603, 2215, 2580, 5261, 2765, 2990, 5979, 389, 3907, 2484, 1232, 5933, 5871, 3304, 1138, 1616, 5114, 9199, 5072, 7442, 7245, 6472, 4760, 6359, 9053, 7876, 2564, 9404, 3043, 9026, 2261, 3374, 4460, 7306, 2326, 966, 828, 3274, 1712, 3446}, {3975, 4565, 8131, 5800, 4570, 2306, 8838, 4392, 9147, 11, 3911, 7118, 9645, 4994, 2028, 6062, 5431, 2279, 8752, 2658, 7836, 994, 7316, 5336, 7185, 3289, 1898, 9689, 2331, 5737, 3403, 1124, 2679, 3241, 7748, 16, 2724, 5441, 6640, 9368, 9081, 5618, 858, 4969, 17, 2103, 6035, 8043, 7475, 2181, 939, 415, 1617, 8500, 8253, 2155, 7843, 7974, 7859, 1746, 6336, 3193, 2617, 8736, 4079, 6324, 6645, 8891, 9396, 5522, 6103, 1857, 8979, 3835, 2475, 1310, 7422, 610, 8345, 7615}, {9248, 5397, 5686, 2988, 3446, 4359, 6634, 9141, 497, 9176, 6773, 7448, 1907, 8454, 916, 1596, 2241, 1626, 1384, 2741, 3649, 5362, 8791, 7170, 2903, 2475, 5325, 6451, 924, 3328, 522, 90, 4813, 9737, 9557, 691, 2388, 1383, 4021, 1609, 9206, 4707, 5200, 7107, 8104, 4333, 9860, 5013, 1224, 6959, 8527, 1877, 4545, 7772, 6268, 621, 4915, 9349, 5970, 706, 9583, 3071, 4127, 780, 8231, 3017, 9114, 3836, 7503, 2383, 1977, 4870, 8035, 2379, 9704, 1037, 3992, 3642, 1016, 4303}, {5093, 138, 4639, 6609, 1146, 5565, 95, 7521, 9077, 2272, 974, 4388, 2465, 2650, 722, 4998, 3567, 3047, 921, 2736, 7855, 173, 2065, 4238, 1048, 5, 6847, 9548, 8632, 9194, 5942, 4777, 7910, 8971, 6279, 7253, 2516, 1555, 1833, 3184, 9453, 9053, 6897, 7808, 8629, 4877, 1871, 8055, 4881, 7639, 1537, 7701, 2508, 7564, 5845, 5023, 2304, 5396, 3193, 2955, 1088, 3801, 6203, 1748, 3737, 1276, 13, 4120, 7715, 8552, 3047, 2921, 106, 7508, 304, 1280, 7140, 2567, 9135, 5266}, {6237, 4607, 7527, 9047, 522, 7371, 4883, 2540, 5867, 6366, 5301, 1570, 421, 276, 3361, 527, 6637, 4861, 2401, 7522, 5808, 9371, 5298, 2045, 5096, 5447, 7755, 5115, 7060, 8529, 4078, 1943, 1697, 1764, 5453, 7085, 960, 2405, 739, 2100, 5800, 728, 9737, 5704, 5693, 1431, 8979, 6428, 673, 7540, 6, 7773, 5857, 6823, 150, 5869, 8486, 684, 5816, 9626, 7451, 5579, 8260, 3397, 5322, 6920, 1879, 2127, 2884, 5478, 4977, 9016, 6165, 6292, 3062, 5671, 5968, 78, 4619, 4763}, {9905, 7127, 9390, 5185, 6923, 3721, 9164, 9705, 4341, 1031, 1046, 5127, 7376, 6528, 3248, 4941, 1178, 7889, 3364, 4486, 5358, 9402, 9158, 8600, 1025, 874, 1839, 1783, 309, 9030, 1843, 845, 8398, 1433, 7118, 70, 8071, 2877, 3904, 8866, 6722, 4299, 10, 1929, 5897, 4188, 600, 1889, 3325, 2485, 6473, 4474, 7444, 6992, 4846, 6166, 4441, 2283, 2629, 4352, 7775, 1101, 2214, 9985, 215, 8270, 9750, 2740, 8361, 7103, 5930, 8664, 9690, 8302, 9267, 344, 2077, 1372, 1880, 9550}, {5825, 8517, 7769, 2405, 8204, 1060, 3603, 7025, 478, 8334, 1997, 3692, 7433, 9101, 7294, 7498, 9415, 5452, 3850, 3508, 6857, 9213, 6807, 4412, 7310, 854, 5384, 686, 4978, 892, 8651, 3241, 2743, 3801, 3813, 8588, 6701, 4416, 6990, 6490, 3197, 6838, 6503, 114, 8343, 5844, 8646, 8694, 65, 791, 5979, 2687, 2621, 2019, 8097, 1423, 3644, 9764, 4921, 3266, 3662, 5561, 2476, 8271, 8138, 6147, 1168, 3340, 1998, 9874, 6572, 9873, 6659, 5609, 2711, 3931, 9567, 4143, 7833, 8887}, {6223, 2099, 2700, 589, 4716, 8333, 1362, 5007, 2753, 2848, 4441, 8397, 7192, 8191, 4916, 9955, 6076, 3370, 6396, 6971, 3156, 248, 3911, 2488, 4930, 2458, 7183, 5455, 170, 6809, 6417, 3390, 1956, 7188, 577, 7526, 2203, 968, 8164, 479, 8699, 7915, 507, 6393, 4632, 1597, 7534, 3604, 618, 3280, 6061, 9793, 9238, 8347, 568, 9645, 2070, 5198, 6482, 5000, 9212, 6655, 5961, 7513, 1323, 3872, 6170, 3812, 4146, 2736, 67, 3151, 5548, 2781, 9679, 7564, 5043, 8587, 1893, 4531}, {5826, 3690, 6724, 2121, 9308, 6986, 8106, 6659, 2142, 1642, 7170, 2877, 5757, 6494, 8026, 6571, 8387, 9961, 6043, 9758, 9607, 6450, 8631, 8334, 7359, 5256, 8523, 2225, 7487, 1977, 9555, 8048, 5763, 2414, 4948, 4265, 2427, 8978, 8088, 8841, 9208, 9601, 5810, 9398, 8866, 9138, 4176, 5875, 7212, 3272, 6759, 5678, 7649, 4922, 5422, 1343, 8197, 3154, 3600, 687, 1028, 4579, 2084, 9467, 4492, 7262, 7296, 6538, 7657, 7134, 2077, 1505, 7332, 6890, 8964, 4879, 7603, 7400, 5973, 739}, {1861, 1613, 4879, 1884, 7334, 966, 2000, 7489, 2123, 4287, 1472, 3263, 4726, 9203, 1040, 4103, 6075, 6049, 330, 9253, 4062, 4268, 1635, 9960, 577, 1320, 3195, 9628, 1030, 4092, 4979, 6474, 6393, 2799, 6967, 8687, 7724, 7392, 9927, 2085, 3200, 6466, 8702, 265, 7646, 8665, 7986, 7266, 4574, 6587, 612, 2724, 704, 3191, 8323, 9523, 3002, 704, 5064, 3960, 8209, 2027, 2758, 8393, 4875, 4641, 9584, 6401, 7883, 7014, 768, 443, 5490, 7506, 1852, 2005, 8850, 5776, 4487, 4269}, {4052, 6687, 4705, 7260, 6645, 6715, 3706, 5504, 8672, 2853, 1136, 8187, 8203, 4016, 871, 1809, 1366, 4952, 9294, 5339, 6872, 2645, 6083, 7874, 3056, 5218, 7485, 8796, 7401, 3348, 2103, 426, 8572, 4163, 9171, 3176, 948, 7654, 9344, 3217, 1650, 5580, 7971, 2622, 76, 2874, 880, 2034, 9929, 1546, 2659, 5811, 3754, 7096, 7436, 9694, 9960, 7415, 2164, 953, 2360, 4194, 2397, 1047, 2196, 6827, 575, 784, 2675, 8821, 6802, 7972, 5996, 6699, 2134, 7577, 2887, 1412, 4349, 4380}, {4629, 2234, 6240, 8132, 7592, 3181, 6389, 1214, 266, 1910, 2451, 8784, 2790, 1127, 6932, 1447, 8986, 2492, 5476, 397, 889, 3027, 7641, 5083, 5776, 4022, 185, 3364, 5701, 2442, 2840, 4160, 9525, 4828, 6602, 2614, 7447, 3711, 4505, 7745, 8034, 6514, 4907, 2605, 7753, 6958, 7270, 6936, 3006, 8968, 439, 2326, 4652, 3085, 3425, 9863, 5049, 5361, 8688, 297, 7580, 8777, 7916, 6687, 8683, 7141, 306, 9569, 2384, 1500, 3346, 4601, 7329, 9040, 6097, 2727, 6314, 4501, 4974, 2829}, {8316, 4072, 2025, 6884, 3027, 1808, 5714, 7624, 7880, 8528, 4205, 8686, 7587, 3230, 1139, 7273, 6163, 6986, 3914, 9309, 1464, 9359, 4474, 7095, 2212, 7302, 2583, 9462, 7532, 6567, 1606, 4436, 8981, 5612, 6796, 4385, 5076, 2007, 6072, 3678, 8331, 1338, 3299, 8845, 4783, 8613, 4071, 1232, 6028, 2176, 3990, 2148, 3748, 103, 9453, 538, 6745, 9110, 926, 3125, 473, 5970, 8728, 7072, 9062, 1404, 1317, 5139, 9862, 6496, 6062, 3338, 464, 1600, 2532, 1088, 8232, 7739, 8274, 3873}, {2341, 523, 7096, 8397, 8301, 6541, 9844, 244, 4993, 2280, 7689, 4025, 4196, 5522, 7904, 6048, 2623, 9258, 2149, 9461, 6448, 8087, 7245, 1917, 8340, 7127, 8466, 5725, 6996, 3421, 5313, 512, 9164, 9837, 9794, 8369, 4185, 1488, 7210, 1524, 1016, 4620, 9435, 2478, 7765, 8035, 697, 6677, 3724, 6988, 5853, 7662, 3895, 9593, 1185, 4727, 6025, 5734, 7665, 3070, 138, 8469, 6748, 6459, 561, 7935, 8646, 2378, 462, 7755, 3115, 9690, 8877, 3946, 2728, 8793, 244, 6323, 8666, 4271}, {6430, 2406, 8994, 56, 1267, 3826, 9443, 7079, 7579, 5232, 6691, 3435, 6718, 5698, 4144, 7028, 592, 2627, 217, 734, 6194, 8156, 9118, 58, 2640, 8069, 4127, 3285, 694, 3197, 3377, 4143, 4802, 3324, 8134, 6953, 7625, 3598, 3584, 4289, 7065, 3434, 2106, 7132, 5802, 7920, 9060, 7531, 3321, 1725, 1067, 3751, 444, 5503, 6785, 7937, 6365, 4803, 198, 6266, 8177, 1470, 6390, 1606, 2904, 7555, 9834, 8667, 2033, 1723, 5167, 1666, 8546, 8152, 473, 4475, 6451, 7947, 3062, 3281}, {2810, 3042, 7759, 1741, 2275, 2609, 7676, 8640, 4117, 1958, 7500, 8048, 1757, 3954, 9270, 1971, 4796, 2912, 660, 5511, 3553, 1012, 5757, 4525, 6084, 7198, 8352, 5775, 7726, 8591, 7710, 9589, 3122, 4392, 6856, 5016, 749, 2285, 3356, 7482, 9956, 7348, 2599, 8944, 495, 3462, 3578, 551, 4543, 7207, 7169, 7796, 1247, 4278, 6916, 8176, 3742, 8385, 2310, 1345, 8692, 2667, 4568, 1770, 8319, 3585, 4920, 3890, 4928, 7343, 5385, 9772, 7947, 8786, 2056, 9266, 3454, 2807, 877, 2660}, {6206, 8252, 5928, 5837, 4177, 4333, 207, 7934, 5581, 9526, 8906, 1498, 8411, 2984, 5198, 5134, 2464, 8435, 8514, 8674, 3876, 599, 5327, 826, 2152, 4084, 2433, 9327, 9697, 4800, 2728, 3608, 3849, 3861, 3498, 9943, 1407, 3991, 7191, 9110, 5666, 8434, 4704, 6545, 5944, 2357, 1163, 4995, 9619, 6754, 4200, 9682, 6654, 4862, 4744, 5953, 6632, 1054, 293, 9439, 8286, 2255, 696, 8709, 1533, 1844, 6441, 430, 1999, 6063, 9431, 7018, 8057, 2920, 6266, 6799, 356, 3597, 4024, 6665}, {3847, 6356, 8541, 7225, 2325, 2946, 5199, 469, 5450, 7508, 2197, 9915, 8284, 7983, 6341, 3276, 3321, 16, 1321, 7608, 5015, 3362, 8491, 6968, 6818, 797, 156, 2575, 706, 9516, 5344, 5457, 9210, 5051, 8099, 1617, 9951, 7663, 8253, 9683, 2670, 1261, 4710, 1068, 8753, 4799, 1228, 2621, 3275, 6188, 4699, 1791, 9518, 8701, 5932, 4275, 6011, 9877, 2933, 4182, 6059, 2930, 6687, 6682, 9771, 654, 9437, 3169, 8596, 1827, 5471, 8909, 2352, 123, 4394, 3208, 8756, 5513, 6917, 2056}, {5458, 8173, 3138, 3290, 4570, 4892, 3317, 4251, 9699, 7973, 1163, 1935, 5477, 6648, 9614, 5655, 9592, 975, 9118, 2194, 7322, 8248, 8413, 3462, 8560, 1907, 7810, 6650, 7355, 2939, 4973, 6894, 3933, 3784, 3200, 2419, 9234, 4747, 2208, 2207, 1945, 2899, 1407, 6145, 8023, 3484, 5688, 7686, 2737, 3828, 3704, 9004, 5190, 9740, 8643, 8650, 5358, 4426, 1522, 1707, 3613, 9887, 6956, 2447, 2762, 833, 1449, 9489, 2573, 1080, 4167, 3456, 6809, 2466, 227, 7125, 2759, 6250, 6472, 8089}, {3266, 7025, 9756, 3914, 1265, 9116, 7723, 9788, 6805, 5493, 2092, 8688, 6592, 9173, 4431, 4028, 6007, 7131, 4446, 4815, 3648, 6701, 759, 3312, 8355, 4485, 4187, 5188, 8746, 7759, 3528, 2177, 5243, 8379, 3838, 7233, 4607, 9187, 7216, 2190, 6967, 2920, 6082, 7910, 5354, 3609, 8958, 6949, 7731, 494, 8753, 8707, 1523, 4426, 3543, 7085, 647, 6771, 9847, 646, 5049, 824, 8417, 5260, 2730, 5702, 2513, 9275, 4279, 2767, 8684, 1165, 9903, 4518, 55, 9682, 8963, 6005, 2102, 6523}, {1998, 8731, 936, 1479, 5259, 7064, 4085, 91, 7745, 7136, 3773, 3810, 730, 8255, 2705, 2653, 9790, 6807, 2342, 355, 9344, 2668, 3690, 2028, 9679, 8102, 574, 4318, 6481, 9175, 5423, 8062, 2867, 9657, 7553, 3442, 3920, 7430, 3945, 7639, 3714, 3392, 2525, 4995, 4850, 2867, 7951, 9667, 486, 9506, 9888, 781, 8866, 1702, 3795, 90, 356, 1483, 4200, 2131, 6969, 5931, 486, 6880, 4404, 1084, 5169, 4910, 6567, 8335, 4686, 5043, 2614, 3352, 2667, 4513, 6472, 7471, 5720, 1616}, {8878, 1613, 1716, 868, 1906, 2681, 564, 665, 5995, 2474, 7496, 3432, 9491, 9087, 8850, 8287, 669, 823, 347, 6194, 2264, 2592, 7871, 7616, 8508, 4827, 760, 2676, 4660, 4881, 7572, 3811, 9032, 939, 4384, 929, 7525, 8419, 5556, 9063, 662, 8887, 7026, 8534, 3111, 1454, 2082, 7598, 5726, 6687, 9647, 7608, 73, 3014, 5063, 670, 5461, 5631, 3367, 9796, 8475, 7908, 5073, 1565, 5008, 5295, 4457, 1274, 4788, 1728, 338, 600, 8415, 8535, 9351, 7750, 6887, 5845, 1741, 125}, {3637, 6489, 9634, 9464, 9055, 2413, 7824, 9517, 7532, 3577, 7050, 6186, 6980, 9365, 9782, 191, 870, 2497, 8498, 2218, 2757, 5420, 6468, 586, 3320, 9230, 1034, 1393, 9886, 5072, 9391, 1178, 8464, 8042, 6869, 2075, 8275, 3601, 7715, 9470, 8786, 6475, 8373, 2159, 9237, 2066, 3264, 5000, 679, 355, 3069, 4073, 494, 2308, 5512, 4334, 9438, 8786, 8637, 9774, 1169, 1949, 6594, 6072, 4270, 9158, 7916, 5752, 6794, 9391, 6301, 5842, 3285, 2141, 3898, 8027, 4310, 8821, 7079, 1307}, {8497, 6681, 4732, 7151, 7060, 5204, 9030, 7157, 833, 5014, 8723, 3207, 9796, 9286, 4913, 119, 5118, 7650, 9335, 809, 3675, 2597, 5144, 3945, 5090, 8384, 187, 4102, 1260, 2445, 2792, 4422, 8389, 9290, 50, 1765, 1521, 6921, 8586, 4368, 1565, 5727, 7855, 2003, 4834, 9897, 5911, 8630, 5070, 1330, 7692, 7557, 7980, 6028, 5805, 9090, 8265, 3019, 3802, 698, 9149, 5748, 1965, 9658, 4417, 5994, 5584, 8226, 2937, 272, 5743, 1278, 5698, 8736, 2595, 6475, 5342, 6596, 1149, 6920}, {8188, 8009, 9546, 6310, 8772, 2500, 9846, 6592, 6872, 3857, 1307, 8125, 7042, 1544, 6159, 2330, 643, 4604, 7899, 6848, 371, 8067, 2062, 3200, 7295, 1857, 9505, 6936, 384, 2193, 2190, 301, 8535, 5503, 1462, 7380, 5114, 4824, 8833, 1763, 4974, 8711, 9262, 6698, 3999, 2645, 6937, 7747, 1128, 2933, 3556, 7943, 2885, 3122, 9105, 5447, 418, 2899, 5148, 3699, 9021, 9501, 597, 4084, 175, 1621, 1, 1079, 6067, 5812, 4326, 9914, 6633, 5394, 4233, 6728, 9084, 1864, 5863, 1225}, {9935, 8793, 9117, 1825, 9542, 8246, 8437, 3331, 9128, 9675, 6086, 7075, 319, 1334, 7932, 3583, 7167, 4178, 1726, 7720, 695, 8277, 7887, 6359, 5912, 1719, 2780, 8529, 1359, 2013, 4498, 8072, 1129, 9998, 1147, 8804, 9405, 6255, 1619, 2165, 7491, 1, 8882, 7378, 3337, 503, 5758, 4109, 3577, 985, 3200, 7615, 8058, 5032, 1080, 6410, 6873, 5496, 1466, 2412, 9885, 5904, 4406, 3605, 8770, 4361, 6205, 9193, 1537, 9959, 214, 7260, 9566, 1685, 100, 4920, 7138, 9819, 5637, 976}, {3466, 9854, 985, 1078, 7222, 8888, 5466, 5379, 3578, 4540, 6853, 8690, 3728, 6351, 7147, 3134, 6921, 9692, 857, 3307, 4998, 2172, 5783, 3931, 9417, 2541, 6299, 13, 787, 2099, 9131, 9494, 896, 8600, 1643, 8419, 7248, 2660, 2609, 8579, 91, 6663, 5506, 7675, 1947, 6165, 4286, 1972, 9645, 3805, 1663, 1456, 8853, 5705, 9889, 7489, 1107, 383, 4044, 2969, 3343, 152, 7805, 4980, 9929, 5033, 1737, 9953, 7197, 9158, 4071, 1324, 473, 9676, 3984, 9680, 3606, 8160, 7384, 5432}, {1005, 4512, 5186, 3953, 2164, 3372, 4097, 3247, 8697, 3022, 9896, 4101, 3871, 6791, 3219, 2742, 4630, 6967, 7829, 5991, 6134, 1197, 1414, 8923, 8787, 1394, 8852, 5019, 7768, 5147, 8004, 8825, 5062, 9625, 7988, 1110, 3992, 7984, 9966, 6516, 6251, 8270, 421, 3723, 1432, 4830, 6935, 8095, 9059, 2214, 6483, 6846, 3120, 1587, 6201, 6691, 9096, 9627, 6671, 4002, 3495, 9939, 7708, 7465, 5879, 6959, 6634, 3241, 3401, 2355, 9061, 2611, 7830, 3941, 2177, 2146, 5089, 7079, 519, 6351}, {7280, 8586, 4261, 2831, 7217, 3141, 9994, 9940, 5462, 2189, 4005, 6942, 9848, 5350, 8060, 6665, 7519, 4324, 7684, 657, 9453, 9296, 2944, 6843, 7499, 7847, 1728, 9681, 3906, 6353, 5529, 2822, 3355, 3897, 7724, 4257, 7489, 8672, 4356, 3983, 1948, 6892, 7415, 4153, 5893, 4190, 621, 1736, 4045, 9532, 7701, 3671, 1211, 1622, 3176, 4524, 9317, 7800, 5638, 6644, 6943, 5463, 3531, 2821, 1347, 5958, 3436, 1438, 2999, 994, 850, 4131, 2616, 1549, 3465, 5946, 690, 9273, 6954, 7991}, {9517, 399, 3249, 2596, 7736, 2142, 1322, 968, 7350, 1614, 468, 3346, 3265, 7222, 6086, 1661, 5317, 2582, 7959, 4685, 2807, 2917, 1037, 5698, 1529, 3972, 8716, 2634, 3301, 3412, 8621, 743, 8001, 4734, 888, 7744, 8092, 3671, 8941, 1487, 5658, 7099, 2781, 99, 1932, 4443, 4756, 4652, 9328, 1581, 7855, 4312, 5976, 7255, 6480, 3996, 2748, 1973, 9731, 4530, 2790, 9417, 7186, 5303, 3557, 351, 7182, 9428, 1342, 9020, 7599, 1392, 8304, 2070, 9138, 7215, 2008, 9937, 1106, 7110}, {7444, 769, 9688, 632, 1571, 6820, 8743, 4338, 337, 3366, 3073, 1946, 8219, 104, 4210, 6986, 249, 5061, 8693, 7960, 6546, 1004, 8857, 5997, 9352, 4338, 6105, 5008, 2556, 6518, 6694, 4345, 3727, 7956, 20, 3954, 8652, 4424, 9387, 2035, 8358, 5962, 5304, 5194, 8650, 8282, 1256, 1103, 2138, 6679, 1985, 3653, 2770, 2433, 4278, 615, 2863, 1715, 242, 3790, 2636, 6998, 3088, 1671, 2239, 957, 5411, 4595, 6282, 2881, 9974, 2401, 875, 7574, 2987, 4587, 3147, 6766, 9885, 2965}, {3287, 3016, 3619, 6818, 9073, 6120, 5423, 557, 2900, 2015, 8111, 3873, 1314, 4189, 1846, 4399, 7041, 7583, 2427, 2864, 3525, 5002, 2069, 748, 1948, 6015, 2684, 438, 770, 8367, 1663, 7887, 7759, 1885, 157, 7770, 4520, 4878, 3857, 1137, 3525, 3050, 6276, 5569, 7649, 904, 4533, 7843, 2199, 5648, 7628, 9075, 9441, 3600, 7231, 2388, 5640, 9096, 958, 3058, 584, 5899, 8150, 1181, 9616, 1098, 8162, 6819, 8171, 1519, 1140, 7665, 8801, 2632, 1299, 9192, 707, 9955, 2710, 7314}, {1772, 2963, 7578, 3541, 3095, 1488, 7026, 2634, 6015, 4633, 4370, 2762, 1650, 2174, 909, 8158, 2922, 8467, 4198, 4280, 9092, 8856, 8835, 5457, 2790, 8574, 9742, 5054, 9547, 4156, 7940, 8126, 9824, 7340, 8840, 6574, 3547, 1477, 3014, 6798, 7134, 435, 9484, 9859, 3031, 4, 1502, 4133, 1738, 1807, 4825, 463, 6343, 9701, 8506, 9822, 9555, 8688, 8168, 3467, 3234, 6318, 1787, 5591, 419, 6593, 7974, 8486, 9861, 6381, 6758, 194, 3061, 4315, 2863, 4665, 3789, 2201, 1492, 4416}, {126, 8927, 6608, 5682, 8986, 6867, 1715, 6076, 3159, 788, 3140, 4744, 830, 9253, 5812, 5021, 7616, 8534, 1546, 9590, 1101, 9012, 9821, 8132, 7857, 4086, 1069, 7491, 2988, 1579, 2442, 4321, 2149, 7642, 6108, 250, 6086, 3167, 24, 9528, 7663, 2685, 1220, 9196, 1397, 5776, 1577, 1730, 5481, 977, 6115, 199, 6326, 2183, 3767, 5928, 5586, 7561, 663, 8649, 9688, 949, 5913, 9160, 1870, 5764, 9887, 4477, 6703, 1413, 4995, 5494, 7131, 2192, 8969, 7138, 3997, 8697, 646, 1028}, {8074, 1731, 8245, 624, 4601, 8706, 155, 8891, 309, 2552, 8208, 8452, 2954, 3124, 3469, 4246, 3352, 1105, 4509, 8677, 9901, 4416, 8191, 9283, 5625, 7120, 2952, 8881, 7693, 830, 4580, 8228, 9459, 8611, 4499, 1179, 4988, 1394, 550, 2336, 6089, 6872, 269, 7213, 1848, 917, 6672, 4890, 656, 1478, 6536, 3165, 4743, 4990, 1176, 6211, 7207, 5284, 9730, 4738, 1549, 4986, 4942, 8645, 3698, 9429, 1439, 2175, 6549, 3058, 6513, 1574, 6988, 8333, 3406, 5245, 5431, 7140, 7085, 6407}, {7845, 4694, 2530, 8249, 290, 5948, 5509, 1588, 5940, 4495, 5866, 5021, 4626, 3979, 3296, 7589, 4854, 1998, 5627, 3926, 8346, 6512, 9608, 1918, 7070, 4747, 4182, 2858, 2766, 4606, 6269, 4107, 8982, 8568, 9053, 4244, 5604, 102, 2756, 727, 5887, 2566, 7922, 44, 5986, 621, 1202, 374, 6988, 4130, 3627, 6744, 9443, 4568, 1398, 8679, 397, 3928, 9159, 367, 2917, 6127, 5788, 3304, 8129, 911, 2669, 1463, 9749, 264, 4478, 8940, 1109, 7309, 2462, 117, 4692, 7724, 225, 2312}, {4164, 3637, 2000, 941, 8903, 39, 3443, 7172, 1031, 3687, 4901, 8082, 4945, 4515, 7204, 9310, 9349, 9535, 9940, 218, 1788, 9245, 2237, 1541, 5670, 6538, 6047, 5553, 9807, 8101, 1925, 8714, 445, 8332, 7309, 6830, 5786, 5736, 7306, 2710, 3034, 1838, 7969, 6318, 7912, 2584, 2080, 7437, 6705, 2254, 7428, 820, 782, 9861, 7596, 3842, 3631, 8063, 5240, 6666, 394, 4565, 7865, 4895, 9890, 6028, 6117, 4724, 9156, 4473, 4552, 602, 470, 6191, 4927, 5387, 884, 3146, 1978, 3000}, {4258, 6880, 1696, 3582, 5793, 4923, 2119, 1155, 9056, 9698, 6603, 3768, 5514, 9927, 9609, 6166, 6566, 4536, 4985, 4934, 8076, 9062, 6741, 6163, 7399, 4562, 2337, 5600, 2919, 9012, 8459, 1308, 6072, 1225, 9306, 8818, 5886, 7243, 7365, 8792, 6007, 9256, 6699, 7171, 4230, 7002, 8720, 7839, 4533, 1671, 478, 7774, 1607, 2317, 5437, 4705, 7886, 4760, 6760, 7271, 3081, 2997, 3088, 7675, 6208, 3101, 6821, 6840, 122, 9633, 4900, 2067, 8546, 4549, 2091, 7188, 5605, 8599, 6758, 5229}, {7854, 5243, 9155, 3556, 8812, 7047, 2202, 1541, 5993, 4600, 4760, 713, 434, 7911, 7426, 7414, 8729, 322, 803, 7960, 7563, 4908, 6285, 6291, 736, 3389, 9339, 4132, 8701, 7534, 5287, 3646, 592, 3065, 7582, 2592, 8755, 6068, 8597, 1982, 5782, 1894, 2900, 6236, 4039, 6569, 3037, 5837, 7698, 700, 7815, 2491, 7272, 5878, 3083, 6778, 6639, 3589, 5010, 8313, 2581, 6617, 5869, 8402, 6808, 2951, 2321, 5195, 497, 2190, 6187, 1342, 1316, 4453, 7740, 4154, 2959, 1781, 1482, 8256}, {7178, 2046, 4419, 744, 8312, 5356, 6855, 8839, 319, 2962, 5662, 47, 6307, 8662, 68, 4813, 567, 2712, 9931, 1678, 3101, 8227, 6533, 4933, 6656, 92, 5846, 4780, 6256, 6361, 4323, 9985, 1231, 2175, 7178, 3034, 9744, 6155, 9165, 7787, 5836, 9318, 7860, 9644, 8941, 6480, 9443, 8188, 5928, 161, 6979, 2352, 5628, 6991, 1198, 8067, 5867, 6620, 3778, 8426, 2994, 3122, 3124, 6335, 3918, 8897, 2655, 9670, 634, 1088, 1576, 8935, 7255, 474, 8166, 7417, 9547, 2886, 5560, 3842}, {6957, 3111, 26, 7530, 7143, 1295, 1744, 6057, 3009, 1854, 8098, 5405, 2234, 4874, 9447, 2620, 9303, 27, 7410, 969, 40, 2966, 5648, 7596, 8637, 4238, 3143, 3679, 7187, 690, 9980, 7085, 7714, 9373, 5632, 7526, 6707, 3951, 9734, 4216, 2146, 3602, 5371, 6029, 3039, 4433, 4855, 4151, 1449, 3376, 8009, 7240, 7027, 4602, 2947, 9081, 4045, 8424, 9352, 8742, 923, 2705, 4266, 3232, 2264, 6761, 363, 2651, 3383, 7770, 6730, 7856, 7340, 9679, 2158, 610, 4471, 4608, 910, 6241}, {4417, 6756, 1013, 8797, 658, 8809, 5032, 8703, 7541, 846, 3357, 2920, 9817, 1745, 9980, 7593, 4667, 3087, 779, 3218, 6233, 5568, 4296, 2289, 2654, 7898, 5021, 9461, 5593, 8214, 9173, 4203, 2271, 7980, 2983, 5952, 9992, 8399, 3468, 1776, 3188, 9314, 1720, 6523, 2933, 621, 8685, 5483, 8986, 6163, 3444, 9539, 4320, 155, 3992, 2828, 2150, 6071, 524, 2895, 5468, 8063, 1210, 3348, 9071, 4862, 483, 9017, 4097, 6186, 9815, 3610, 5048, 1644, 1003, 9865, 9332, 2145, 1944, 2213}, {9284, 3803, 4920, 1927, 6706, 4344, 7383, 4786, 9890, 2010, 5228, 1224, 3158, 6967, 8580, 8990, 8883, 5213, 76, 8306, 2031, 4980, 5639, 9519, 7184, 5645, 7769, 3259, 8077, 9130, 1317, 3096, 9624, 3818, 1770, 695, 2454, 947, 6029, 3474, 9938, 3527, 5696, 4760, 7724, 7738, 2848, 6442, 5767, 6845, 8323, 4131, 2859, 7595, 2500, 4815, 3660, 9130, 8580, 7016, 8231, 4391, 8369, 3444, 4069, 4021, 556, 6154, 627, 2778, 1496, 4206, 6356, 8434, 8491, 3816, 8231, 3190, 5575, 1015}, {3787, 7572, 1788, 6803, 5641, 6844, 1961, 4811, 8535, 9914, 9999, 1450, 8857, 738, 4662, 8569, 6679, 2225, 7839, 8618, 286, 2648, 5342, 2294, 3205, 4546, 176, 8705, 3741, 6134, 8324, 8021, 7004, 5205, 7032, 6637, 9442, 5539, 5584, 4819, 5874, 5807, 8589, 6871, 9016, 983, 1758, 3786, 1519, 6241, 185, 8398, 495, 3370, 9133, 3051, 4549, 9674, 7311, 9738, 3316, 9383, 2658, 2776, 9481, 7558, 619, 3943, 3324, 6491, 4933, 153, 9738, 4623, 912, 3595, 7771, 7939, 1219, 4405}, {2650, 3883, 4154, 5809, 315, 7756, 4430, 1788, 4451, 1631, 6461, 7230, 6017, 5751, 138, 588, 5282, 2442, 9110, 9035, 6349, 2515, 1570, 6122, 4192, 4174, 3530, 1933, 4186, 4420, 4609, 5739, 4135, 2963, 6308, 1161, 8809, 8619, 2796, 3819, 6971, 8228, 4188, 1492, 909, 8048, 2328, 6772, 8467, 7671, 9068, 2226, 7579, 6422, 7056, 8042, 3296, 2272, 3006, 2196, 7320, 3238, 3490, 3102, 37, 1293, 3212, 4767, 5041, 8773, 5794, 4456, 6174, 7279, 7054, 2835, 7053, 9088, 790, 6640}, {3101, 1057, 7057, 3826, 6077, 1025, 2955, 1224, 1114, 6729, 5902, 4698, 6239, 7203, 9423, 1804, 4417, 6686, 1426, 6941, 8071, 1029, 4985, 9010, 6122, 6597, 1622, 1574, 3513, 1684, 7086, 5505, 3244, 411, 9638, 4150, 907, 9135, 829, 981, 1707, 5359, 8781, 9751, 5, 9131, 3973, 7159, 1340, 6955, 7514, 7993, 6964, 8198, 1933, 2797, 877, 3993, 4453, 8020, 9349, 8646, 2779, 8679, 2961, 3547, 3374, 3510, 1129, 3568, 2241, 2625, 9138, 5974, 8206, 7669, 7678, 1833, 8700, 4480}, {4865, 9912, 8038, 8238, 782, 3095, 8199, 1127, 4501, 7280, 2112, 2487, 3626, 2790, 9432, 1475, 6312, 8277, 4827, 2218, 5806, 7132, 8752, 1468, 7471, 6386, 739, 8762, 8323, 8120, 5169, 9078, 9058, 3370, 9560, 7987, 8585, 8531, 5347, 9312, 1058, 4271, 1159, 5286, 5404, 6925, 8606, 9204, 7361, 2415, 560, 586, 4002, 2644, 1927, 2824, 768, 4409, 2942, 3345, 1002, 808, 4941, 6267, 7979, 5140, 8643, 7553, 9438, 7320, 4938, 2666, 4609, 2778, 8158, 6730, 3748, 3867, 1866, 7181}, {171, 3771, 7134, 8927, 4778, 2913, 3326, 2004, 3089, 7853, 1378, 1729, 4777, 2706, 9578, 1360, 5693, 3036, 1851, 7248, 2403, 2273, 8536, 6501, 9216, 613, 9671, 7131, 7719, 6425, 773, 717, 8803, 160, 1114, 7554, 7197, 753, 4513, 4322, 8499, 4533, 2609, 4226, 8710, 6627, 644, 9666, 6260, 4870, 5744, 7385, 6542, 6203, 7703, 6130, 8944, 5589, 2262, 6803, 6381, 7414, 6888, 5123, 7320, 9392, 9061, 6780, 322, 8975, 7050, 5089, 1061, 2260, 3199, 1150, 1865, 5386, 9699, 6501}, {3744, 8454, 6885, 8277, 919, 1923, 4001, 6864, 7854, 5519, 2491, 6057, 8794, 9645, 1776, 5714, 9786, 9281, 7538, 6916, 3215, 395, 2501, 9618, 4835, 8846, 9708, 2813, 3303, 1794, 8309, 7176, 2206, 1602, 1838, 236, 4593, 2245, 8993, 4017, 10, 8215, 6921, 5206, 4023, 5932, 6997, 7801, 262, 7640, 3107, 8275, 4938, 7822, 2425, 3223, 3886, 2105, 8700, 9526, 2088, 8662, 8034, 7004, 5710, 2124, 7164, 3574, 6630, 9980, 4242, 2901, 9471, 1491, 2117, 4562, 1130, 9086, 4117, 6698}, {2810, 2280, 2331, 1170, 4554, 4071, 8387, 1215, 2274, 9848, 6738, 1604, 7281, 8805, 439, 1298, 8318, 7834, 9426, 8603, 6092, 7944, 1309, 8828, 303, 3157, 4638, 4439, 9175, 1921, 4695, 7716, 1494, 1015, 1772, 5913, 1127, 1952, 1950, 8905, 4064, 9890, 385, 9357, 7945, 5035, 7082, 5369, 4093, 6546, 5187, 5637, 2041, 8946, 1758, 7111, 6566, 1027, 1049, 5148, 7224, 7248, 296, 6169, 375, 1656, 7993, 2816, 3717, 4279, 4675, 1609, 3317, 42, 6201, 3100, 3144, 163, 9530, 4531}, {7096, 6070, 1009, 4988, 3538, 5801, 7149, 3063, 2324, 2912, 7911, 7002, 4338, 7880, 2481, 7368, 3516, 2016, 7556, 2193, 1388, 3865, 8125, 4637, 4096, 8114, 750, 3144, 1938, 7002, 9343, 4095, 1392, 4220, 3455, 6969, 9647, 1321, 9048, 1996, 1640, 6626, 1788, 314, 9578, 6630, 2813, 6626, 4981, 9908, 7024, 4355, 3201, 3521, 3864, 3303, 464, 1923, 595, 9801, 3391, 8366, 8084, 9374, 1041, 8807, 9085, 1892, 9431, 8317, 9016, 9221, 8574, 9981, 9240, 5395, 2009, 6310, 2854, 9255}, {8830, 3145, 2960, 9615, 8220, 6061, 3452, 2918, 6481, 9278, 2297, 3385, 6565, 7066, 7316, 5682, 107, 7646, 4466, 68, 1952, 9603, 8615, 54, 7191, 791, 6833, 2560, 693, 9733, 4168, 570, 9127, 9537, 1925, 8287, 5508, 4297, 8452, 8795, 6213, 7994, 2420, 4208, 524, 5915, 8602, 8330, 2651, 8547, 6156, 1812, 6271, 7991, 9407, 9804, 1553, 6866, 1128, 2119, 4691, 9711, 8315, 5879, 9935, 6900, 482, 682, 4126, 1041, 428, 6247, 3720, 5882, 7526, 2582, 4327, 7725, 3503, 2631}, {2738, 9323, 721, 7434, 1453, 6294, 2957, 3786, 5722, 6019, 8685, 4386, 3066, 9057, 6860, 499, 5315, 3045, 5194, 7111, 3137, 9104, 941, 586, 3066, 755, 4177, 8819, 7040, 5309, 3583, 3897, 4428, 7788, 4721, 7249, 6559, 7324, 825, 7311, 3760, 6064, 6070, 9672, 4882, 584, 1365, 9739, 9331, 5783, 2624, 7889, 1604, 1303, 1555, 7125, 8312, 425, 8936, 3233, 7724, 1480, 403, 7440, 1784, 1754, 4721, 1569, 652, 3893, 4574, 5692, 9730, 4813, 9844, 8291, 9199, 7101, 3391, 8914}, {6044, 2928, 9332, 3328, 8588, 447, 3830, 1176, 3523, 2705, 8365, 6136, 5442, 9049, 5526, 8575, 8869, 9031, 7280, 706, 2794, 8814, 5767, 4241, 7696, 78, 6570, 556, 5083, 1426, 4502, 3336, 9518, 2292, 1885, 3740, 3153, 9348, 9331, 8051, 2759, 5407, 9028, 7840, 9255, 831, 515, 2612, 9747, 7435, 8964, 4971, 2048, 4900, 5967, 8271, 1719, 9670, 2810, 6777, 1594, 6367, 6259, 8316, 3815, 1689, 6840, 9437, 4361, 822, 9619, 3065, 83, 6344, 7486, 8657, 8228, 9635, 6932, 4864}, {8478, 4777, 6334, 4678, 7476, 4963, 6735, 3096, 5860, 1405, 5127, 7269, 7793, 4738, 227, 9168, 2996, 8928, 765, 733, 1276, 7677, 6258, 1528, 9558, 3329, 302, 8901, 1422, 8277, 6340, 645, 9125, 8869, 5952, 141, 8141, 1816, 9635, 4025, 4184, 3093, 83, 2344, 2747, 9352, 7966, 1206, 1126, 1826, 218, 7939, 2957, 2729, 810, 8752, 5247, 4174, 4038, 8884, 7899, 9567, 301, 5265, 5752, 7524, 4381, 1669, 3106, 8270, 6228, 6373, 754, 2547, 4240, 2313, 5514, 3022, 1040, 9738}, {2265, 8192, 1763, 1369, 8469, 8789, 4836, 52, 1212, 6690, 5257, 8918, 6723, 6319, 378, 4039, 2421, 8555, 8184, 9577, 1432, 7139, 8078, 5452, 9628, 7579, 4161, 7490, 5159, 8559, 1011, 81, 478, 5840, 1964, 1334, 6875, 8670, 9900, 739, 1514, 8692, 522, 9316, 6955, 1345, 8132, 2277, 3193, 9773, 3923, 4177, 2183, 1236, 6747, 6575, 4874, 6003, 6409, 8187, 745, 8776, 9440, 7543, 9825, 2582, 7381, 8147, 7236, 5185, 7564, 6125, 218, 7991, 6394, 391, 7659, 7456, 5128, 5294}, {2132, 8992, 8160, 5782, 4420, 3371, 3798, 5054, 552, 5631, 7546, 4716, 1332, 6486, 7892, 7441, 4370, 6231, 4579, 2121, 8615, 1145, 9391, 1524, 1385, 2400, 9437, 2454, 7896, 7467, 2928, 8400, 3299, 4025, 7458, 4703, 7206, 6358, 792, 6200, 725, 4275, 4136, 7390, 5984, 4502, 7929, 5085, 8176, 4600, 119, 3568, 76, 9363, 6943, 2248, 9077, 9731, 6213, 5817, 6729, 4190, 3092, 6910, 759, 2682, 8380, 1254, 9604, 3011, 9291, 5329, 9453, 9746, 2739, 6522, 3765, 5634, 1113, 5789}, {5304, 5499, 564, 2801, 679, 2653, 1783, 3608, 7359, 7797, 3284, 796, 3222, 437, 7185, 6135, 8571, 2778, 7488, 5746, 678, 6140, 861, 7750, 803, 9859, 9918, 2425, 3734, 2698, 9005, 4864, 9818, 6743, 2475, 132, 9486, 3825, 5472, 919, 292, 4411, 7213, 7699, 6435, 9019, 6769, 1388, 802, 2124, 1345, 8493, 9487, 8558, 7061, 8777, 8833, 2427, 2238, 5409, 4957, 8503, 3171, 7622, 5779, 6145, 2417, 5873, 5563, 5693, 9574, 9491, 1937, 7384, 4563, 6842, 5432, 2751, 3406, 7981}};
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p081().run());
}

public String run() {
    for (int i = grid.length - 1; i >= 0; --i) {
        for (int j = grid[i].length - 1; j >= 0; --j) {
            int temp;
            if (i + 1 < grid.length && j + 1 < grid[i].length) temp = Math.min(grid[i + 1][j], grid[i][j + 1]); else if (i + 1 < grid.length) temp = grid[i + 1][j]; else if (j + 1 < grid[i].length) temp = grid[i][j + 1]; else temp = 0;
            grid[i][j] += temp;
        }
    }
    return Integer.toString(grid[0][0]);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p082().run());
}

public String run() {
    int h = GRID.length;
    int w = GRID[0].length;
    distance = new int[h][w];
    for (int x = 0; x < w; ++x) {
        for (int y = 0; y < h; ++y) distance[y][x] = GRID[y][x] + Math.min(getValue(x - 1, y), getValue(x, y - 1));
        for (int y = h - 1; y >= 0; --y) distance[y][x] = Math.min(GRID[y][x] + getValue(x, y + 1), distance[y][x]);
    }
    int min = INFINITY;
    for (int y = 0; y < h; ++y) min = Math.min(distance[y][w - 1], min);
    return Integer.toString(min);
}

private int getValue(int x, int y) {
    if (x < 0) return 0; else if (y < 0 || y >= distance.length || x >= distance[y].length) return INFINITY; else return distance[y][x];
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p083().run());
}

public String run() {
    int h = GRID.length;
    int w = GRID[0].length;
    distance = new int[h][w];
    for (/*synthetic*/ int[][] arr$ = distance, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int[] row = arr$[i$];
        Arrays.fill(row, INFINITY);
    }
    distance[0][0] = GRID[0][0];
    for (int i = 0; i < w * h; ++i) {
        for (int y = 0; y < h; ++y) {
            for (int x = 0; x < w; ++x) {
                int temp = INFINITY;
                temp = Math.min(getDistance(x - 1, y), temp);
                temp = Math.min(getDistance(x + 1, y), temp);
                temp = Math.min(getDistance(x, y - 1), temp);
                temp = Math.min(getDistance(x, y + 1), temp);
                distance[y][x] = Math.min(GRID[y][x] + temp, distance[y][x]);
            }
        }
    }
    return Integer.toString(distance[h - 1][w - 1]);
}

private int getDistance(int x, int y) {
    if (y < 0 || y >= distance.length || x < 0 || x >= distance[y].length) return INFINITY; else return distance[y][x];
}

public <init>() {
    super();
    random = new Random();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p084().run());
}

public String run() {
    final int[] visitCounts = new int[40];
    p084$CardDeck chance = new p084$CardDeck(this, 16);
    p084$CardDeck communityChest = new p084$CardDeck(this, 16);
    int consecutiveDoubles = 0;
    int location = 0;
    for (int i = 0; i < 100000000; ++i) {
        int die0 = random.nextInt(4) + 1;
        int die1 = random.nextInt(4) + 1;
        if (die0 == die1) ++consecutiveDoubles; else consecutiveDoubles = 0;
        if (consecutiveDoubles < 3) location = (location + die0 + die1) % 40; else {
            location = 30;
            consecutiveDoubles = 0;
        }
        switch (location) {
        case 7: 
        
        case 22: 
        
        case 36: 
            switch (chance.nextCard()) {
            case 0: 
                location = 0;
                break;
            
            case 1: 
                location = 10;
                break;
            
            case 2: 
                location = 11;
                break;
            
            case 3: 
                location = 24;
                break;
            
            case 4: 
                location = 39;
                break;
            
            case 5: 
                location = 5;
                break;
            
            case 6: 
            
            case 7: 
                location = (location + 5) / 10 % 4 * 10 + 5;
                break;
            
            case 8: 
                location = location > 12 && location < 28 ? 28 : 12;
                break;
            
            case 9: 
                location -= 3;
                break;
            
            default: 
                break;
            
            }
            break;
        
        case 30: 
            location = 10;
            break;
        
        default: 
            break;
        
        }
        switch (location) {
        case 2: 
        
        case 17: 
        
        case 33: 
            switch (communityChest.nextCard()) {
            case 0: 
                location = 0;
                break;
            
            case 1: 
                location = 10;
                break;
            
            default: 
                break;
            
            }
            break;
        
        default: 
            break;
        
        }
        ++visitCounts[location];
    }
    for (int i = 0; i < visitCounts.length; ++i) visitCounts[i] = ~visitCounts[i] << 6 | i;
    Arrays.sort(visitCounts);
    String result = "";
    for (int i = 0; i < 3; ++i) result += String.format("%02d", new Object[]{Integer.valueOf(visitCounts[i] & 63)});
    return result;
}

public <init>(/*synthetic*/ final p084 this$0, int size) {
    this.this$0 = this$0;
    super();
    cards = new int[size];
    for (int i = 0; i < cards.length; ++i) cards[i] = i;
    index = size;
}
STATEMENT:
super();
STATEMENT:
cards = new int[size];
STATEMENT:
for (int i = 0; i < cards.length; ++i) cards[i] = i;
STATEMENT:
index = size;

public int nextCard() {
    if (index == cards.length) {
        for (int i = cards.length - 1; i >= 0; --i) {
            int j = p084.access$000(this$0).nextInt(i + 1);
            int temp = cards[i];
            cards[i] = cards[j];
            cards[j] = temp;
        }
        index = 0;
    }
    int result = cards[index];
    ++index;
    return result;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p085().run());
}

public String run() {
    int bestDiff = Integer.MAX_VALUE;
    int bestArea = -1;
    int sqrt = Library.sqrt(TARGET);
    for (int w = 1; w <= sqrt; ++w) {
        for (int h = 1; h <= sqrt; ++h) {
            int diff = Math.abs(numberOfRectangles(w, h) - TARGET);
            if (diff < bestDiff) {
                bestDiff = diff;
                bestArea = w * h;
            }
        }
    }
    return Integer.toString(bestArea);
}

private static int numberOfRectangles(int m, int n) {
    return (m + 1) * m * (n + 1) * n / 4;
}

public <init>() {
    super();
    solutions = new ArrayList();
    cumulativeSolutions = new ArrayList();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p086().run());
}

public String run() {
    cumulativeSolutions.add(Integer.valueOf(0));
    int limit = 1;
    while (true) {
        while (solutions.size() < limit) solutions.add(new HashSet());
        generateSolutions(limit);
        for (int i = cumulativeSolutions.size(); i < limit; ++i) {
            int sum = ((Integer)cumulativeSolutions.get(i - 1)).intValue() + ((Set)solutions.get(i)).size();
            cumulativeSolutions.add(Integer.valueOf(sum));
            if (sum > 1000000) return Integer.toString(i);
        }
        limit *= 2;
    }
}

private void generateSolutions(int limit) {
    outer: for (int s = 3; ; s += 2) {
        for (int t = s - 2; t > 0; t -= 2) {
            if (s * s / 2 >= limit * 3) break outer;
            if (Library.gcd(s, t) == 1) {
                for (int k = 1; ; ++k) {
                    int a = s * t * k;
                    int b = (s * s - t * t) / 2 * k;
                    int c = (s * s + t * t) / 2 * k;
                    if (a >= limit && b >= limit) break;
                    findSplits(a, b, c, limit);
                    findSplits(b, a, c, limit);
                }
            }
        }
    }
}

private void findSplits(int a, int b, int c, int limit) {
    int z = b;
    for (int x = 1; x < a; ++x) {
        int y = a - x;
        if (y < x) break;
        if (Math.min(Math.min((x + y) * (x + y) + z * z, (y + z) * (y + z) + x * x), (z + x) * (z + x) + y * y) == c * c) {
            int max = Math.max(Math.max(x, y), z);
            if (max < limit) {
                List soln = new ArrayList();
                Collections.addAll(soln, new Integer[]{Integer.valueOf(x), Integer.valueOf(y), Integer.valueOf(z)});
                Collections.sort(soln);
                ((Set)solutions.get(max)).add(soln);
            }
        }
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p087().run());
}

public String run() {
    int[] primes = Library.listPrimes(Library.sqrt(LIMIT));
    Set sums = new HashSet();
    sums.add(Integer.valueOf(0));
    for (int i = 2; i <= 4; ++i) {
        Set newsums = new HashSet();
        for (/*synthetic*/ int[] arr$ = primes, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
            int p = arr$[i$];
            {
                long q = 1;
                for (int j = 0; j < i; ++j) q *= p;
                if (q > LIMIT) break;
                int r = (int)q;
                for (/*synthetic*/ java.util.Iterator i$ = sums.iterator(); i$.hasNext(); ) {
                    int x = ((Integer)i$.next()).intValue();
                    {
                        if (x + r <= LIMIT) newsums.add(Integer.valueOf(x + r));
                    }
                }
            }
        }
        sums = newsums;
    }
    return Integer.toString(sums.size());
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p088().run());
}

public String run() {
    minSumProduct = new int[LIMIT + 1];
    Arrays.fill(minSumProduct, Integer.MAX_VALUE);
    for (int i = 2; i <= LIMIT * 2; ++i) factorize(i, i, i, 0, 0);
    Set items = new HashSet();
    for (int i = 2; i < minSumProduct.length; ++i) items.add(Integer.valueOf(minSumProduct[i]));
    int sum = 0;
    for (/*synthetic*/ java.util.Iterator i$ = items.iterator(); i$.hasNext(); ) {
        int n = ((Integer)i$.next()).intValue();
        sum += n;
    }
    return Integer.toString(sum);
}

private void factorize(int n, int remain, int maxFactor, int sum, int terms) {
    if (remain == 1) {
        if (sum > n) throw new AssertionError();
        terms += n - sum;
        if (terms <= LIMIT && n < minSumProduct[terms]) minSumProduct[terms] = n;
    } else {
        for (int i = 2; i <= maxFactor; ++i) {
            if (remain % i == 0) {
                int factor = i;
                factorize(n, remain / factor, Math.min(factor, maxFactor), sum + factor, terms + 1);
            }
        }
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p089().run());
}

public String run() {
    int sum = 0;
    for (/*synthetic*/ String[] arr$ = TO_SIMPLIFY, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        String s = arr$[i$];
        sum += s.length() - romanNumeralLength(parseRomanNumeral(s));
    }
    return Integer.toString(sum);
}

private static int parseRomanNumeral(String s) {
    int result = 0;
    outer: while (s.length() > 0) {
        for (/*synthetic*/ Object[][] arr$ = PREFIXES, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
            Object[] prefix = arr$[i$];
            {
                if (s.startsWith((String)(String)prefix[0])) {
                    result += ((Integer)(Integer)prefix[1]).intValue();
                    s = s.substring(((String)(String)prefix[0]).length());
                    continue outer;
                }
            }
        }
        throw new IllegalArgumentException("Cannot parse Roman numeral");
    }
    return result;
}

private static int romanNumeralLength(int n) {
    if (n <= 0 || n >= 5000) throw new IllegalArgumentException();
    int count = 0;
    if (n >= 4000) count += 2;
    for (; n != 0; n /= 10) count += DIGIT_LENGTHS[n % 10];
    return count;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p090().run());
}

public String run() {
    int count = 0;
    for (int i = 0; i < (1 << 10); ++i) {
        for (int j = i; j < (1 << 10); ++j) {
            if (Integer.bitCount(i) == 6 && Integer.bitCount(j) == 6 && isArrangementValid(i, j)) ++count;
        }
    }
    return Integer.toString(count);
}

private static boolean isArrangementValid(int a, int b) {
    if (testBit(a, 6) || testBit(a, 9)) a |= (1 << 6) | (1 << 9);
    if (testBit(b, 6) || testBit(b, 9)) b |= (1 << 6) | (1 << 9);
    for (/*synthetic*/ int[][] arr$ = SQUARES, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int[] sqr = arr$[i$];
        {
            if (!(testBit(a, sqr[0]) && testBit(b, sqr[1]) || testBit(a, sqr[1]) && testBit(b, sqr[0]))) return false;
        }
    }
    return true;
}

private static boolean testBit(int x, int i) {
    return ((x >>> i) & 1) != 0;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p091().run());
}

public String run() {
    int count = 0;
    for (int x1 = 0; x1 <= LIMIT; ++x1) {
        for (int y1 = 0; y1 <= LIMIT; ++y1) {
            for (int x2 = 0; x2 <= LIMIT; ++x2) {
                for (int y2 = 0; y2 <= LIMIT; ++y2) {
                    if (y2 * x1 < y1 * x2 && isRightTriangle(x1, y1, x2, y2)) ++count;
                }
            }
        }
    }
    return Integer.toString(count);
}

private static boolean isRightTriangle(int x1, int y1, int x2, int y2) {
    int a = x1 * x1 + y1 * y1;
    int b = x2 * x2 + y2 * y2;
    int c = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    return a + b == c || b + c == a || c + a == b;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p092().run());
}

public String run() {
    int count = 0;
    for (int i = 1; i < LIMIT; ++i) {
        if (isClass89(i)) ++count;
    }
    return Integer.toString(count);
}

private static boolean isClass89(int x) {
    while (true) {
        switch (x) {
        case 1: 
            return false;
        
        case 89: 
            return true;
        
        default: 
            x = nextNumber(x);
        
        }
    }
}

private static int nextNumber(int x) {
    int sum = 0;
    while (x != 0) {
        sum += (x % 10) * (x % 10);
        x /= 10;
    }
    return sum;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p093().run());
}

public String run() {
    int longest = 0;
    int abcd = -1;
    for (int a = 1; a <= 9; ++a) {
        for (int b = a + 1; b <= 9; ++b) {
            for (int c = b + 1; c <= 9; ++c) {
                for (int d = c + 1; d <= 9; ++d) {
                    int consec = longestConsecutive(a, b, c, d);
                    if (consec > longest) {
                        longest = consec;
                        abcd = a * 1000 + b * 100 + c * 10 + d;
                    }
                }
            }
        }
    }
    return Integer.toString(abcd);
}

private static int longestConsecutive(int a, int b, int c, int d) {
    Set expressible = new HashSet();
    int[] ops = {0, 0, 0, a, b, c, d};
    outer: do {
        inner: for (int i = 0; i < 64; ++i) {
            Stack stack = new Stack();
            int j = 0;
            for (/*synthetic*/ int[] arr$ = ops, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
                int op = arr$[i$];
                {
                    if (1 <= op && op <= 9) {
                        stack.push(new Fraction(BigInteger.valueOf(op)));
                    } else if (op == 0) {
                        if (stack.size() < 2) continue outer;
                        Fraction right = (Fraction)stack.pop();
                        Fraction left = (Fraction)stack.pop();
                        switch ((i >>> (j * 2)) & 3) {
                        case 0: 
                            stack.push(left.add(right));
                            break;
                        
                        case 1: 
                            stack.push(left.subtract(right));
                            break;
                        
                        case 2: 
                            stack.push(left.multiply(right));
                            break;
                        
                        case 3: 
                            if (right.numerator.signum() == 0) continue inner;
                            stack.push(left.divide(right));
                            break;
                        
                        default: 
                            throw new AssertionError();
                        
                        }
                        ++j;
                    } else throw new AssertionError();
                }
            }
            if (stack.size() != 1) throw new AssertionError();
            Fraction result = (Fraction)stack.pop();
            if (result.denominator.equals(BigInteger.ONE)) expressible.add(Integer.valueOf(result.numerator.intValue()));
        }
    }     while (Library.nextPermutation(ops));
    for (int i = 0; ; ++i) {
        if (!expressible.contains(Integer.valueOf(i + 1))) return i;
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p094().run());
}

public String run() {
    long sum = 0;
    for (int s = 1; s * s <= (LIMIT + 1) / 3; s += 2) {
        for (int t = s - 2; t > 0; t -= 2) {
            if (Library.gcd(s, t) == 1) {
                int a = s * t;
                int b = (s * s - t * t) / 2;
                int c = (s * s + t * t) / 2;
                if (a * 2 == c - 1) {
                    int p = c * 3 - 1;
                    if (p <= LIMIT) sum += p;
                }
                if (a * 2 == c + 1) {
                    int p = c * 3 + 1;
                    if (p <= LIMIT) sum += p;
                }
                if (b * 2 == c - 1) {
                    int p = c * 3 - 1;
                    if (p <= LIMIT) sum += p;
                }
                if (b * 2 == c + 1) {
                    int p = c * 3 + 1;
                    if (p <= LIMIT) sum += p;
                }
            }
        }
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p095().run());
}

public String run() {
    int[] divisorSum = new int[LIMIT + 1];
    for (int i = 1; i <= LIMIT; ++i) {
        for (int j = i * 2; j <= LIMIT; j += i) divisorSum[j] += i;
    }
    int maxChainLen = 0;
    int minChainElem = -1;
    for (int i = 0; i <= LIMIT; ++i) {
        Set visited = new HashSet();
        for (int count = 1, cur = i; ; ++count) {
            visited.add(Integer.valueOf(cur));
            int next = divisorSum[cur];
            if (next == i) {
                if (count > maxChainLen) {
                    minChainElem = i;
                    maxChainLen = count;
                }
                break;
            } else if (next > LIMIT || visited.contains(Integer.valueOf(next))) break; else cur = next;
        }
    }
    return Integer.toString(minChainElem);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p096().run());
}

public String run() {
    int sum = 0;
    for (/*synthetic*/ String[] arr$ = PUZZLES, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        String puz = arr$[i$];
        {
            if (puz.length() != 81) throw new IllegalArgumentException();
            char[] board = puz.toCharArray();
            if (!solveSudoku(board, 0)) throw new IllegalArgumentException("Unsolvable");
            sum += Integer.parseInt("" + board[0] + board[1] + board[2]);
        }
    }
    return Integer.toString(sum);
}

private static boolean solveSudoku(char[] board, int index) {
    if (index == board.length) return true; else if (board[index] != '0') return solveSudoku(board, index + 1); else {
        outer: for (char digit = '1'; digit <= '9'; ++digit) {
            int x = index % 9;
            int y = index / 9;
            int b = y / 3 * 27 + x / 3 * 3;
            for (int i = 0; i < 9; ++i) {
                if (board[y * 9 + i] == digit) continue outer;
                if (board[i * 9 + x] == digit) continue outer;
                if (board[b + i / 3 * 9 + i % 3] == digit) continue outer;
            }
            board[index] = digit;
            if (solveSudoku(board, index + 1)) return true;
        }
        board[index] = '0';
        return false;
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p097().run());
}

public String run() {
    BigInteger modulus = BigInteger.TEN.pow(10);
    BigInteger n = BigInteger.valueOf(2).modPow(BigInteger.valueOf(7830457), modulus);
    n = n.multiply(BigInteger.valueOf(28433)).mod(modulus);
    n = n.add(BigInteger.ONE).mod(modulus);
    return String.format("%010d", new Object[]{n});
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p098().run());
}

public String run() {
    Map anagrams = new HashMap();
    for (/*synthetic*/ String[] arr$ = WORDS, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        String word = arr$[i$];
        {
            String key = canonicalize(word);
            if (!anagrams.containsKey(key)) anagrams.put(key, new ArrayList());
            ((List)anagrams.get(key)).add(word);
        }
    }
    int max = 0;
    for (/*synthetic*/ java.util.Iterator i$ = anagrams.keySet().iterator(); i$.hasNext(); ) {
        String key = (String)i$.next();
        {
            List words = (List)anagrams.get(key);
            for (int i = 0; i < words.size(); ++i) {
                for (int j = i + 1; j < words.size(); ++j) {
                    int[] assignments = new int['Z' + 1];
                    Arrays.fill(assignments, -1);
                    max = Math.max(maxSquarePair((String)words.get(i), (String)words.get(j), 0, assignments, new boolean[10]), max);
                }
            }
        }
    }
    return Integer.toString(max);
}

private static int maxSquarePair(String a, String b, int index, int[] assignments, boolean[] isDigitUsed) {
    if (index == a.length()) {
        if (assignments[a.charAt(0)] == 0 || assignments[b.charAt(0)] == 0) return 0;
        int aNum = 0;
        int bNum = 0;
        for (int i = 0; i < a.length(); ++i) {
            aNum = aNum * 10 + assignments[a.charAt(i)];
            bNum = bNum * 10 + assignments[b.charAt(i)];
        }
        if (Library.isSquare(aNum) && Library.isSquare(bNum)) return Math.max(aNum, bNum); else return 0;
    } else if (assignments[a.charAt(index)] != -1) {
        return maxSquarePair(a, b, index + 1, assignments, isDigitUsed);
    } else {
        int max = 0;
        for (int i = 0; i < 10; ++i) {
            if (!isDigitUsed[i]) {
                isDigitUsed[i] = true;
                assignments[a.charAt(index)] = i;
                max = Math.max(maxSquarePair(a, b, index + 1, assignments, isDigitUsed), max);
                isDigitUsed[i] = false;
                assignments[a.charAt(index)] = -1;
            }
        }
        return max;
    }
}

private static String canonicalize(String s) {
    char[] c = s.toCharArray();
    Arrays.sort(c);
    return new String(c);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p099().run());
}

public String run() {
    int[] maxVal = DATA[0];
    int maxIndex = 0;
    for (int i = 1; i < DATA.length; ++i) {
        if (comparePowers(DATA[i][0], DATA[i][1], maxVal[0], maxVal[1]) > 0) {
            maxVal = DATA[i];
            maxIndex = i;
        }
    }
    return Integer.toString(maxIndex + 1);
}

private static int comparePowers(int xBase, int xExp, int yBase, int yExp) {
    for (int precision = 16; precision <= 1024; precision *= 2) {
        p099$BigFloat xLow = new p099$BigFloat(xBase).power(xExp, precision, false);
        p099$BigFloat xHigh = new p099$BigFloat(xBase).power(xExp, precision, true);
        p099$BigFloat yLow = new p099$BigFloat(yBase).power(yExp, precision, false);
        p099$BigFloat yHigh = new p099$BigFloat(yBase).power(yExp, precision, true);
        if (xHigh.compareTo(yLow) < 0) return -1; else if (xLow.compareTo(yHigh) > 0) return +1;
    }
    BigInteger xPow = BigInteger.valueOf(xBase).pow(xExp);
    BigInteger yPow = BigInteger.valueOf(yBase).pow(yExp);
    return xPow.compareTo(yPow);
}

public <init>(int n) {
    super();
    if (n <= 0) throw new IllegalArgumentException();
    mantissa = BigInteger.valueOf(n);
    exponent = 0;
}
STATEMENT:
super();
STATEMENT:
if (n <= 0) throw new IllegalArgumentException();
STATEMENT:
mantissa = BigInteger.valueOf(n);
STATEMENT:
exponent = 0;

private <init>(BigInteger man, int exp) {
    super();
    mantissa = man;
    exponent = exp;
}
STATEMENT:
super();
STATEMENT:
mantissa = man;
STATEMENT:
exponent = exp;

public int compareTo(p099$BigFloat other) {
    int minExp = Math.min(exponent, other.exponent);
    BigInteger tempx = mantissa.shiftLeft(exponent - minExp);
    BigInteger tempy = other.mantissa.shiftLeft(other.exponent - minExp);
    return tempx.compareTo(tempy);
}

public String toString() {
    return mantissa + "<<" + exponent;
}

public p099$BigFloat multiply(p099$BigFloat other, int precision, boolean roundUp) {
    BigInteger man = mantissa.multiply(other.mantissa);
    int exp = exponent + other.exponent;
    int excess = man.bitLength() - precision;
    if (excess > 0) {
        if (roundUp) {
            BigInteger mask = BigInteger.ONE.shiftLeft(excess).subtract(BigInteger.ONE);
            if (!mask.and(man).equals(BigInteger.ZERO)) man = man.add(BigInteger.ONE.shiftLeft(excess));
            excess = man.bitLength() - precision;
        }
        man = man.shiftRight(excess);
        exp += excess;
    }
    return new p099$BigFloat(man, exp);
}

public p099$BigFloat power(int y, int precision, boolean roundUp) {
    if (y < 0 || precision <= 0) throw new IllegalArgumentException();
    p099$BigFloat x = this;
    p099$BigFloat z = new p099$BigFloat(1);
    for (; y != 0; y >>>= 1) {
        if ((y & 1) != 0) z = z.multiply(x, precision, roundUp);
        x = x.multiply(x, precision, roundUp);
    }
    return z;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p100().run());
}

public String run() {
    BigInteger x0 = BigInteger.valueOf(3);
    BigInteger y0 = BigInteger.valueOf(1);
    BigInteger x = BigInteger.valueOf(3);
    BigInteger y = BigInteger.valueOf(1);
    while (true) {
        BigInteger sqrt = Library.sqrt(y.multiply(y).multiply(BigInteger.valueOf(8)).add(BigInteger.ONE));
        if (sqrt.testBit(0)) {
            BigInteger blue = sqrt.add(BigInteger.ONE).divide(BigInteger.valueOf(2)).add(y);
            if (blue.add(y).compareTo(BigInteger.TEN.pow(12)) > 0) return blue.toString();
        }
        BigInteger nextx = x.multiply(x0).add(y.multiply(y0).multiply(BigInteger.valueOf(8)));
        BigInteger nexty = x.multiply(y0).add(y.multiply(x0));
        x = nextx;
        y = nexty;
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p101().run());
}

public String run() {
    Fraction sum = Fraction.ZERO;
    for (int k = 1; k <= DEGREE; ++k) {
        for (int n = k + 1; ; ++n) {
            if (n == DEGREE + 2) throw new AssertionError();
            Fraction reference = new Fraction(generatingFunction(n));
            Fraction term = optimumPolynomial(k, n);
            if (!term.equals(reference)) {
                sum = sum.add(term);
                break;
            }
        }
    }
    if (sum.denominator.equals(BigInteger.ONE)) return sum.numerator.toString(); else return sum.toString();
}

private static Fraction optimumPolynomial(int k, int n) {
    Fraction sum = Fraction.ZERO;
    for (int i = 1; i <= k; ++i) {
        Fraction product = new Fraction(generatingFunction(i));
        for (int j = 1; j <= k; ++j) {
            if (j != i) product = product.multiply(new Fraction(BigInteger.valueOf(n - j), BigInteger.valueOf(i - j)));
        }
        sum = sum.add(product);
    }
    return sum;
}

private static BigInteger generatingFunction(int n) {
    BigInteger sum = BigInteger.ZERO;
    BigInteger biN = BigInteger.valueOf(-n);
    for (int i = 0; i <= DEGREE; ++i) sum = sum.add(biN.pow(i));
    return sum;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p102().run());
}

public String run() {
    int count = 0;
    for (/*synthetic*/ int[][] arr$ = TRIANGLES, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int[] t = arr$[i$];
        {
            if (isInTriangle(t, 0, 0)) ++count;
        }
    }
    return Integer.toString(count);
}

private static boolean isInTriangle(int[] t, int x, int y) {
    int a = Integer.signum((t[0] - t[2]) * (y - t[1]) - (t[1] - t[3]) * (x - t[0]));
    int b = Integer.signum((t[2] - t[4]) * (y - t[3]) - (t[3] - t[5]) * (x - t[2]));
    int c = Integer.signum((t[4] - t[0]) * (y - t[5]) - (t[5] - t[1]) * (x - t[4]));
    return a == 0 || b == 0 || c == 0 || (a == b && b == c);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p104().run());
}

public String run() {
    int i = 0;
    int a = 0;
    int b = 1;
    while (!isFound(i, a)) {
        int c = (a + b) % 1000000000;
        a = b;
        b = c;
        ++i;
    }
    return Integer.toString(i);
}

private static boolean isFound(int n, int fibMod) {
    if (!isPandigital(Integer.toString(fibMod))) return false;
    BigInteger fib = fibonacci(n)[0];
    if (fib.mod(BigInteger.valueOf(1000000000)).intValue() != fibMod) throw new AssertionError();
    return isPandigital(leading9Digits(fib));
}

private static String leading9Digits(BigInteger x) {
    int log10 = (x.bitLength() - 1) * 3 / 10;
    x = x.divide(BigInteger.TEN.pow(Math.max(log10 + 1 - 9, 0)));
    return x.toString().substring(0, 9);
}

private static boolean isPandigital(String s) {
    if (s.length() != 9) return false;
    char[] temp = s.toCharArray();
    Arrays.sort(temp);
    return new String(temp).equals("123456789");
}

private static BigInteger[] fibonacci(int n) {
    if (n < 0) throw new IllegalArgumentException(); else if (n == 0) return new BigInteger[]{BigInteger.ZERO, BigInteger.ONE}; else {
        BigInteger[] ab = fibonacci(n / 2);
        BigInteger a = ab[0];
        BigInteger b = ab[1];
        BigInteger c = a.multiply(b.shiftLeft(1).subtract(a));
        BigInteger d = a.multiply(a).add(b.multiply(b));
        if (n % 2 == 0) return new BigInteger[]{c, d}; else return new BigInteger[]{d, c.add(d)};
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p105().run());
}

public String run() {
    int sum = 0;
    for (/*synthetic*/ int[][] arr$ = SETS, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int[] set = arr$[i$];
        {
            if (isSpecialSumSet(set)) {
                for (/*synthetic*/ int[] arr$ = set, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
                    int x = arr$[i$];
                    sum += x;
                }
            }
        }
    }
    return Integer.toString(sum);
}

private static boolean isSpecialSumSet(int[] set) {
    Set sumsSeen = new HashSet();
    int[] minSum = new int[set.length + 1];
    int[] maxSum = new int[set.length + 1];
    Arrays.fill(minSum, Integer.MAX_VALUE);
    for (int i = 0; i < (1 << set.length); ++i) {
        int size = Integer.bitCount(i);
        int sum = 0;
        for (int j = 0; j < set.length; ++j) {
            if (((i >>> j) & 1) != 0) sum += set[j];
        }
        if (!sumsSeen.add(Integer.valueOf(sum))) return false;
        minSum[size] = Math.min(sum, minSum[size]);
        maxSum[size] = Math.max(sum, maxSum[size]);
    }
    for (int i = 0; i < set.length; ++i) {
        if (maxSum[i] >= minSum[i + 1]) return false;
    }
    return true;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p107().run());
}

public String run() {
    int vertices = WEIGHTS.length;
    for (int i = 0; i < vertices; ++i) {
        if (WEIGHTS[i].length != vertices) throw new AssertionError("Matrix not square");
    }
    int oldWeight = 0;
    for (int i = 0; i < vertices; ++i) {
        if (WEIGHTS[i][i] != -1) throw new AssertionError("Self edge");
        for (int j = i + 1; j < vertices; ++j) {
            if (WEIGHTS[i][j] != WEIGHTS[j][i]) throw new AssertionError("Matrix not symmetric");
            if (WEIGHTS[i][j] != -1) oldWeight += WEIGHTS[i][j];
        }
    }
    boolean[] reachable = new boolean[vertices];
    reachable[0] = true;
    int newWeight = 0;
    for (int i = 1; i < vertices; ++i) {
        int lowestWeight = -1;
        int target = -1;
        for (int j = 0; j < vertices; ++j) {
            if (reachable[j]) {
                for (int k = 0; k < vertices; ++k) {
                    if (!reachable[k] && WEIGHTS[j][k] != -1 && (lowestWeight == -1 || WEIGHTS[j][k] < lowestWeight)) {
                        lowestWeight = WEIGHTS[j][k];
                        target = k;
                    }
                }
            }
        }
        if (lowestWeight == -1) throw new AssertionError("No spanning tree exists");
        reachable[target] = true;
        newWeight += lowestWeight;
    }
    return Integer.toString(oldWeight - newWeight);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p108().run());
}

public String run() {
    for (int n = 1; ; ++n) {
        if ((countDivisorsSquared(n) + 1) / 2 > 1000) return Integer.toString(n);
    }
}

private static int countDivisorsSquared(int n) {
    int count = 1;
    for (int i = 2, end = Library.sqrt(n); i <= end; ++i) {
        if (n % i == 0) {
            int j = 0;
            do {
                n /= i;
                ++j;
            }             while (n % i == 0);
            count *= j * 2 + 1;
            end = Library.sqrt(n);
        }
    }
    if (n != 1) count *= 3;
    return count;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p109().run());
}

public String run() {
    points = new ArrayList();
    for (int i = 1; i <= 20; ++i) {
        for (int j = 1; j <= 3; ++j) points.add(Integer.valueOf(i * j));
    }
    points.add(Integer.valueOf(25));
    points.add(Integer.valueOf(50));
    List doublePoints = new ArrayList();
    for (int i = 1; i <= 20; ++i) doublePoints.add(Integer.valueOf(i * 2));
    doublePoints.add(Integer.valueOf(25 * 2));
    ways = new int[3][101][points.size()];
    for (/*synthetic*/ int[][][] arr$ = ways, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int[][] x = arr$[i$];
        {
            for (/*synthetic*/ int[][] arr$ = x, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
                int[] y = arr$[i$];
                Arrays.fill(y, -1);
            }
        }
    }
    int checkouts = 0;
    for (int remainingPoints = 1; remainingPoints < 100; ++remainingPoints) {
        for (int throwz = 0; throwz <= 2; ++throwz) {
            for (/*synthetic*/ java.util.Iterator i$ = doublePoints.iterator(); i$.hasNext(); ) {
                int p = ((Integer)i$.next()).intValue();
                {
                    if (p <= remainingPoints) checkouts += ways(throwz, remainingPoints - p, points.size() - 1);
                }
            }
        }
    }
    return Integer.toString(checkouts);
}

private int ways(int throwz, int total, int maxIndex) {
    if (ways[throwz][total][maxIndex] == -1) {
        int result;
        if (throwz == 0) result = total == 0 ? 1 : 0; else {
            result = 0;
            if (maxIndex > 0) result += ways(throwz, total, maxIndex - 1);
            if (((Integer)points.get(maxIndex)).intValue() <= total) result += ways(throwz - 1, total - ((Integer)points.get(maxIndex)).intValue(), maxIndex);
        }
        ways[throwz][total][maxIndex] = result;
    }
    return ways[throwz][total][maxIndex];
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p111().run());
}

public String run() {
    primes = Library.listPrimes((int)Library.sqrt(pow(10, DIGITS)));
    long total = 0;
    for (int digit = 0; digit < 10; ++digit) {
        for (int rep = DIGITS; rep >= 0; --rep) {
            long sum = 0;
            int[] digits = new int[DIGITS];
            long count = pow(9, DIGITS - rep);
            level2: for (long i = 0; i < count; ++i) {
                Arrays.fill(digits, 0, rep, digit);
                long temp = i;
                for (int j = 0; j < DIGITS - rep; ++j) {
                    int d = (int)(temp % 9);
                    if (d >= digit) ++d;
                    if (j > 0 && d > digits[DIGITS - j]) continue level2;
                    digits[DIGITS - 1 - j] = d;
                    temp /= 9;
                }
                Arrays.sort(digits);
                do {
                    if (digits[0] > 0) {
                        long num = toInteger(digits);
                        if (isPrime(num)) sum += num;
                    }
                }                 while (Library.nextPermutation(digits));
            }
            if (sum > 0) {
                total += sum;
                break;
            }
        }
    }
    return Long.toString(total);
}

private boolean isPrime(long n) {
    for (/*synthetic*/ int[] arr$ = primes, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int p = arr$[i$];
        {
            if (n % p == 0) return false;
        }
    }
    return true;
}

private static long toInteger(int[] digits) {
    long result = 0;
    for (/*synthetic*/ int[] arr$ = digits, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        result = result * 10 + x;
    }
    return result;
}

private static long pow(int x, int y) {
    long z = 1;
    for (int i = 0; i < y; ++i) z *= x;
    return z;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p112().run());
}

public String run() {
    int bouncy = 0;
    for (int i = 1; ; ++i) {
        if (isBouncy(i)) ++bouncy;
        if (bouncy * 100 == i * 99) return Integer.toString(i);
    }
}

private static boolean isBouncy(int x) {
    if (x < 100) return false; else {
        boolean nonincreasing = true;
        boolean nondecreasing = true;
        int lastDigit = x % 10;
        x /= 10;
        while (x != 0) {
            int digit = x % 10;
            if (digit > lastDigit) nondecreasing = false; else if (digit < lastDigit) nonincreasing = false;
            lastDigit = digit;
            x /= 10;
        }
        return !nonincreasing && !nondecreasing;
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p113().run());
}

public String run() {
    BigInteger increasing = Library.binomial(DIGITS + 9, 9).subtract(BigInteger.ONE);
    BigInteger decreasing = Library.binomial(DIGITS + 10, 10).subtract(BigInteger.valueOf(DIGITS + 1));
    BigInteger flat = BigInteger.valueOf(DIGITS * 9);
    return increasing.add(decreasing).subtract(flat).toString();
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p114().run());
}

public String run() {
    long[] ways = new long[LENGTH + 1];
    ways[0] = 1;
    ways[1] = 1;
    ways[2] = 1;
    for (int n = 3; n <= LENGTH; ++n) {
        long sum = ways[n - 1] + 1;
        for (int k = 3; k < n; ++k) sum += ways[n - k - 1];
        ways[n] = sum;
    }
    return Long.toString(ways[LENGTH]);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p115().run());
}

public String run() {
    List ways = new ArrayList();
    ways.add(Long.valueOf(1L));
    for (int n = 1; ; ++n) {
        long sum = ((Long)ways.get(n - 1)).longValue();
        for (int k = M; k < n; ++k) sum += ((Long)ways.get(n - k - 1)).longValue();
        if (n >= M) ++sum;
        ways.add(Long.valueOf(sum));
        if (sum > 1000000) return Long.toString(n);
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p116().run());
}

public String run() {
    return Long.toString(countWays(LENGTH, 2) + countWays(LENGTH, 3) + countWays(LENGTH, 4));
}

private static long countWays(int length, int m) {
    long[] ways = new long[length + 1];
    ways[0] = 1;
    for (int n = 1; n <= length; ++n) {
        ways[n] += ways[n - 1];
        if (n >= m) ways[n] += ways[n - m];
    }
    return ways[length] - 1;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p117().run());
}

public String run() {
    long[] ways = new long[LENGTH + 1];
    ways[0] = 1;
    for (int n = 1; n <= LENGTH; ++n) {
        for (int k = 1; k <= 4 && k <= n; ++k) ways[n] += ways[n - k];
    }
    return Long.toString(ways[LENGTH]);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p118().run());
}

public String run() {
    isPrime = Library.listPrimality(10000);
    count = 0;
    int[] digits = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    do countPrimeSets(digits, 0, 0);     while (Library.nextPermutation(digits));
    return Integer.toString(count);
}

private void countPrimeSets(int[] digits, int startIndex, int prevNum) {
    if (startIndex == digits.length) ++count; else {
        for (int split = startIndex + 1; split <= digits.length; ++split) {
            int num = toInteger(digits, startIndex, split);
            if (num > prevNum && isPrime(num)) countPrimeSets(digits, split, num);
        }
    }
}

private boolean isPrime(int n) {
    if (n < isPrime.length) return isPrime[n]; else return Library.isPrime(n);
}

private static int toInteger(int[] digits, int start, int end) {
    int result = 0;
    for (int i = start; i < end; ++i) result = result * 10 + digits[i];
    return result;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p119().run());
}

public String run() {
    for (BigInteger limit = BigInteger.ONE; ; limit = limit.shiftLeft(8)) {
        SortedSet candidates = new TreeSet();
        for (int k = 2; BigInteger.valueOf(1).shiftLeft(k).compareTo(limit) < 0; ++k) {
            for (int n = 2; ; ++n) {
                BigInteger pow = BigInteger.valueOf(n).pow(k);
                if (pow.compareTo(limit) >= 0 && pow.toString().length() * 9 < n) break;
                if (pow.compareTo(BigInteger.TEN) >= 0 && isDigitSumPower(pow)) candidates.add(pow);
            }
        }
        if (candidates.size() >= INDEX) return ((BigInteger)new ArrayList(candidates).get(INDEX - 1)).toString();
    }
}

private static boolean isDigitSumPower(BigInteger x) {
    int digitSum = digitSum(x);
    if (digitSum == 1) return false;
    BigInteger base = BigInteger.valueOf(digitSum);
    BigInteger pow = base;
    while (pow.compareTo(x) < 0) pow = pow.multiply(base);
    return pow.equals(x);
}

private static int digitSum(BigInteger x) {
    if (x.signum() < 1) throw new IllegalArgumentException("Only for positive integers");
    int sum = 0;
    for (/*synthetic*/ char[] arr$ = x.toString().toCharArray(), len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        char c = arr$[i$];
        sum += c - '0';
    }
    return sum;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p120().run());
}

public String run() {
    int sum = 0;
    for (int a = 3; a <= 1000; ++a) sum += a * (a - (a % 2 == 0 ? 2 : 1));
    return Integer.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p121().run());
}

public String run() {
    BigInteger[][] ways = new BigInteger[TURNS + 1][];
    ways[0] = new BigInteger[]{BigInteger.ONE};
    for (int i = 1; i <= TURNS; ++i) {
        ways[i] = new BigInteger[i + 1];
        for (int j = 0; j <= i; ++j) {
            BigInteger temp = BigInteger.ZERO;
            if (j < i) temp = ways[i - 1][j].multiply(BigInteger.valueOf(i));
            if (j > 0) temp = temp.add(ways[i - 1][j - 1]);
            ways[i][j] = temp;
        }
    }
    BigInteger numer = BigInteger.ZERO;
    for (int i = TURNS / 2 + 1; i <= TURNS; ++i) numer = numer.add(ways[TURNS][i]);
    BigInteger denom = Library.factorial(TURNS + 1);
    return denom.divide(numer).toString();
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p122().run());
}

public String run() {
    minOperations = new int[LIMIT + 1];
    Arrays.fill(minOperations, -1);
    minOperations[0] = 0;
    minOperations[1] = 0;
    numUnknown = LIMIT - 1;
    for (int ops = 1; numUnknown > 0; ++ops) {
        p122$IntStack chain = new p122$IntStack(ops + 1);
        chain.push(1);
        exploreChains(chain, ops);
    }
    int sum = 0;
    for (/*synthetic*/ int[] arr$ = minOperations, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        sum += x;
    }
    return Integer.toString(sum);
}

private void exploreChains(p122$IntStack chain, int maxOps) {
    if (chain.size > maxOps || numUnknown == 0) return;
    int max = chain.values[chain.size - 1];
    for (int i = chain.size - 1; i >= 0; --i) {
        for (int j = i; j >= 0; --j) {
            int x = chain.values[i] + chain.values[j];
            if (x <= max) break;
            if (x <= LIMIT) {
                chain.push(x);
                if (minOperations[x] == -1) {
                    minOperations[x] = chain.size - 1;
                    --numUnknown;
                }
                exploreChains(chain, maxOps);
                chain.pop();
            }
        }
    }
}

public <init>(int capacity) {
    super();
    values = new int[capacity];
    size = 0;
}
STATEMENT:
super();
STATEMENT:
values = new int[capacity];
STATEMENT:
size = 0;

public void push(int x) {
    if (size >= values.length) throw new IllegalStateException();
    values[size] = x;
    ++size;
}

public int pop() {
    if (size <= 0) throw new IllegalStateException();
    --size;
    return values[size];
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p123().run());
}

public String run() {
    int[] primes = Library.listPrimes(PRIME_LIMIT);
    for (int n = 5; n <= primes.length; n += 2) {
        long rem = (long)n * primes[n - 1] * 2;
        if (rem > THRESHOLD) return Integer.toString(n);
    }
    throw new AssertionError("Not found");
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p124().run());
}

public String run() {
    int[] rads = new int[LIMIT + 1];
    Arrays.fill(rads, 1, rads.length, 1);
    for (int i = 2; i < rads.length; ++i) {
        if (rads[i] == 1) {
            for (int j = i; j < rads.length; j += i) rads[j] *= i;
        }
    }
    p124$IntPair[] data = new p124$IntPair[LIMIT];
    for (int i = 0; i < data.length; ++i) data[i] = new p124$IntPair(rads[i + 1], i + 1);
    Arrays.sort(data);
    return Integer.toString(data[10000 - 1].b);
}

public <init>(int a, int b) {
    super();
    this.a = a;
    this.b = b;
}
STATEMENT:
super();
STATEMENT:
this.a = a;
STATEMENT:
this.b = b;

public int compareTo(p124$IntPair other) {
    if (a != other.a) return Integer.compare(a, other.a); else return Integer.compare(b, other.b);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p125().run());
}

public String run() {
    Set nums = new HashSet();
    for (int i = 1; i <= 10000; ++i) {
        int sum = i * i;
        for (int j = i + 1; ; ++j) {
            sum += j * j;
            if (sum >= 100000000) break;
            if (Library.isPalindrome(sum)) nums.add(Integer.valueOf(sum));
        }
    }
    long sum = 0;
    for (/*synthetic*/ java.util.Iterator i$ = nums.iterator(); i$.hasNext(); ) {
        int x = ((Integer)i$.next()).intValue();
        sum += x;
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p127().run());
}

public String run() {
    int[] rads = new int[LIMIT];
    Arrays.fill(rads, 1, rads.length, 1);
    for (int i = 2; i < rads.length; ++i) {
        if (rads[i] == 1) {
            for (int j = i; j < rads.length; j += i) rads[j] *= i;
        }
    }
    long sum = 0;
    for (int c = 2; c < LIMIT; ++c) {
        if (rads[c] == c) continue;
        for (int a = 1, end = (c - 1) / 2; a <= end; ++a) {
            int b = c - a;
            if (!$assertionsDisabled && !(a < b)) throw new AssertionError();
            if ((long)rads[a] * rads[b] * rads[c] < c && Library.gcd(a, b) == 1) sum += c;
        }
    }
    return Long.toString(sum);
}
IF:
if (!$assertionsDisabled && !(a < b)) throw new AssertionError();
0
assert a < b;
a < b
605943721
Node[6270122]
13
1

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p128().run());
}

public String run() {
    int count = 2;
    for (int ring = 2; ; ++ring) {
        if ((long)ring * 12 + 5 > Integer.MAX_VALUE) throw new ArithmeticException();
        if (Library.isPrime(ring * 6 - 1) && Library.isPrime(ring * 6 + 1) && Library.isPrime(ring * 12 + 5)) {
            ++count;
            if (count == TARGET) return Long.toString((long)ring * (ring - 1) * 3 + 2);
        }
        if (Library.isPrime(ring * 6 - 1) && Library.isPrime(ring * 6 + 5) && Library.isPrime(ring * 12 - 7)) {
            ++count;
            if (count == TARGET) return Long.toString((long)ring * (ring + 1) * 3 + 1);
        }
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p129().run());
}

public String run() {
    for (int n = LIMIT; ; ++n) {
        if (findLeastDivisibleRepunit(n) > LIMIT) return Integer.toString(n);
    }
}

private static int findLeastDivisibleRepunit(int n) {
    if (n % 2 == 0 || n % 5 == 0) return 0;
    if (n > Integer.MAX_VALUE / 10) throw new IllegalArgumentException("Arithmetic overflow");
    int sum = 1;
    int pow = 1;
    int k = 1;
    while (sum % n != 0) {
        ++k;
        pow = pow * 10 % n;
        sum = (sum + pow) % n;
    }
    return k;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p130().run());
}

public String run() {
    int sum = 0;
    int found = 0;
    for (int i = 7; found < 25; i += 2) {
        if (i % 5 != 0 && !Library.isPrime(i) && (i - 1) % findLeastDivisibleRepunit(i) == 0) {
            sum += i;
            ++found;
        }
    }
    return Integer.toString(sum);
}

private static int findLeastDivisibleRepunit(int n) {
    if (n % 2 == 0 || n % 5 == 0) return 0;
    if (n > Integer.MAX_VALUE / 10) throw new IllegalArgumentException("Arithmetic overflow");
    int sum = 1;
    int pow = 1;
    int k = 1;
    while (sum % n != 0) {
        ++k;
        pow = pow * 10 % n;
        sum = (sum + pow) % n;
    }
    return k;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p132().run());
}

public String run() {
    int sum = 0;
    int count = 0;
    for (int i = 2; count < 40; ++i) {
        if (Library.isPrime(i) && repunitMod(1000000000, i) == 0) {
            sum += i;
            ++count;
        }
    }
    return Integer.toString(sum);
}

private static int repunitMod(int k, int m) {
    return (Library.powMod(10, k, m * 9) - 1) / 9;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p133().run());
}

public String run() {
    long sum = 0;
    for (/*synthetic*/ int[] arr$ = Library.listPrimes(100000), len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int p = arr$[i$];
        {
            if (p == 2 || p == 5 || !hasDivisibleRepunit(p)) sum += p;
        }
    }
    return Long.toString(sum);
}

private static boolean hasDivisibleRepunit(int p) {
    return (BigInteger.TEN.modPow(EXPONENT, BigInteger.valueOf(p * 9)).intValue() - 1) / 9 % p == 0;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p134().run());
}

public String run() {
    long sum = 0;
    int[] primes = Library.listPrimes(2000000);
    for (int i = 2; primes[i] <= 1000000; ++i) {
        int p = primes[i];
        int q = primes[i + 1];
        int k = 1;
        while (k < p) k *= 10;
        long m = (long)(q - p) * Library.reciprocalMod(k % q, q) % q;
        sum += m * k + p;
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p135().run());
}

public String run() {
    int[] solutions = new int[LIMIT];
    for (int m = 1; m < LIMIT * 2; ++m) {
        for (int k = m / 5 + 1; k * 2 < m; ++k) {
            long temp = (long)(m - k) * (k * 5 - m);
            if (temp >= solutions.length) break;
            ++solutions[(int)temp];
        }
    }
    int count = 0;
    for (/*synthetic*/ int[] arr$ = solutions, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        {
            if (x == 10) ++count;
        }
    }
    return Integer.toString(count);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p139().run());
}

public String run() {
    int count = 0;
    for (int s = 3; s * s / 2 < LIMIT; s += 2) {
        for (int t = 1; t < s; t += 2) {
            int a = s * t;
            int b = (s * s - t * t) / 2;
            int c = (s * s + t * t) / 2;
            int p = a + b + c;
            if (p >= LIMIT) break;
            if (c % (a - b) == 0 && Library.gcd(s, t) == 1) count += (LIMIT - 1) / p;
        }
    }
    return Integer.toString(count);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p142().run());
}

public String run() {
    int sumLimit = 10;
    while (true) {
        isSquare = new boolean[sumLimit];
        for (int i = 0; i * i < sumLimit; ++i) isSquare[i * i] = true;
        int sum = findSum(sumLimit);
        if (sum != -1) {
            sum = sumLimit;
            break;
        }
        sumLimit *= 10;
    }
    while (true) {
        int sum = findSum(sumLimit);
        if (sum == -1) return Integer.toString(sumLimit);
        sumLimit = sum;
    }
}

private int findSum(int limit) {
    for (int a = 1; a * a < limit; ++a) {
        for (int b = a - 1; b > 0; --b) {
            if ((a + b) % 2 != 0) continue;
            int x = (a * a + b * b) / 2;
            int y = (a * a - b * b) / 2;
            if (x + y + 1 >= limit) continue;
            int zlimit = Math.min(y, limit - x - y);
            for (int c = Library.sqrt(y) + 1; c * c - y < zlimit; ++c) {
                int z = c * c - y;
                if (isSquare[x + z] && isSquare[x - z] && isSquare[y - z]) return x + y + z;
            }
        }
    }
    return -1;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p145().run());
}

public String run() {
    int sum = 0;
    for (int digits = 1; digits <= 9; ++digits) {
        if (digits % 2 == 0) sum += 20 * Library.pow(30, digits / 2 - 1); else if (digits % 4 == 3) sum += 100 * Library.pow(500, (digits - 3) / 4); else if (digits % 4 == 1) sum += 0; else throw new AssertionError();
    }
    return Integer.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p146().run());
}

public String run() {
    long sum = 0;
    for (int n = 0; n < LIMIT; n += 10) {
        if (hasConsecutivePrimes(n)) sum += n;
    }
    return Long.toString(sum);
}

private static boolean hasConsecutivePrimes(int n) {
    long n2 = (long)n * n;
    long[] temp = new long[INCREMENTS.length];
    for (int i = 0; i < INCREMENTS.length; ++i) temp[i] = n2 + INCREMENTS[i];
    for (/*synthetic*/ int[] arr$ = primes, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int p = arr$[i$];
        {
            for (/*synthetic*/ long[] arr$ = temp, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
                long x = arr$[i$];
                {
                    if (x != p && x % p == 0) return false;
                }
            }
        }
    }
    for (int i = 1; i < INCREMENTS[INCREMENTS.length - 1]; ++i) {
        if (Arrays.binarySearch(INCREMENTS, i) < 0 && isPrime(n2 + i)) return false;
    }
    return true;
}

private static boolean isPrime(long n) {
    int end = (int)Library.sqrt(n);
    for (/*synthetic*/ int[] arr$ = primes, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int p = arr$[i$];
        {
            if (p > end) break;
            if (n != p && n % p == 0) return false;
        }
    }
    return true;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p149().run());
}

public String run() {
    grid = new int[SIZE][SIZE];
    p149$LfgRandom rand = new p149$LfgRandom();
    for (int y = 0; y < grid.length; ++y) {
        for (int x = 0; x < grid[y].length; ++x) grid[y][x] = rand.next();
    }
    int max = 0;
    for (int i = 0; i < SIZE; ++i) {
        max = Math.max(getMaxSubstringSum(0, i, +1, 0), max);
        max = Math.max(getMaxSubstringSum(i, 0, 0, +1), max);
        max = Math.max(getMaxSubstringSum(0, i, +1, +1), max);
        max = Math.max(getMaxSubstringSum(i, 0, +1, +1), max);
        max = Math.max(getMaxSubstringSum(i, 0, -1, +1), max);
        max = Math.max(getMaxSubstringSum(SIZE - 1, i, -1, +1), max);
    }
    return Integer.toString(max);
}

private int getMaxSubstringSum(int x, int y, int dx, int dy) {
    int max = 0;
    for (int cur = 0; 0 <= x && x < SIZE && 0 <= y && y < SIZE; x += dx, y += dy) {
        cur = Math.max(cur + grid[y][x], 0);
        max = Math.max(cur, max);
    }
    return max;
}

public <init>() {
    super();
    k = 1;
    history = new int[55];
    index = 0;
}
STATEMENT:
super();
STATEMENT:
k = 1;
STATEMENT:
history = new int[55];
STATEMENT:
index = 0;

public int next() {
    int result;
    if (k <= 55) {
        result = (int)((100003L - 200003L * k + 300007L * k * k * k) % 1000000) - 500000;
        ++k;
    } else {
        result = (getHistory(24) + getHistory(55) + 1000000) % 1000000 - 500000;
    }
    history[index] = result;
    index = (index + 1) % history.length;
    return result;
}

private int getHistory(int n) {
    if (n <= 0 || n > history.length) throw new IllegalArgumentException();
    return history[(index - n + history.length) % history.length];
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p150().run());
}

public String run() {
    p150$LcgRandom rand = new p150$LcgRandom();
    int[][] triangle = new int[ROWS][];
    for (int i = 0; i < triangle.length; ++i) {
        triangle[i] = new int[i + 1];
        for (int j = 0; j <= i; ++j) triangle[i][j] = rand.next();
    }
    int[][] rowSums = new int[triangle.length][];
    for (int i = 0; i < rowSums.length; ++i) {
        rowSums[i] = new int[triangle[i].length + 1];
        rowSums[i][0] = 0;
        for (int j = 0; j <= i; ++j) rowSums[i][j + 1] = rowSums[i][j] + triangle[i][j];
    }
    long minSum = 0;
    for (int i = 0; i < triangle.length; ++i) {
        for (int j = 0; j < triangle[i].length; ++j) {
            long curSum = 0;
            for (int k = i; k < triangle.length; ++k) {
                curSum += rowSums[k][k - i + 1 + j] - rowSums[k][j];
                minSum = Math.min(curSum, minSum);
            }
        }
    }
    return Long.toString(minSum);
}

public <init>() {
    super();
    state = 0;
}
STATEMENT:
super();
STATEMENT:
state = 0;

public int next() {
    state = (615949 * state + 797807) & ((1 << 20) - 1);
    return state - (1 << 19);
}

public <init>() {
    super();
    expectedSingles = new HashMap();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p151().run());
}

public String run() {
    List startState = Arrays.asList(new Integer[]{Integer.valueOf(1)});
    return String.format("%.6f", new Object[]{Double.valueOf(getExpectedSingles(startState) - 2)});
}

private double getExpectedSingles(List state) {
    if (expectedSingles.containsKey(state)) return ((Double)expectedSingles.get(state)).doubleValue();
    double result = 0;
    if (!state.isEmpty()) {
        for (int i = 0; i < state.size(); ++i) {
            List newState = new ArrayList(state);
            int sheet = ((Integer)state.get(i)).intValue();
            newState.remove(i);
            for (int j = sheet + 1; j <= 5; ++j) newState.add(Integer.valueOf(j));
            Collections.sort(newState);
            result += getExpectedSingles(newState);
        }
        result /= state.size();
        if (state.size() == 1) ++result;
    }
    expectedSingles.put(state, Double.valueOf(result));
    return result;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p155().run());
}

public String run() {
    @SuppressWarnings(value = "unchecked")
    Set[] possible = new Set[SIZE + 1];
    Set all = new HashSet();
    possible[0] = new HashSet();
    possible[1] = new HashSet();
    possible[1].add(new p155$FastFraction(60, 1));
    all.addAll(possible[1]);
    for (int i = 2; i <= SIZE; ++i) {
        Set poss = new HashSet();
        for (int j = 1; j <= i - j; ++j) {
            for (/*synthetic*/ java.util.Iterator i$ = possible[j].iterator(); i$.hasNext(); ) {
                p155$FastFraction a = (p155$FastFraction)i$.next();
                {
                    for (/*synthetic*/ java.util.Iterator i$ = possible[i - j].iterator(); i$.hasNext(); ) {
                        p155$FastFraction b = (p155$FastFraction)i$.next();
                        {
                            poss.add(a.add(b));
                            poss.add(a.reciprocalAdd(b));
                        }
                    }
                }
            }
        }
        possible[i] = poss;
        all.addAll(poss);
    }
    return Integer.toString(all.size());
}

public <init>(long num, long den) {
    super();
    if (den <= 0) throw new IllegalArgumentException();
    int n = (int)num;
    int d = (int)den;
    if (n == num && d == den) {
        int gcd = Library.gcd(n, d);
        if (gcd > 1) {
            n /= gcd;
            d /= gcd;
        }
        numerator = n;
        denominator = d;
        bigFraction = null;
    } else {
        p155$FastFraction temp = new p155$FastFraction(new Fraction(BigInteger.valueOf(num), BigInteger.valueOf(den)));
        numerator = temp.numerator;
        denominator = temp.denominator;
        bigFraction = temp.bigFraction;
    }
}
STATEMENT:
super();
STATEMENT:
if (den <= 0) throw new IllegalArgumentException();
STATEMENT:
int n = (int)num
STATEMENT:
int d = (int)den
STATEMENT:
if (n == num && d == den) {
    int gcd = Library.gcd(n, d);
    if (gcd > 1) {
        n /= gcd;
        d /= gcd;
    }
    numerator = n;
    denominator = d;
    bigFraction = null;
} else {
    p155$FastFraction temp = new p155$FastFraction(new Fraction(BigInteger.valueOf(num), BigInteger.valueOf(den)));
    numerator = temp.numerator;
    denominator = temp.denominator;
    bigFraction = temp.bigFraction;
}

public <init>(Fraction frac) {
    super();
    if (frac.numerator.bitLength() <= 31 && frac.denominator.bitLength() <= 31) {
        numerator = frac.numerator.intValue();
        denominator = frac.denominator.intValue();
        bigFraction = null;
    } else {
        numerator = 0;
        denominator = 0;
        bigFraction = frac;
    }
}
STATEMENT:
super();
STATEMENT:
if (frac.numerator.bitLength() <= 31 && frac.denominator.bitLength() <= 31) {
    numerator = frac.numerator.intValue();
    denominator = frac.denominator.intValue();
    bigFraction = null;
} else {
    numerator = 0;
    denominator = 0;
    bigFraction = frac;
}

public Fraction toFraction() {
    if (bigFraction == null) return new Fraction(BigInteger.valueOf(numerator), BigInteger.valueOf(denominator)); else return bigFraction;
}

public p155$FastFraction add(p155$FastFraction other) {
    if (bigFraction == null && other.bigFraction == null) {
        long num = (long)numerator * other.denominator + (long)other.numerator * denominator;
        long den = (long)denominator * other.denominator;
        return new p155$FastFraction(num, den);
    } else return new p155$FastFraction(toFraction().add(other.toFraction()));
}

public p155$FastFraction reciprocalAdd(p155$FastFraction other) {
    if (bigFraction == null && other.bigFraction == null) {
        long num = (long)numerator * other.numerator;
        long den = (long)numerator * other.denominator + (long)other.numerator * denominator;
        return new p155$FastFraction(num, den);
    } else {
        Fraction x = this.toFraction();
        Fraction y = other.toFraction();
        return new p155$FastFraction(x.multiply(y).divide(x.add(y)));
    }
}

public boolean equals(Object obj) {
    if (!(obj instanceof p155$FastFraction)) return false;
    p155$FastFraction other = (p155$FastFraction)(p155$FastFraction)obj;
    if (bigFraction == null && other.bigFraction == null) return numerator == other.numerator && denominator == other.denominator; else return toFraction().equals(other.toFraction());
}

public int hashCode() {
    if (bigFraction == null) return numerator + denominator * 1204805; else return bigFraction.hashCode();
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p160().run());
}

public String run() {
    return Long.toString(factorialSuffix(1000000000000L));
}

private static long factorialSuffix(long n) {
    long twos = countFactors(n, 2) - countFactors(n, 5);
    if (twos >= 2505) twos = (twos - 5) % 2500 + 5;
    return factorialish(n) * Library.powMod(2, (int)twos, 100000) % 100000;
}

private static long factorialish(long n) {
    return evenFactorialish(n) * oddFactorialish(n) % 100000;
}

private static long evenFactorialish(long n) {
    if (n == 0) return 1; else return factorialish(n / 2);
}

private static long oddFactorialish(long n) {
    if (n == 0) return 1; else return oddFactorialish(n / 5) * factorialCoprime(n) % 100000;
}

private static long factorialCoprime(long n) {
    n %= 100000;
    long product = 1;
    for (int i = 1; i <= n; ++i) {
        if (i % 2 != 0 && i % 5 != 0) product = i * product % 100000;
    }
    return product;
}

private static long countFactors(long end, long n) {
    if (end == 0) return 0; else return end / n + countFactors(end / n, n);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p162().run());
}

public String run() {
    BigInteger sum = BigInteger.ZERO;
    for (int n = 1; n <= 16; ++n) {
        sum = sum.add(bi(15).multiply(bi(16).pow(n - 1))).subtract(bi(43).multiply(bi(15).pow(n - 1))).add(bi(41).multiply(bi(14).pow(n - 1))).subtract(bi(13).pow(n));
    }
    return sum.toString(16).toUpperCase();
}

private static BigInteger bi(int n) {
    return BigInteger.valueOf(n);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p164().run());
}

public String run() {
    BigInteger[][] ways = new BigInteger[DIGITS + CONSECUTIVE + 1][Library.pow(BASE, CONSECUTIVE)];
    ways[0][0] = BigInteger.ONE;
    for (int prefix = 1; prefix < ways[0].length; ++prefix) ways[0][prefix] = BigInteger.ZERO;
    for (int digits = 1; digits < ways.length; ++digits) {
        for (int prefix = 0; prefix < ways[digits].length; ++prefix) {
            BigInteger sum = BigInteger.ZERO;
            if (digitSum(prefix) <= MAX_SUM) {
                for (int nextDigit = 0; nextDigit < BASE; ++nextDigit) sum = sum.add(ways[digits - 1][prefix % Library.pow(BASE, CONSECUTIVE - 1) * BASE + nextDigit]);
            }
            ways[digits][prefix] = sum;
        }
    }
    return ways[DIGITS + CONSECUTIVE][0].subtract(ways[DIGITS + CONSECUTIVE - 1][0]).toString();
}

private static int digitSum(int n) {
    int sum = 0;
    for (; n != 0; n /= 10) sum += n % 10;
    return sum;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p166().run());
}

public String run() {
    int count = 0;
    int[] num = new int[8];
    do {
        int a = num[0];
        int b = num[1];
        int c = num[2];
        int d = num[3];
        int e = num[4];
        int g = num[5];
        int i = num[6];
        int k = num[7];
        int m = b + c + d - e - i;
        if (m < 0 || m > 9) continue;
        int o = a + b + d - g - k;
        if (o < 0 || o > 9) continue;
        int j = a + b + c - g - m;
        if (j < 0 || j > 9) continue;
        int l = a + b + c + d - i - j - k;
        if (l < 0 || l > 9) continue;
        int f = b + c + d * 2 - e - i - k;
        if (f < 0 || f > 9) continue;
        int h = a + b + c + d - e - f - g;
        if (h < 0 || h > 9) continue;
        int n = a + c + d - f - j;
        if (n < 0 || n > 9) continue;
        int p = a + b + c - h - l;
        if (p < 0 || p > 9) continue;
        ++count;
    }     while (increment(num));
    return Integer.toString(count);
}

private static boolean increment(int[] num) {
    int i = 0;
    while (num[i] == 9) {
        num[i] = 0;
        ++i;
        if (i == num.length) return false;
    }
    ++num[i];
    return true;
}

public <init>() {
    super();
    ways = new HashMap();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p169().run());
}

public String run() {
    return countWays(NUMBER, NUMBER.bitLength() - 1, 2).toString();
}

private BigInteger countWays(BigInteger number, int exponent, int repetitions) {
    List key = Arrays.asList(new BigInteger[]{number, BigInteger.valueOf(exponent), BigInteger.valueOf(repetitions)});
    if (ways.containsKey(key)) return (BigInteger)ways.get(key);
    BigInteger result;
    if (exponent < 0) result = number.equals(BigInteger.ZERO) ? BigInteger.ONE : BigInteger.ZERO; else {
        result = countWays(number, exponent - 1, 2);
        BigInteger pow = BigInteger.ONE.shiftLeft(exponent);
        BigInteger upper = pow.multiply(BigInteger.valueOf(repetitions + 2));
        if (repetitions > 0 && pow.compareTo(number) <= 0 && number.compareTo(upper) < 0) result = result.add(countWays(number.subtract(pow), exponent, repetitions - 1));
    }
    ways.put(key, result);
    return result;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p171().run());
}

public String run() {
    int MAX_SQR_DIGIT_SUM = (BASE - 1) * (BASE - 1) * LENGTH;
    long[][] sum = new long[LENGTH + 1][MAX_SQR_DIGIT_SUM + 1];
    long[][] count = new long[LENGTH + 1][MAX_SQR_DIGIT_SUM + 1];
    count[0][0] = 1;
    for (int i = 1; i <= LENGTH; ++i) {
        for (int j = 0; j < BASE; ++j) {
            for (int k = 0; k + j * j <= MAX_SQR_DIGIT_SUM; ++k) {
                sum[i][k + j * j] = (sum[i][k + j * j] + sum[i - 1][k] + Library.powMod(BASE, i - 1, MODULUS) * j % MODULUS * count[i - 1][k]) % MODULUS;
                count[i][k + j * j] = (count[i][k + j * j] + count[i - 1][k]) % MODULUS;
            }
        }
    }
    long s = 0;
    for (int i = 1; i * i <= MAX_SQR_DIGIT_SUM; ++i) s = (s + sum[LENGTH][i * i]) % MODULUS;
    return String.format("%09d", new Object[]{Long.valueOf(s)});
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p172().run());
}

public String run() {
    BigInteger ways = partitionAndCount(LENGTH, MAX_COUNT, new ArrayList());
    BigInteger BASE_BI = BigInteger.valueOf(BASE);
    ways = ways.multiply(BASE_BI.subtract(BigInteger.ONE));
    ways = divideExactly(ways, BASE_BI);
    return ways.toString();
}

private BigInteger partitionAndCount(int sum, int max, List terms) {
    if (terms.size() == BASE) {
        if (sum == 0) return countWays(terms); else return BigInteger.ZERO;
    } else {
        BigInteger result = BigInteger.ZERO;
        for (int i = Math.min(max, sum); i >= 0; --i) {
            terms.add(Integer.valueOf(i));
            result = result.add(partitionAndCount(sum - i, i, terms));
            terms.remove(terms.size() - 1);
        }
        return result;
    }
}

private BigInteger countWays(List freqs) {
    int[] histogram = new int[MAX_COUNT + 1];
    for (/*synthetic*/ java.util.Iterator i$ = freqs.iterator(); i$.hasNext(); ) {
        int x = ((Integer)i$.next()).intValue();
        ++histogram[x];
    }
    BigInteger ways = Library.factorial(BASE);
    for (/*synthetic*/ int[] arr$ = histogram, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        ways = ways.divide(Library.factorial(x));
    }
    ways = ways.multiply(Library.factorial(LENGTH));
    for (/*synthetic*/ java.util.Iterator i$ = freqs.iterator(); i$.hasNext(); ) {
        int x = ((Integer)i$.next()).intValue();
        ways = ways.divide(Library.factorial(x));
    }
    return ways;
}

private static BigInteger divideExactly(BigInteger x, BigInteger y) {
    BigInteger[] temp = x.divideAndRemainder(y);
    if (temp[1].signum() != 0) throw new IllegalArgumentException("Not divisible");
    return temp[0];
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p173().run());
}

public String run() {
    int count = 0;
    for (int n = 3; n <= TILES / 4 + 1; ++n) {
        for (int k = n - 2; k >= 1; k -= 2) {
            if ((long)n * n - (long)k * k > TILES) break;
            ++count;
        }
    }
    return Integer.toString(count);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p174().run());
}

public String run() {
    int[] type = new int[SIZE_LIMIT + 1];
    for (int n = 3; (n - 1) * 4 <= SIZE_LIMIT; ++n) {
        for (int m = n - 2; m >= 1; m -= 2) {
            int tiles = n * n - m * m;
            if (tiles > SIZE_LIMIT) break;
            ++type[tiles];
        }
    }
    int count = 0;
    for (/*synthetic*/ int[] arr$ = type, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int t = arr$[i$];
        {
            if (1 <= t && t <= TYPE_LIMIT) ++count;
        }
    }
    return Integer.toString(count);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p178().run());
}

public String run() {
    BigInteger[][][][] ways = new BigInteger[LIMIT + 1][10][10][10];
    BigInteger sum = BigInteger.ZERO;
    for (int digits = 0; digits < ways.length; ++digits) {
        for (int head = 0; head < 10; ++head) {
            for (int low = 0; low < 10; ++low) {
                for (int high = 0; high < 10; ++high) {
                    BigInteger val;
                    if (digits <= 1) val = (low == head && head == high) ? BigInteger.ONE : BigInteger.ZERO; else {
                        val = BigInteger.ZERO;
                        BigInteger[][][] prevWays = ways[digits - 1];
                        if (head - 1 >= low) {
                            val = val.add(prevWays[head - 1][low][high]);
                            if (head == high) val = val.add(prevWays[head - 1][low][high - 1]);
                        }
                        if (head + 1 <= high) {
                            val = val.add(prevWays[head + 1][low][high]);
                            if (head == low) val = val.add(prevWays[head + 1][low + 1][high]);
                        }
                    }
                    ways[digits][head][low][high] = val;
                    if (head > 0 && low == 0 && high == 9) sum = sum.add(val);
                }
            }
        }
    }
    return sum.toString();
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p179().run());
}

public String run() {
    int[] numDivisors = new int[LIMIT + 1];
    Arrays.fill(numDivisors, 2);
    for (int i = 2; i < numDivisors.length; ++i) {
        for (int j = i * 2; j < numDivisors.length; j += i) ++numDivisors[j];
    }
    int count = 0;
    for (int i = 2; i < numDivisors.length - 1; ++i) {
        if (numDivisors[i] == numDivisors[i + 1]) ++count;
    }
    return Integer.toString(count);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p182().run());
}

public String run() {
    int[] numUnconcealedP = countAllUnconcealed(P);
    int[] numUnconcealedQ = countAllUnconcealed(Q);
    int minUnconcealedP = Integer.MAX_VALUE;
    for (/*synthetic*/ int[] arr$ = numUnconcealedP, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        minUnconcealedP = Math.min(x, minUnconcealedP);
    }
    int minUnconcealedQ = Integer.MAX_VALUE;
    for (/*synthetic*/ int[] arr$ = numUnconcealedQ, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        minUnconcealedQ = Math.min(x, minUnconcealedQ);
    }
    long sum = 0;
    for (int e = 0; e < TOTIENT; ++e) {
        if (numUnconcealedP[e % (P - 1)] == minUnconcealedP && numUnconcealedQ[e % (Q - 1)] == minUnconcealedQ) sum += e;
    }
    return Long.toString(sum);
}

private static int[] countAllUnconcealed(int prime) {
    int[] numUnconcealed = new int[prime - 1];
    for (int e = 0; e < numUnconcealed.length; ++e) {
        if (Library.gcd(e, prime - 1) == 1) numUnconcealed[e] = countUnconcealed(prime, e); else numUnconcealed[e] = Integer.MAX_VALUE;
    }
    return numUnconcealed;
}

private static int countUnconcealed(int modulus, int e) {
    int count = 0;
    for (int m = 0; m < modulus; ++m) {
        if (Library.powMod(m, e, modulus) == m) ++count;
    }
    return count;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p186().run());
}

public String run() {
    p186$DisjointSet ds = new p186$DisjointSet(1000000);
    p186$LfgRandom rand = new p186$LfgRandom();
    int i = 0;
    while (ds.size(524287) < 990000) {
        int caller = rand.next();
        int callee = rand.next();
        if (caller != callee) {
            ds.union(caller, callee);
            ++i;
        }
    }
    return Integer.toString(i);
}

public <init>(int size) {
    super();
    nodes = new p186$DisjointSet$Node[size];
    for (int i = 0; i < size; ++i) nodes[i] = new p186$DisjointSet$Node();
}
STATEMENT:
super();
STATEMENT:
nodes = new p186$DisjointSet$Node[size];
STATEMENT:
for (int i = 0; i < size; ++i) nodes[i] = new p186$DisjointSet$Node();

private p186$DisjointSet$Node find(int i) {
    return find(nodes[i]);
}

private static p186$DisjointSet$Node find(p186$DisjointSet$Node node) {
    if (node.parent != node) node.parent = find(node.parent);
    return node.parent;
}

public void union(int i, int j) {
    p186$DisjointSet$Node x = find(i);
    p186$DisjointSet$Node y = find(j);
    if (x == y) return;
    if (x.rank == y.rank) ++x.rank; else if (x.rank < y.rank) {
        p186$DisjointSet$Node z = x;
        x = y;
        y = z;
    }
    y.parent = x;
    x.size += y.size;
    y.size = 0;
}

public int size(int i) {
    return find(i).size;
}

public <init>() {
    super();
    parent = this;
    rank = 0;
    size = 1;
}
STATEMENT:
super();
STATEMENT:
parent = this;
STATEMENT:
rank = 0;
STATEMENT:
size = 1;

public <init>() {
    super();
    k = 1;
    history = new int[55];
    index = 0;
}
STATEMENT:
super();
STATEMENT:
k = 1;
STATEMENT:
history = new int[55];
STATEMENT:
index = 0;

public int next() {
    int result;
    if (k <= 55) {
        result = (int)((100003L - 200003L * k + 300007L * k * k * k) % 1000000);
        ++k;
    } else result = (getHistory(24) + getHistory(55)) % 1000000;
    history[index] = result;
    ++index;
    if (index == history.length) index = 0;
    return result;
}

private int getHistory(int n) {
    int i = index - n;
    if (i < 0) i += history.length;
    return history[i];
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p187().run());
}

public String run() {
    int count = 0;
    int[] primes = Library.listPrimes(LIMIT / 2);
    for (int i = 0, sqrt = Library.sqrt(LIMIT); i < primes.length && primes[i] <= sqrt; ++i) {
        int end = Arrays.binarySearch(primes, LIMIT / primes[i]);
        if (end >= 0) ++end; else end = -end - 1;
        count += end - i;
    }
    return Integer.toString(count);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p188().run());
}

public String run() {
    return Integer.toString(tetrationMod(1777, 1855, Library.pow(10, 8)));
}

private static int tetrationMod(int x, int y, int m) {
    if (y == 1) return x % m; else return Library.powMod(x, tetrationMod(x, y - 1, Library.totient(m)), m);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p191().run());
}

public String run() {
    long[][][] numPrizeStrings = new long[NUM_DAYS + 1][MAX_ABSENT + 1][MAX_LATE + 1];
    numPrizeStrings[0][0][0] = 1;
    for (int i = 1; i <= NUM_DAYS; ++i) {
        for (int j = 0; j <= MAX_ABSENT; ++j) {
            for (int k = 0; k <= MAX_LATE; ++k) {
                long sum;
                if (j == 0) {
                    sum = 0;
                    for (int l = 0; l <= MAX_ABSENT; ++l) sum += numPrizeStrings[i - 1][l][k];
                    if (k > 0) {
                        for (int l = 0; l <= MAX_ABSENT; ++l) sum += numPrizeStrings[i - 1][l][k - 1];
                    }
                } else sum = numPrizeStrings[i - 1][j - 1][k];
                numPrizeStrings[i][j][k] = sum;
            }
        }
    }
    long sum = 0;
    for (int j = 0; j <= MAX_ABSENT; ++j) {
        for (int k = 0; k <= MAX_LATE; ++k) sum += numPrizeStrings[NUM_DAYS][j][k];
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p197().run());
}

public String run() {
    double x = -1;
    double y = -1;
    long i = 0;
    for (; i < ITERATIONS; ++i) {
        if (i > 0 && x == y) break;
        x = f(x);
        y = f(f(y));
    }
    long remain = (ITERATIONS - i) % i;
    for (; remain > 0; --remain) x = f(x);
    double answer = x + f(x);
    answer = Math.floor(answer * 1.0E9) / 1.0E9;
    return String.format("%.9f", new Object[]{Double.valueOf(answer)});
}

private static double f(double x) {
    return Math.floor(Math.pow(2, 30.403243784 - x * x)) / 1.0E9;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p203().run());
}

public String run() {
    Set numbers = new HashSet();
    long max = 0;
    for (int n = 0; n <= 50; ++n) {
        for (int k = 0; k <= n; ++k) {
            BigInteger x = Library.binomial(n, k);
            if (x.bitLength() >= 64) throw new AssertionError("Number too large to handle");
            numbers.add(Long.valueOf(x.longValue()));
            max = Math.max(x.longValue(), max);
        }
    }
    int[] primes = Library.listPrimes((int)Library.sqrt(max));
    primesSquared = new long[primes.length];
    for (int i = 0; i < primes.length; ++i) primesSquared[i] = (long)primes[i] * primes[i];
    long sum = 0;
    for (/*synthetic*/ java.util.Iterator i$ = numbers.iterator(); i$.hasNext(); ) {
        long n = ((Long)i$.next()).longValue();
        {
            if (isSquarefree(n)) sum += n;
        }
    }
    return Long.toString(sum);
}

private boolean isSquarefree(long n) {
    for (/*synthetic*/ long[] arr$ = primesSquared, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        long p2 = arr$[i$];
        {
            if (p2 > n) break;
            if (n % p2 == 0) return false;
        }
    }
    return true;
}

public <init>() {
    super();
    primes = Library.listPrimes(100);
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p204().run());
}

public String run() {
    return Integer.toString(count(0, 1));
}

private int count(int primeIndex, long product) {
    if (primeIndex == primes.length) return product <= LIMIT ? 1 : 0; else {
        int count = 0;
        while (product <= LIMIT) {
            count += count(primeIndex + 1, product);
            product *= primes[primeIndex];
        }
        return count;
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p205().run());
}

public String run() {
    int[] ninePyramidalPdf = {1};
    for (int i = 0; i < 9; ++i) ninePyramidalPdf = convolve(ninePyramidalPdf, PYRAMIDAL_DIE_PDF);
    int[] sixCubicPdf = {1};
    for (int i = 0; i < 6; ++i) sixCubicPdf = convolve(sixCubicPdf, CUBIC_DIE_PDF);
    long numer = 0;
    for (int i = 0; i < ninePyramidalPdf.length; ++i) numer += (long)ninePyramidalPdf[i] * sum(sixCubicPdf, 0, i);
    long denom = (long)sum(ninePyramidalPdf, 0, ninePyramidalPdf.length) * sum(sixCubicPdf, 0, sixCubicPdf.length);
    return String.format("%.7f", new Object[]{Double.valueOf((double)numer / denom)});
}

private static int[] convolve(int[] a, int[] b) {
    int[] c = new int[a.length + b.length - 1];
    for (int i = 0; i < a.length; ++i) {
        for (int j = 0; j < b.length; ++j) c[i + j] += a[i] * b[j];
    }
    return c;
}

private static int sum(int[] array, int start, int end) {
    int sum = 0;
    for (int i = start; i < end; ++i) sum += array[i];
    return sum;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p206().run());
}

public String run() {
    long n = 1000000000;
    int[] ndigits = new int[10];
    int[] n2digits = new int[19];
    long temp = n;
    for (int i = 0; i < ndigits.length; ++i, temp /= 10) ndigits[i] = (int)(temp % 10);
    temp = n * n;
    for (int i = 0; i < n2digits.length; ++i, temp /= 10) n2digits[i] = (int)(temp % 10);
    while (!isConcealedSquare(n2digits)) {
        add20n(ndigits, n2digits);
        add10Pow(n2digits, 2);
        n += 10;
        add10Pow(ndigits, 1);
    }
    return Long.toString(n);
}

private static boolean isConcealedSquare(int[] n) {
    for (int i = 1; i <= 9; ++i) {
        if (n[20 - i * 2] != i) return false;
    }
    return n[0] == 0;
}

private static void add10Pow(int[] n, int i) {
    while (n[i] == 9) {
        n[i] = 0;
        ++i;
    }
    ++n[i];
}

private static void add20n(int[] n, int[] n2) {
    int carry = 0;
    int i;
    for (i = 0; i < n.length; ++i) {
        int sum = n[i] * 2 + n2[i + 1] + carry;
        n2[i + 1] = sum % 10;
        carry = sum / 10;
    }
    for (++i; carry > 0; ++i) {
        int sum = n2[i] + carry;
        n2[i] = sum % 10;
        carry = sum / 10;
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p208().run());
}

public String run() {
    Map reachable = new HashMap();
    reachable.put(new p208$State(0, 0, 0, 0, 0), BigInteger.ONE);
    for (int i = 0; i < LIMIT; ++i) {
        Map newReachable = new HashMap();
        for (/*synthetic*/ java.util.Iterator i$ = reachable.entrySet().iterator(); i$.hasNext(); ) {
            Map$Entry entry = (Map$Entry)i$.next();
            {
                p208$State state = (p208$State)entry.getKey();
                BigInteger ways = (BigInteger)entry.getValue();
                p208$State acw = state.move(true);
                BigInteger temp = newReachable.containsKey(acw) ? (BigInteger)newReachable.get(acw) : BigInteger.ZERO;
                newReachable.put(acw, temp.add(ways));
                p208$State cw = state.move(false);
                temp = newReachable.containsKey(cw) ? (BigInteger)newReachable.get(cw) : BigInteger.ZERO;
                newReachable.put(cw, temp.add(ways));
            }
        }
        reachable = newReachable;
    }
    BigInteger sum = BigInteger.ZERO;
    for (int dir = 0; dir < 5; ++dir) {
        p208$State st = new p208$State(dir, 0, 0, 0, 0);
        if (reachable.containsKey(st)) sum = sum.add((BigInteger)reachable.get(st));
    }
    return sum.toString();
}

public <init>(int dir, int xComp0, int xComp1, int yComp0, int yComp1) {
    super();
    if (dir < 0 || dir >= 5) throw new IllegalArgumentException();
    direction = dir;
    xComponent0 = xComp0;
    xComponent1 = xComp1;
    yComponent0 = yComp0;
    yComponent1 = yComp1;
}
STATEMENT:
super();
STATEMENT:
if (dir < 0 || dir >= 5) throw new IllegalArgumentException();
STATEMENT:
direction = dir;
STATEMENT:
xComponent0 = xComp0;
STATEMENT:
xComponent1 = xComp1;
STATEMENT:
yComponent0 = yComp0;
STATEMENT:
yComponent1 = yComp1;

public p208$State move(boolean anticlockwise) {
    int sign = anticlockwise ? +1 : -1;
    int[] entry = ANTICLOCKWISE_MOVES[(direction * sign + 5) % 5];
    return new p208$State((direction + sign + 5) % 5, xComponent0 + entry[0] * sign, xComponent1 + entry[1] * sign, yComponent0 + entry[2], yComponent1 + entry[3]);
}

public boolean equals(Object obj) {
    if (!(obj instanceof p208$State)) return false;
    p208$State other = (p208$State)(p208$State)obj;
    return direction == other.direction && xComponent0 == other.xComponent0 && xComponent1 == other.xComponent1 && yComponent0 == other.yComponent0 && yComponent1 == other.yComponent1;
}

public int hashCode() {
    return Objects.hash(new Object[]{Integer.valueOf(direction), Integer.valueOf(xComponent0), Integer.valueOf(xComponent1), Integer.valueOf(yComponent0), Integer.valueOf(yComponent1)});
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p211().run());
}

public String run() {
    isResidue = new boolean[RESIDUE_TEST];
    for (int i = 0; i < RESIDUE_TEST; ++i) isResidue[i * i % RESIDUE_TEST] = true;
    long[] sigma2 = listSigma2(LIMIT - 1);
    long sum = 0;
    for (int i = 1; i < LIMIT; ++i) {
        if (isPerfectSquare(sigma2[i])) sum += i;
    }
    return Long.toString(sum);
}

private static long[] listSigma2(int n) {
    int sqrt = Library.sqrt(n);
    short[] quasiPrimeFactor = new short[n + 1];
    for (int i = 2; i <= sqrt; ++i) {
        if (quasiPrimeFactor[i] == 0) {
            quasiPrimeFactor[i] = (short)i;
            if ((long)i * i <= n) {
                for (int j = i * i; j <= n; j += i) {
                    if (quasiPrimeFactor[j] == 0) quasiPrimeFactor[j] = (short)i;
                }
            }
        }
    }
    long[] sigma2 = new long[n + 1];
    sigma2[1] = 1;
    for (int i = 2; i < sigma2.length; ++i) {
        int p = quasiPrimeFactor[i];
        if (p == 0) p = i;
        long sum = 1;
        int j = i;
        long p2 = (long)p * p;
        for (long k = p2; j % p == 0; j /= p, k *= p2) sum += k;
        sigma2[i] = sum * sigma2[j];
    }
    return sigma2;
}

private boolean isPerfectSquare(long x) {
    if (!isResidue[(int)(x % RESIDUE_TEST)]) return false;
    long y = 0;
    for (long i = 1L << 31; i != 0; i >>>= 1) {
        y |= i;
        if (y > 3037000499L || y * y > x) y ^= i;
    }
    return y * y == x;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p214().run());
}

public String run() {
    int[] totient = Library.listTotients(LIMIT - 1);
    int[] totientChainLength = new int[totient.length];
    totientChainLength[0] = 0;
    long sum = 0;
    for (int i = 1; i < totient.length; ++i) {
        int chainlen = totientChainLength[totient[i]] + 1;
        totientChainLength[i] = chainlen;
        if (chainlen == 25 && totient[i] == i - 1) sum += i;
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p215().run());
}

public String run() {
    List crackPositions = new ArrayList();
    getCrackPositions(new Stack(), 0, crackPositions);
    BigInteger[] ways = new BigInteger[crackPositions.size()];
    Arrays.fill(ways, BigInteger.ONE);
    for (int i = 1; i < HEIGHT; ++i) {
        BigInteger[] newWays = new BigInteger[ways.length];
        for (int j = 0; j < newWays.length; ++j) {
            BigInteger sum = BigInteger.ZERO;
            for (int k = 0; k < ways.length; ++k) {
                if (areDisjointSorted((int[])crackPositions.get(j), (int[])crackPositions.get(k))) sum = sum.add(ways[k]);
            }
            newWays[j] = sum;
        }
        ways = newWays;
    }
    BigInteger sum = BigInteger.ZERO;
    for (/*synthetic*/ BigInteger[] arr$ = ways, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        BigInteger x = arr$[i$];
        sum = sum.add(x);
    }
    return sum.toString();
}

private static void getCrackPositions(Stack cracks, int position, List result) {
    if (position < 0) throw new IllegalArgumentException(); else if (position < WIDTH) {
        for (int i = 2; i <= 3; ++i) {
            cracks.push(Integer.valueOf(position + i));
            getCrackPositions(cracks, position + i, result);
            cracks.pop();
        }
    } else if (position == WIDTH) {
        int[] temp = new int[cracks.size() - 1];
        for (int i = 0; i < temp.length; ++i) temp[i] = ((Integer)cracks.get(i)).intValue();
        result.add(temp);
    } else return;
}

private static boolean areDisjointSorted(int[] a, int[] b) {
    for (int i = 0, j = 0; i < a.length && j < b.length; ) {
        if (a[i] == b[j]) return false; else if (a[i] < b[j]) ++i; else if (a[i] > b[j]) ++j; else throw new AssertionError();
    }
    return true;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p216().run());
}

public String run() {
    long[] sequence = new long[LIMIT + 1];
    sequence[0] = sequence[1] = -1;
    for (int i = 2; i < sequence.length; ++i) sequence[i] = 2L * i * i - 1;
    int count = 0;
    for (int i = 2; i < sequence.length; ++i) {
        long term = sequence[i];
        if (term == 2L * i * i - 1) ++count;
        if (1 < term && term <= LIMIT * 2) {
            int p = (int)term;
            for (int j = i + p; j < sequence.length; j += p) {
                if (!$assertionsDisabled && !(sequence[j] % p == 0)) throw new AssertionError();
                do sequence[j] /= p;                 while (sequence[j] % p == 0);
            }
            for (int j = i + (p - i) * 2 % p; j < sequence.length; j += p) {
                if (!$assertionsDisabled && !(sequence[j] % p == 0)) throw new AssertionError();
                do sequence[j] /= p;                 while (sequence[j] % p == 0);
            }
        }
    }
    return Integer.toString(count);
}
IF:
if (!$assertionsDisabled && !(sequence[j] % p == 0)) throw new AssertionError();
1
assert sequence[j] % p == 0;
sequence[j] % p == 0
2147432463
Node[6270168]
13
2
IF:
if (!$assertionsDisabled && !(sequence[j] % p == 0)) throw new AssertionError();
2
assert sequence[j] % p == 0;
sequence[j] % p == 0
1652598086
Node[6272844]
13
3

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p218().run());
}

public String run() {
    return "0";
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p222().run());
}

public String run() {
    sphereRadii = new double[21];
    for (int i = 0; i < sphereRadii.length; ++i) sphereRadii[i] = (i + 30) * 1000;
    minLength = new double[sphereRadii.length][1 << sphereRadii.length];
    double min = Double.POSITIVE_INFINITY;
    for (int i = 0; i < sphereRadii.length; ++i) min = Math.min(findMinimumLength(i, (1 << sphereRadii.length) - 1) + sphereRadii[i], min);
    return Long.toString(Math.round(min));
}

private double findMinimumLength(int currentSphereIndex, int setOfSpheres) {
    if ((setOfSpheres & (1 << currentSphereIndex)) == 0) throw new IllegalArgumentException();
    if (minLength[currentSphereIndex][setOfSpheres] == 0) {
        double result;
        if (Integer.bitCount(setOfSpheres) == 1) result = sphereRadii[currentSphereIndex]; else {
            result = Double.POSITIVE_INFINITY;
            int newSetOfSpheres = setOfSpheres ^ (1 << currentSphereIndex);
            for (int i = 0; i < sphereRadii.length; ++i) {
                if ((newSetOfSpheres & (1 << i)) == 0) continue;
                double temp = Math.sqrt((sphereRadii[i] + sphereRadii[currentSphereIndex] - 50000) * 200000);
                temp += findMinimumLength(i, newSetOfSpheres);
                result = Math.min(temp, result);
            }
        }
        minLength[currentSphereIndex][setOfSpheres] = result;
    }
    return minLength[currentSphereIndex][setOfSpheres];
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p225().run());
}

public String run() {
    int count = 0;
    for (int i = 1; ; i += 2) {
        if (!hasTribonacciMultiple(i)) {
            ++count;
            if (count == INDEX) return Integer.toString(i);
        }
    }
}

private static boolean hasTribonacciMultiple(int modulus) {
    int[] slow = {1, 1, 1};
    int[] fast = (int[])slow.clone();
    for (boolean head = true; ; head = false) {
        if (slow[0] % modulus == 0) return true;
        if (!head && Arrays.equals(slow, fast)) return false;
        tribonacci(slow, modulus);
        tribonacci(fast, modulus);
        tribonacci(fast, modulus);
    }
}

private static void tribonacci(int[] state, int mod) {
    int a = state[0];
    int b = state[1];
    int c = state[2];
    state[0] = b;
    state[1] = c;
    state[2] = (a + b + c) % mod;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p231().run());
}

public String run() {
    smallestPrimeFactor = Library.listSmallestPrimeFactors(N);
    return Long.toString(factorialPrimeFactorSum(N) - factorialPrimeFactorSum(K) - factorialPrimeFactorSum(N - K));
}

private long factorialPrimeFactorSum(int n) {
    long sum = 0;
    for (int i = 1; i <= n; ++i) {
        int j = i;
        while (j > 1) {
            int p = smallestPrimeFactor[j];
            sum += p;
            j /= p;
        }
    }
    return sum;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p243().run());
}

public String run() {
    BigInteger totient = BigInteger.ONE;
    BigInteger denominator = BigInteger.ONE;
    for (int p = 2; ; ) {
        totient = totient.multiply(BigInteger.valueOf(p - 1));
        denominator = denominator.multiply(BigInteger.valueOf(p));
        do ++p;         while (!Library.isPrime(p));
        if (new Fraction(totient, denominator).compareTo(TARGET) < 0) {
            for (int i = 1; i < p; ++i) {
                BigInteger numer = BigInteger.valueOf(i).multiply(totient);
                BigInteger denom = BigInteger.valueOf(i).multiply(denominator);
                if (new Fraction(numer, denom.subtract(BigInteger.ONE)).compareTo(TARGET) < 0) return denom.toString();
            }
        }
    }
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p249().run());
}

public String run() {
    boolean[] isPrime = Library.listPrimality(LIMIT * LIMIT / 2);
    long[] numSubsets = new long[LIMIT * LIMIT / 2];
    numSubsets[0] = 1;
    int maxSum = 0;
    for (int i = 0; i < LIMIT; ++i) {
        if (!isPrime[i]) continue;
        maxSum += i;
        for (int j = maxSum; j >= i; --j) {
            long temp = numSubsets[j] + numSubsets[j - i];
            if (temp < MODULUS) numSubsets[j] = temp; else numSubsets[j] = temp - MODULUS;
        }
    }
    long sum = 0;
    for (int i = 0; i < numSubsets.length; ++i) {
        if (isPrime[i]) sum = (sum + numSubsets[i]) % MODULUS;
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p250().run());
}

public String run() {
    long[] numSubsets = new long[250];
    numSubsets[0] = 1;
    for (int i = 1; i <= 250250; ++i) {
        int temp = Library.powMod(i, i, 250);
        long[] newArray = new long[numSubsets.length];
        for (int j = 0; j < 250; ++j) newArray[(j + temp) % 250] = (numSubsets[j] + numSubsets[(j + temp) % 250]) % MODULUS;
        numSubsets = newArray;
    }
    return Long.toString((numSubsets[0] - 1 + MODULUS) % MODULUS);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p265().run());
}

public String run() {
    long sum = 0;
    int start = (1 << (TWO_POW_N - N - 1)) + 1;
    int end = 1 << (TWO_POW_N - N);
    for (int i = start; i < end; i += 2) {
        if (checkArrangement(i)) sum += i;
    }
    return Long.toString(sum);
}

private static boolean checkArrangement(int digits) {
    int seen = 0;
    long temp = (digits & 4294967295L) | ((digits & 4294967295L) << TWO_POW_N);
    for (int i = 0; i < TWO_POW_N; ++i) seen |= 1 << ((int)(temp >>> i) & MASK);
    return seen == FULL_SET;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p267().run());
}

public String run() {
    int maxIndex = -1;
    int prevChangeLevel = 1;
    for (int level = 1; level - prevChangeLevel <= 8; ++level) {
        if (level > 30) throw new AssertionError();
        double scaler = Math.pow(2, -level);
        for (int i = 1, end = 1 << level; i < end; i += 2) {
            int index = calcBillionaireProbability(i * scaler);
            if (index > maxIndex) {
                maxIndex = index;
                prevChangeLevel = level;
            }
        }
    }
    BigInteger binomialSum = BigInteger.ZERO;
    for (int i = 0; i < maxIndex; ++i) binomialSum = binomialSum.add(Library.binomial(TRIALS, i));
    BigInteger denominator = BigInteger.ONE.shiftLeft(TRIALS);
    return roundToDecimal(new Fraction(binomialSum, denominator), 12);
}

private static int calcBillionaireProbability(double betProportion) {
    double initCapital = 1;
    int i;
    for (i = 0; i <= TRIALS; ++i) {
        double finalCapital = initCapital * Math.pow(1 - betProportion, i) * Math.pow(1 + betProportion * 2, TRIALS - i);
        if (finalCapital < 1.0E9) break;
    }
    return i;
}

private static String roundToDecimal(Fraction num, int places) {
    if (num.numerator.signum() == -1) return "-" + roundToDecimal(new Fraction(num.numerator.negate(), num.denominator), places);
    num = new Fraction(num.numerator.multiply(BigInteger.TEN.pow(places)), num.denominator);
    BigInteger whole = num.numerator.divide(num.denominator);
    Fraction frac = new Fraction(num.numerator.mod(num.denominator), num.denominator);
    Fraction HALF = new Fraction(BigInteger.ONE, BigInteger.valueOf(2));
    if (frac.compareTo(HALF) > 0 || frac.compareTo(HALF) == 0 && whole.testBit(0)) whole = whole.add(BigInteger.ONE);
    StringBuilder sb = new StringBuilder(whole.toString());
    while (sb.length() < places + 1) sb.insert(0, '0');
    sb.insert(sb.length() - places, '.');
    return sb.toString();
}

public <init>() {
    super();
    factorSolutions = new ArrayList();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p271().run());
}

public String run() {
    for (/*synthetic*/ int[] arr$ = FACTORS, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int fact = arr$[i$];
        {
            Set sols = new HashSet();
            for (int j = 1; j < fact; ++j) {
                if (Library.powMod(j, 3, fact) == 1) sols.add(Integer.valueOf(j));
            }
            factorSolutions.add(sols);
        }
    }
    BigInteger sum = buildAndSumSolutions(0, BigInteger.ZERO, BigInteger.ONE);
    return sum.subtract(BigInteger.ONE).toString();
}

private BigInteger buildAndSumSolutions(int factorIndex, BigInteger x, BigInteger m) {
    if (factorIndex == FACTORS.length) return x; else {
        BigInteger result = BigInteger.ZERO;
        BigInteger fact = BigInteger.valueOf(FACTORS[factorIndex]);
        for (/*synthetic*/ java.util.Iterator i$ = ((Set)factorSolutions.get(factorIndex)).iterator(); i$.hasNext(); ) {
            int sol = ((Integer)i$.next()).intValue();
            {
                BigInteger newx = chineseRemainderTheorem(x, m, BigInteger.valueOf(sol), fact);
                BigInteger temp = buildAndSumSolutions(factorIndex + 1, newx, m.multiply(fact));
                result = result.add(temp);
            }
        }
        return result;
    }
}

private static BigInteger chineseRemainderTheorem(BigInteger a, BigInteger p, BigInteger b, BigInteger q) {
    return a.add(b.subtract(a).multiply(p.modInverse(q)).multiply(p)).mod(p.multiply(q));
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p280().run());
}

public String run() {
    int[][] successors = new int[p280$State.ID_LIMIT][];
    for (/*synthetic*/ Iterator i$ = p280$State.listAllStates().iterator(); i$.hasNext(); ) {
        p280$State st = (p280$State)i$.next();
        {
            Set suc = st.getSuccessors();
            int[] sucIds = new int[suc.size()];
            Iterator it = suc.iterator();
            for (int i = 0; i < sucIds.length; ++i) sucIds[i] = ((p280$State)it.next()).id;
            successors[st.id] = sucIds;
        }
    }
    double sum = 0;
    double[] probs = new double[p280$State.ID_LIMIT];
    probs[p280$State.START_STATE.id] = 1;
    for (int i = 1; ; ++i) {
        double[] nextProbs = new double[probs.length];
        for (int j = 0; j < probs.length; ++j) {
            if (probs[j] > 0) {
                int[] suc = successors[j];
                for (/*synthetic*/ int[] arr$ = suc, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
                    int k = arr$[i$];
                    nextProbs[k] += probs[j] / suc.length;
                }
            }
        }
        double doneNow = nextProbs[p280$State.DONE_STATE.id];
        if (i > 44 && doneNow < 1.0E-20) break;
        sum += doneNow * i;
        probs = nextProbs;
    }
    return String.format("%.6f", new Object[]{Double.valueOf(sum)});
}

public static Set listAllStates() {
    HashSet result = new HashSet();
    for (int i = 0; i < (1 << 11); ++i) {
        if (Integer.bitCount(i) != 5) continue;
        for (int y = 0; y < 5; ++y) {
            for (int x = 0; x < 5; ++x) {
                boolean[] seed = new boolean[11];
                for (int j = 0; j < seed.length; ++j) seed[j] = ((i >>> j) & 1) != 0;
                result.add(new p280$State(false, x, y, seed));
            }
        }
    }
    result.add(DONE_STATE);
    return result;
}

public <init>(boolean done, int x, int y, boolean[] seed) {
    super();
    isDone = done;
    antX = x;
    antY = y;
    hasSeed = seed;
    if (done) id = 5 * 5 * (1 << seed.length); else {
        int temp = 0;
        for (int i = 0; i < seed.length; ++i) temp |= (seed[i] ? 1 : 0) << i;
        id = x + y * 5 + temp * 25;
    }
}
STATEMENT:
super();
STATEMENT:
isDone = done;
STATEMENT:
antX = x;
STATEMENT:
antY = y;
STATEMENT:
hasSeed = seed;
STATEMENT:
if (done) id = 5 * 5 * (1 << seed.length); else {
    int temp = 0;
    for (int i = 0; i < seed.length; ++i) temp |= (seed[i] ? 1 : 0) << i;
    id = x + y * 5 + temp * 25;
}

public Set getSuccessors() {
    HashSet result = new HashSet();
    if (!isDone) {
        tryAddSuccessor(-1, 0, result);
        tryAddSuccessor(+1, 0, result);
        tryAddSuccessor(0, -1, result);
        tryAddSuccessor(0, +1, result);
    }
    return result;
}

private void tryAddSuccessor(int dx, int dy, Set result) {
    int x = antX + dx;
    int y = antY + dy;
    if (x < 0 || x >= 5 || y < 0 || y >= 5) return;
    boolean[] seed = (boolean[])hasSeed.clone();
    boolean done = false;
    if (!seed[10] && y == 4 && seed[5 + x]) {
        seed[5 + x] = false;
        seed[10] = true;
    } else if (seed[10] && y == 0 && !seed[x]) {
        seed[10] = false;
        seed[x] = true;
        done = seed[0] & seed[1] & seed[2] & seed[3] & seed[4];
    }
    result.add(new p280$State(done, x, y, seed));
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p301().run());
}

public String run() {
    int a = 0;
    int b = 1;
    for (int i = 0; i < 32; ++i) {
        int c = a + b;
        a = b;
        b = c;
    }
    return Integer.toString(a);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p303().run());
}

public String run() {
    BigInteger sum = BigInteger.ZERO;
    for (int n = 1; n <= 10000; ++n) sum = sum.add(findMinimumMultiple(n).divide(BigInteger.valueOf(n)));
    return sum.toString();
}

private static BigInteger findMinimumMultiple(int n) {
    List feasible = new ArrayList();
    feasible.add(new byte[n]);
    ((byte[])feasible.get(0))[0] = 1;
    for (int i = 0; ((byte[])feasible.get(i))[0] != 2; ++i) {
        if (!$assertionsDisabled && !(i == feasible.size() - 1)) throw new AssertionError();
        byte[] prev = (byte[])feasible.get(i);
        byte[] cur = new byte[n];
        int digitMod = Library.powMod(10, i, n);
        for (int j = 0; j < n; ++j) {
            if (prev[j] > 0) {
                cur[(j + digitMod * 0) % n] = prev[j];
                cur[(j + digitMod * 1) % n] = 2;
                cur[(j + digitMod * 2) % n] = 2;
            }
        }
        feasible.add(cur);
    }
    BigInteger result = BigInteger.ZERO;
    int remainder = 0;
    outer: for (int i = feasible.size() - 2; i >= 0; --i) {
        int digitMod = Library.powMod(10, i, n);
        for (int j = (i == feasible.size() - 2 ? 1 : 0); j <= 2; ++j) {
            int newRem = (remainder - digitMod * j % n + n) % n;
            if (((byte[])feasible.get(i))[newRem] > 0) {
                result = result.multiply(BigInteger.valueOf(10)).add(BigInteger.valueOf(j));
                remainder = newRem;
                continue outer;
            }
        }
        throw new AssertionError();
    }
    return result;
}
IF:
if (!$assertionsDisabled && !(i == feasible.size() - 1)) throw new AssertionError();
3
assert i == feasible.size() - 1;
i == feasible.size() - 1
1548675201
Node[6273624]
13
4

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p304().run());
}

public String run() {
    int[] primes = Library.listPrimes((int)Library.sqrt(BASE + SEARCH_RANGE));
    isComposite = new boolean[SEARCH_RANGE];
    for (/*synthetic*/ int[] arr$ = primes, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int p = arr$[i$];
        {
            for (int i = (int)((BASE + p - 1) / p * p - BASE); i < isComposite.length; i += p) isComposite[i] = true;
        }
    }
    long sum = 0;
    int p = 0;
    for (int i = 0; i < 100000; ++i) {
        p = nextPrime(p);
        sum = (sum + fibonacciMod(BASE + p)) % MODULUS;
    }
    return Long.toString(sum);
}

private int nextPrime(int n) {
    do {
        ++n;
        if (n >= isComposite.length) throw new AssertionError("Search range exhausted");
    }     while (isComposite[n]);
    return n;
}

private static long fibonacciMod(long n) {
    BigInteger a = BigInteger.ZERO;
    BigInteger b = BigInteger.ONE;
    for (int i = 63; i >= 0; --i) {
        BigInteger d = a.multiply(b.shiftLeft(1).subtract(a));
        BigInteger e = a.pow(2).add(b.pow(2));
        a = d;
        b = e;
        if (((n >>> i) & 1) != 0) {
            BigInteger c = a.add(b);
            a = b;
            b = c;
        }
        a = a.mod(MODULUS_BI);
        b = b.mod(MODULUS_BI);
    }
    return a.longValue();
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p315().run());
}

public String run() {
    boolean[] isPrime = Library.listPrimality(20000000);
    int sum = 0;
    for (int i = 10000000; i < isPrime.length; ++i) {
        if (isPrime[i]) sum += samTransitionsMinusMaxTransitions(i);
    }
    return Integer.toString(sum);
}

private static int samTransitionsMinusMaxTransitions(int n) {
    int samTrans = 0;
    int maxTrans = 0;
    long segmentState = 0;
    while (true) {
        long newState = numberToSegments(n);
        if (newState == segmentState) break;
        maxTrans += Long.bitCount(newState ^ segmentState);
        segmentState = newState;
        samTrans += 2 * Long.bitCount(newState);
        n = digitSum(n);
    }
    maxTrans += Long.bitCount(segmentState);
    return samTrans - maxTrans;
}

private static long numberToSegments(int n) {
    if (n < 0 || n > 999999999) throw new IllegalArgumentException();
    long result = 0;
    int i = 0;
    do {
        result |= (long)DECIMAL_DIGIT_TO_SEGMENT[n % 10] << (i * 7);
        n /= 10;
        ++i;
    }     while (n != 0);
    return result;
}

private static int digitSum(int n) {
    if (n < 0) throw new IllegalArgumentException();
    int result = 0;
    while (n != 0) {
        result += n % 10;
        n /= 10;
    }
    return result;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p323().run());
}

@SuppressWarnings(value = "unused")
public String run() {
    Fraction[] expect = new Fraction[SIZE + 1];
    expect[0] = Fraction.ZERO;
    for (int n = 1; n < expect.length; ++n) {
        Fraction sum = Fraction.ZERO;
        for (int k = 0; k < n; ++k) {
            BigInteger binom = Library.binomial(n, k);
            Fraction term = new Fraction(expect[k].numerator.multiply(binom), expect[k].denominator);
            sum = sum.add(term);
        }
        BigInteger twoPowN = BigInteger.ONE.shiftLeft(n);
        Fraction temp = sum.add(new Fraction(twoPowN));
        expect[n] = new Fraction(temp.numerator, temp.denominator.multiply(twoPowN.subtract(BigInteger.ONE)));
    }
    Fraction ans = expect[SIZE];
    if (!$assertionsDisabled && !(ans.compareTo(Fraction.ZERO) >= 0)) throw new AssertionError();
    Fraction scaled = new Fraction(ans.numerator.multiply(BigInteger.TEN.pow(DECIMALS)), ans.denominator);
    BigInteger[] quotRem = scaled.numerator.divideAndRemainder(scaled.denominator);
    BigInteger whole = quotRem[0];
    Fraction frac = new Fraction(quotRem[1], scaled.denominator);
    if (!$assertionsDisabled && !(frac.compareTo(Fraction.ZERO) >= 0)) throw new AssertionError();
    if (!$assertionsDisabled && !(frac.compareTo(new Fraction(BigInteger.ONE)) < 0)) throw new AssertionError();
    Fraction HALF = new Fraction(BigInteger.ONE, BigInteger.valueOf(2));
    if (frac.compareTo(HALF) > 0 || frac.equals(HALF) && whole.testBit(0)) whole = whole.add(BigInteger.ONE);
    String temp = whole.toString();
    ;
    while (temp.length() < DECIMALS + 1) temp = "0" + temp;
    int index = temp.length() - DECIMALS;
    return String.format("%s.%s", new Object[]{temp.substring(0, index), temp.substring(index)});
}
IF:
if (!$assertionsDisabled && !(ans.compareTo(Fraction.ZERO) >= 0)) throw new AssertionError();
4
assert SIZE >= 0;
SIZE >= 0
1588914365
Node[6273628]
13
5
IF:
if (!$assertionsDisabled && !(frac.compareTo(Fraction.ZERO) >= 0)) throw new AssertionError();
5
assert DECIMALS >= 0;
DECIMALS >= 0
1026801430
Node[6273758]
13
6
IF:
if (!$assertionsDisabled && !(frac.compareTo(new Fraction(BigInteger.ONE)) < 0)) throw new AssertionError();
6
assert ans.compareTo(Fraction.ZERO) >= 0;
ans.compareTo(Fraction.ZERO) >= 0
634824041
Node[6273808]
13
7

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p329().run());
}

public String run() {
    long globalNumerator = 0;
    boolean[] isPrime = Library.listPrimality(END_NUM);
    for (int i = START_NUM; i <= END_NUM; ++i) {
        for (int j = 0; j < NUM_TRIALS; ++j) {
            int pos = i;
            int trialNumerator = 1;
            if (isPrime[pos] == (CROAK_SEQ.charAt(0) == 'P')) trialNumerator *= 2;
            for (int k = 0; k < NUM_JUMPS; ++k) {
                if (pos <= START_NUM) ++pos; else if (pos >= END_NUM) --pos; else if (((j >>> k) & 1) == 0) ++pos; else --pos;
                if (isPrime[pos] == (CROAK_SEQ.charAt(k + 1) == 'P')) trialNumerator *= 2;
            }
            globalNumerator += trialNumerator;
        }
    }
    BigInteger globalDenominator = BigInteger.valueOf(END_NUM + 1L - START_NUM).shiftLeft(NUM_JUMPS).multiply(BigInteger.valueOf(3).pow(CROAK_SEQ.length()));
    return new Fraction(BigInteger.valueOf(globalNumerator), globalDenominator).toString();
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p345().run());
}

public String run() {
    if (COLUMNS > 30) throw new AssertionError();
    maxSum = new int[ROWS][1 << COLUMNS];
    return Integer.toString(findMaximumSum(0, (1 << COLUMNS) - 1));
}

private int findMaximumSum(int startRow, int setOfCols) {
    if (startRow == ROWS) {
        if (Integer.bitCount(setOfCols) != COLUMNS - ROWS) throw new AssertionError();
        return 0;
    }
    if (maxSum[startRow][setOfCols] == 0) {
        int max = 0;
        for (int col = 0; (1 << col) <= setOfCols; ++col) {
            if ((setOfCols & (1 << col)) != 0) max = Math.max(MATRIX[startRow][col] + findMaximumSum(startRow + 1, setOfCols ^ (1 << col)), max);
        }
        maxSum[startRow][setOfCols] = max;
    }
    return maxSum[startRow][setOfCols];
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p346().run());
}

public String run() {
    Set strongRepunits = new HashSet();
    strongRepunits.add(Long.valueOf(1L));
    for (int length = 3; length <= BigInteger.valueOf(LIMIT).bitLength(); ++length) {
        middle: for (int base = 2; ; ++base) {
            long value = 0;
            for (int i = 0; i < length; ++i) {
                if (Long.MAX_VALUE / base < value) break middle;
                value *= base;
                if (value + 1 < value) break middle;
                ++value;
            }
            if (value >= LIMIT) break;
            strongRepunits.add(Long.valueOf(value));
        }
    }
    long sum = 0;
    for (/*synthetic*/ java.util.Iterator i$ = strongRepunits.iterator(); i$.hasNext(); ) {
        long x = ((Long)i$.next()).longValue();
        {
            if (sum + x < sum) throw new ArithmeticException("Overflow");
            sum += x;
        }
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p347().run());
}

public String run() {
    Set possible = new HashSet();
    int[] primes = Library.listPrimes(LIMIT / 2);
    for (int i = 0, end = Library.sqrt(LIMIT); i < primes.length; ++i) {
        int p = primes[i];
        if (p > end) break;
        for (int j = i + 1; j < primes.length; ++j) {
            int q = primes[j];
            int lcm = p * q;
            if (lcm > LIMIT) break;
            int multLimit = LIMIT / lcm;
            int multiplier = 1;
            while (multiplier * p <= multLimit) multiplier *= p;
            int maxMult = multiplier;
            while (multiplier % p == 0) {
                multiplier /= p;
                while (multiplier * q <= multLimit) multiplier *= q;
                maxMult = Math.max(multiplier, maxMult);
            }
            possible.add(Integer.valueOf(maxMult * lcm));
        }
    }
    long sum = 0;
    for (/*synthetic*/ java.util.Iterator i$ = possible.iterator(); i$.hasNext(); ) {
        int x = ((Integer)i$.next()).intValue();
        sum += x;
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p348().run());
}

public String run() {
    for (long limit = 1; ; limit *= 10) {
        if (limit > Integer.MAX_VALUE) throw new AssertionError("Overflow");
        long answer = trySearch((int)limit);
        if (answer != -1) return Long.toString(answer);
    }
}

private static long trySearch(int limit) {
    byte[] ways = new byte[limit];
    for (int i = cbrt(limit - 1); i > 1; --i) {
        int cube = i * i * i;
        for (int j = Library.sqrt(limit - 1 - cube); j > 1; --j) {
            int index = cube + j * j;
            ways[index] = (byte)Math.min(ways[index] + 1, TARGET_WAYS + 1);
        }
    }
    long result = 0;
    int count = 0;
    for (int i = 0; i < ways.length; ++i) {
        if (ways[i] == TARGET_WAYS && Library.isPalindrome(i)) {
            result += i;
            ++count;
            if (count == TARGET_COUNT) return result;
        }
    }
    return -1;
}

private static int cbrt(int x) {
    if (x < 0) throw new IllegalArgumentException("Not implemented");
    int y = 0;
    for (int i = 1 << 10; i != 0; i >>>= 1) {
        y |= i;
        if (y > 1290 || y * y * y > x) y ^= i;
    }
    return y;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p357().run());
}

public String run() {
    isPrime = Library.listPrimality(LIMIT + 1);
    long sum = 0;
    for (int n = 0; n <= LIMIT; ++n) {
        if (isPrime[n + 1] && isPrimeGenerating(n)) sum += n;
    }
    return Long.toString(sum);
}

private boolean isPrimeGenerating(int n) {
    for (int i = 1, end = Library.sqrt(n); i <= end; ++i) {
        if (n % i == 0 && !isPrime[i + n / i]) return false;
    }
    return true;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p381().run());
}

public String run() {
    boolean[] isPrime = Library.listPrimality(Library.pow(10, 8));
    long sum = 0;
    for (int i = 5; i < isPrime.length; ++i) {
        if (isPrime[i]) sum += s(i);
    }
    return Long.toString(sum);
}

private static int s(int p) {
    return (int)((long)(p - 3) * Library.reciprocalMod(8 % p, p) % p);
}

public <init>() {
    super();
    sum = BigInteger.ZERO;
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p387().run());
}

public String run() {
    for (int i = 1; i <= 9; ++i) findHarshadPrimes(i, i, false);
    return sum.toString();
}

private void findHarshadPrimes(long n, int digitSum, boolean isStrong) {
    long m = n * 10;
    int s = digitSum;
    for (int i = 0; i < 10 && m < LIMIT; ++i, ++m, ++s) {
        if (isStrong && isPrime(m)) sum = sum.add(BigInteger.valueOf(m));
        if (m % s == 0) findHarshadPrimes(m, s, isPrime(m / s));
    }
}

private static boolean isPrime(long x) {
    if (x < 0) throw new IllegalArgumentException("Negative number");
    if (x == 0 || x == 1) return false;
    for (long i = 2, end = Library.sqrt(x); i <= end; ++i) {
        if (x % i == 0) return false;
    }
    return true;
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p401().run());
}

public String run() {
    int splitCount = (int)Library.sqrt(LIMIT);
    splitCount = Math.max(splitCount / 3, 1);
    int splitAt = (int)(LIMIT / (splitCount + 1));
    long sum = 0;
    for (int i = 1; i <= splitAt; ++i) {
        long count = LIMIT / i % MODULUS;
        long term = (long)i * i % MODULUS;
        term = term * count % MODULUS;
        sum = (sum + term) % MODULUS;
    }
    for (int i = splitCount; i >= 1; --i) {
        long start = LIMIT / (i + 1);
        long end = LIMIT / i;
        long sumSquares = sumSquaresMod(end) - sumSquaresMod(start);
        sumSquares = (sumSquares + MODULUS) % MODULUS;
        sum = (sum + i * sumSquares % MODULUS) % MODULUS;
    }
    return Long.toString(sum);
}

private static long sumSquaresMod(long n) {
    BigInteger x = BigInteger.valueOf(n);
    BigInteger y = x.multiply(x.add(BigInteger.ONE));
    y = y.multiply(x.shiftLeft(1).add(BigInteger.ONE));
    y = y.divide(SIX_BI);
    y = y.mod(MODULUS_BI);
    return y.longValue();
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p407().run());
}

public String run() {
    int[] smallestPrimeFactor = Library.listSmallestPrimeFactors(LIMIT);
    int maxNumPrimeFactors = 0;
    for (int i = 2, prod = 1; i < smallestPrimeFactor.length; ++i) {
        if (smallestPrimeFactor[i] == i) {
            if (LIMIT / prod < i) break;
            prod *= i;
            ++maxNumPrimeFactors;
        }
    }
    long sum = 0;
    int[] solns = new int[1 << maxNumPrimeFactors];
    int[] newsolns = new int[1 << maxNumPrimeFactors];
    for (int i = 1; i <= LIMIT; ++i) {
        List factorization = new ArrayList();
        for (int j = i; j != 1; ) {
            int p = smallestPrimeFactor[j];
            int q = 1;
            do {
                j /= p;
                q *= p;
            }             while (j % p == 0);
            factorization.add(Integer.valueOf(q));
        }
        solns[0] = 0;
        int solnslen = 1;
        int modulus = 1;
        for (/*synthetic*/ java.util.Iterator i$ = factorization.iterator(); i$.hasNext(); ) {
            int q = ((Integer)i$.next()).intValue();
            {
                int recip = Library.reciprocalMod(q % modulus, modulus);
                int newmod = q * modulus;
                int newsolnslen = 0;
                for (int j = 0; j < solnslen; ++j) {
                    newsolns[newsolnslen++] = ((0 + (int)((long)(solns[j] - 0 + modulus) * recip % modulus) * q) % newmod);
                    newsolns[newsolnslen++] = ((1 + (int)((long)(solns[j] - 1 + modulus) * recip % modulus) * q) % newmod);
                }
                solnslen = newsolnslen;
                modulus = newmod;
                int[] temp = solns;
                solns = newsolns;
                newsolns = temp;
            }
        }
        int max = 0;
        for (int j = 0; j < solnslen; ++j) max = Math.max(solns[j], max);
        sum += max;
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p417().run());
}

public String run() {
    int[] primes = Library.listPrimes(LIMIT);
    int[] smallestPrimeFactor = Library.listSmallestPrimeFactors(LIMIT);
    long[] primePowersAndTotients = calcPrimePowersAndTotients(primes);
    int[] primePowerPeriods = calcPrimePowerPeriods(primePowersAndTotients, smallestPrimeFactor);
    smallestPrimeFactor = null;
    int[] periods = calcPeriods(primePowersAndTotients, primePowerPeriods);
    return Long.toString(sumAllPeriods(periods));
}

private static long[] calcPrimePowersAndTotients(int[] primes) {
    p417$LongList temp = new p417$LongList(primes.length * 2);
    for (/*synthetic*/ int[] arr$ = primes, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int p = arr$[i$];
        {
            if (p == 2 || p == 5) continue;
            for (long pow = p, tot = p - 1; pow <= LIMIT; pow *= p, tot *= p) temp.append(pow << 32 | tot);
        }
    }
    long[] result = temp.toArray();
    Arrays.sort(result);
    return result;
}

private static int[] calcPrimePowerPeriods(long[] primePowersAndTotients, int[] smallestPrimeFactor) {
    int[] result = new int[primePowersAndTotients.length];
    for (int i = 0; i < primePowersAndTotients.length; ++i) {
        long ppt = primePowersAndTotients[i];
        int primePow = (int)(ppt >>> 32);
        int period = (int)ppt;
        int remainingFactors = period;
        while (remainingFactors > 1) {
            int q = smallestPrimeFactor[remainingFactors];
            if (Library.powMod(10, period / q, primePow) == 1) period /= q;
            remainingFactors /= q;
        }
        result[i] = period;
    }
    return result;
}

private static int[] calcPeriods(long[] primePowersAndTotients, int[] primePowerPeriods) {
    int[] result = new int[LIMIT + 1];
    result[1] = 1;
    for (int i = 0; i < primePowersAndTotients.length; ++i) {
        int ppow = (int)(primePowersAndTotients[i] >>> 32);
        int period = primePowerPeriods[i];
        for (int j = 0, end = LIMIT / ppow; j <= end; ++j) {
            if (result[j] != 0) result[j * ppow] = lcm(result[j], period);
        }
    }
    result[1] = 0;
    return result;
}

private static long sumAllPeriods(int[] periods) throws AssertionError {
    long sum = 0;
    for (int i = 3; i <= LIMIT; ++i) {
        int n = i;
        n >>>= Integer.numberOfTrailingZeros(n);
        while (n % 5 == 0) n /= 5;
        if (n > 1 && periods[n] == 0) throw new AssertionError();
        sum += periods[n];
    }
    return sum;
}

private static int lcm(int x, int y) {
    return x / Library.gcd(x, y) * y;
}

public <init>(int initCapacity) {
    super();
    if (initCapacity < 1) throw new IllegalArgumentException();
    data = new long[initCapacity];
    length = 0;
}
STATEMENT:
super();
STATEMENT:
if (initCapacity < 1) throw new IllegalArgumentException();
STATEMENT:
data = new long[initCapacity];
STATEMENT:
length = 0;

public void append(long x) {
    if (length == data.length) data = Arrays.copyOf(data, length * 2);
    data[length] = x;
    ++length;
}

public long[] toArray() {
    return Arrays.copyOf(data, length);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p425().run());
}

public String run() {
    boolean[] isPrime = Library.listPrimality(LIMIT);
    int[] pathMax = new int[isPrime.length];
    Arrays.fill(pathMax, Integer.MAX_VALUE);
    Queue queue = new PriorityQueue();
    queue.add(new p425$IntPair(2, 2));
    while (!queue.isEmpty()) {
        p425$IntPair item = (p425$IntPair)queue.remove();
        int n = item.b;
        int pmax = item.a;
        if (pmax >= pathMax[n]) {
            continue;
        }
        pathMax[n] = pmax;
        int[] digits = toDigits(n);
        int[] tempDigits = (int[])digits.clone();
        for (int i = 0; i < tempDigits.length; ++i) {
            for (int j = 0; j < 10; ++j) {
                tempDigits[i] = j;
                int m = toNumber(tempDigits);
                int nextPmax = Math.max(m, pmax);
                if (m < isPrime.length && isPrime[m] && nextPmax < pathMax[m]) queue.add(new p425$IntPair(nextPmax, m));
            }
            tempDigits[i] = digits[i];
        }
    }
    long sum = 0;
    for (int i = 0; i < isPrime.length; ++i) {
        if (isPrime[i] && pathMax[i] > i) sum += i;
    }
    return Long.toString(sum);
}

private static int[] toDigits(int n) {
    if (n < 0) throw new IllegalArgumentException();
    int[] temp = new int[11];
    int len = 0;
    do {
        temp[len] = n % 10;
        n /= 10;
        ++len;
    }     while (n > 0);
    int[] result = new int[len + 1];
    for (int i = 0; i < result.length; ++i) result[i] = temp[len - i];
    return result;
}

private static int toNumber(int[] digits) {
    int result = 0;
    for (/*synthetic*/ int[] arr$ = digits, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        result = result * 10 + x;
    }
    return result;
}

public <init>(int a, int b) {
    super();
    this.a = a;
    this.b = b;
}
STATEMENT:
super();
STATEMENT:
this.a = a;
STATEMENT:
this.b = b;

public int compareTo(p425$IntPair other) {
    return Integer.compare(a, other.a);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p429().run());
}

public String run() {
    int[] primes = Library.listPrimes(LIMIT);
    long sum = 1;
    for (/*synthetic*/ int[] arr$ = primes, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int p = arr$[i$];
        {
            int power = countFactors(LIMIT, p);
            sum *= 1 + Library.powMod(p, power * 2, MODULUS);
            sum %= MODULUS;
        }
    }
    return Long.toString(sum);
}

private static int countFactors(int n, int p) {
    if (n == 0) return 0; else return n / p + countFactors(n / p, p);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p431().run());
}

public String run() {
    double sum = 0;
    for (int i = 20; i <= 25; ++i) sum += findRootSecant(0, RADIUS, i * i);
    return String.format("%.9f", new Object[]{Double.valueOf(sum)});
}

private static double findRootSecant(double x0, double x1, double val) {
    int samples = 10000;
    double y0 = volume(x0, samples);
    double y1 = volume(x1, samples);
    while (Math.abs(x0 - x1) > 1.0E-12) {
        double x2 = (val - y0) / (y1 - y0) * (x1 - x0) + x0;
        double y2 = volume(x2, samples);
        x0 = x1;
        x1 = x2;
        y0 = y1;
        y1 = y2;
        if (Math.abs(x0 - x1) < 1.0E-4) samples = Math.max(1000000, samples);
        if (Math.abs(x0 - x1) < 1.0E-6) samples = Math.max(10000000, samples);
        if (Math.abs(x0 - x1) < 1.0E-8) samples = Math.max(100000000, samples);
    }
    return x1;
}

private static double volume(double x, int samples) {
    double discVolume = Math.pow(RADIUS + x, 3) / 3 * Math.PI * 2;
    if (x > 0) {
        double scaler = x * 2 / samples;
        double r2plusx2 = RADIUS * RADIUS + x * x;
        double rec2x = 1 / (x * 2);
        double sum = 0;
        for (int i = 0; i < samples; ++i) {
            double r = RADIUS - x + (i + 0.5) * scaler;
            double r2 = r * r;
            sum += Math.acos(((r2plusx2 - r2) * rec2x - x) / r) * r2;
        }
        discVolume -= sum * 4 * x / samples;
    }
    return discVolume * Math.tan(REPOSE);
}

public <init>() {
    super();
    sum = 0;
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p433().run());
}

public String run() {
    for (int i = 1; i <= LIMIT; ++i) exploreGcds(i, 0, 0);
    return Long.toString(sum * 2 + (long)LIMIT * (LIMIT + 1) / 2);
}

private void exploreGcds(int x, int y, int steps) {
    if (!(0 <= y && y < x && x <= LIMIT)) throw new IllegalArgumentException();
    sum += steps;
    for (int z = y + (y > 0 ? 1 : 2) * x; z <= LIMIT; z += x) exploreGcds(z, x, steps + 1);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p451().run());
}

public String run() {
    smallestPrimeFactor = Library.listSmallestPrimeFactors(LIMIT);
    solutions = new p451$IntArrayArray(LIMIT / 2 + 1);
    solutions.append(new int[]{});
    solutions.append(new int[]{});
    solutions.append(new int[]{1});
    long sum = 0;
    for (int i = 3; i <= LIMIT; ++i) {
        int[] sols = getSolutions(i);
        if (i <= LIMIT / 2) solutions.append(sols);
        sum += sols[sols.length - 2];
    }
    return Long.toString(sum);
}

private int[] getSolutions(int n) {
    if (smallestPrimeFactor[n] == n) return new int[]{1, n - 1}; else {
        List temp = new ArrayList();
        int p = smallestPrimeFactor[n];
        int[] sols = solutions.get(n / p);
        for (int i = 0, inc = n / p; i < n; i += inc) {
            for (/*synthetic*/ int[] arr$ = sols, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
                int j = arr$[i$];
                {
                    int k = i + j;
                    if ((long)k * k % n == 1) temp.add(Integer.valueOf(k));
                }
            }
        }
        int[] result = new int[temp.size()];
        for (int i = 0; i < result.length; ++i) result[i] = ((Integer)temp.get(i)).intValue();
        return result;
    }
}

public <init>(int len) {
    super();
    data = new int[1];
    dataLength = 0;
    starts = new int[len + 1];
    Arrays.fill(starts, -1);
    starts[0] = 0;
    index = 0;
}
STATEMENT:
super();
STATEMENT:
data = new int[1];
STATEMENT:
dataLength = 0;
STATEMENT:
starts = new int[len + 1];
STATEMENT:
Arrays.fill(starts, -1);
STATEMENT:
starts[0] = 0;
STATEMENT:
index = 0;

public int[] get(int i) {
    return Arrays.copyOfRange(data, starts[i], starts[i + 1]);
}

public void append(int... arr) {
    while (dataLength + arr.length > data.length) data = Arrays.copyOf(data, data.length * 2);
    System.arraycopy(arr, 0, data, dataLength, arr.length);
    dataLength += arr.length;
    ++index;
    starts[index] = dataLength;
}

public <init>() {
    super();
    numerator = BigInteger.ZERO;
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p493().run());
}

public String run() {
    explore(NUM_PICKED, BALLS_PER_COLOR, new Stack());
    BigInteger denominator = Library.binomial(NUM_COLORS * BALLS_PER_COLOR, NUM_PICKED);
    BigDecimal num = new BigDecimal(numerator);
    BigDecimal den = new BigDecimal(denominator);
    return num.divide(den, 9, RoundingMode.HALF_EVEN).toString();
}

private void explore(int remain, int limit, Stack history) {
    if (remain == 0) {
        int[] hist = new int[NUM_COLORS];
        for (int i = 0; i < history.size(); ++i) hist[i] = ((Integer)history.get(i)).intValue();
        int[] histogram = new int[BALLS_PER_COLOR + 1];
        for (/*synthetic*/ int[] arr$ = hist, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
            int x = arr$[i$];
            ++histogram[x];
        }
        BigInteger count = Library.factorial(NUM_COLORS);
        for (/*synthetic*/ int[] arr$ = histogram, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
            int x = arr$[i$];
            count = divideExactly(count, Library.factorial(x));
        }
        for (/*synthetic*/ int[] arr$ = hist, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
            int x = arr$[i$];
            count = count.multiply(Library.binomial(BALLS_PER_COLOR, x));
        }
        int distinctColors = history.size();
        numerator = numerator.add(count.multiply(BigInteger.valueOf(distinctColors)));
    } else if (history.size() < NUM_COLORS) {
        for (int i = Math.min(limit, remain); i > 0; --i) {
            history.push(Integer.valueOf(i));
            explore(remain - i, i, history);
            history.pop();
        }
    }
}

private static BigInteger divideExactly(BigInteger x, BigInteger y) {
    BigInteger[] temp = x.divideAndRemainder(y);
    if (temp[1].signum() != 0) throw new IllegalArgumentException("Not divisible");
    return temp[0];
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p500().run());
}

public String run() {
    Queue queue = new PriorityQueue();
    int nextPrime = 2;
    queue.add(Long.valueOf((long)nextPrime));
    long product = 1;
    for (int i = 0; i < TARGET; ++i) {
        long item = ((Long)queue.remove()).longValue();
        product *= item % MODULUS;
        product %= MODULUS;
        queue.add(Long.valueOf(item * item));
        if (item == nextPrime) {
            do ++nextPrime;             while (!Library.isPrime(nextPrime));
            queue.add(Long.valueOf((long)nextPrime));
        }
    }
    return Long.toString(product);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p518().run());
}

public String run() {
    long sum = 0;
    boolean[] isPrime = Library.listPrimality(LIMIT - 1);
    for (int x = 1; x < isPrime.length; ++x) {
        for (int y = 1; ; ++y) {
            long a = (long)x * y * y - 1;
            if (a >= isPrime.length) break;
            if (!isPrime[(int)a]) continue;
            for (int z = y + 1; ; ++z) {
                if (Library.gcd(y, z) != 1) continue;
                long b = (long)x * y * z - 1;
                long c = (long)x * z * z - 1;
                if (c >= isPrime.length) break;
                if (isPrime[(int)b] && isPrime[(int)c]) {
                    long addend = a + b + c;
                    if (sum + addend < sum) throw new ArithmeticException("Overflow");
                    sum += addend;
                }
            }
        }
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p549().run());
}

public String run() {
    int[] smallestDivisibleFactorials = new int[LIMIT + 1];
    for (int i = 2; i < smallestDivisibleFactorials.length; ++i) {
        if (smallestDivisibleFactorials[i] == 0) {
            long power = 1;
            middle: for (int j = i; ; j += i) {
                power *= i;
                if (power > LIMIT) break;
                for (int inc = (int)power, k = inc; k < smallestDivisibleFactorials.length; k += inc) smallestDivisibleFactorials[k] = Math.max(j, smallestDivisibleFactorials[k]);
                for (int temp = j / i; temp % i == 0; temp /= i) {
                    power *= i;
                    if (power > LIMIT) break middle;
                }
            }
        }
    }
    long sum = 0;
    for (/*synthetic*/ int[] arr$ = smallestDivisibleFactorials, len$ = arr$.length, i$ = 0; i$ < len$; ++i$) {
        int x = arr$[i$];
        sum += x;
    }
    return Long.toString(sum);
}

public <init>() {
    super();
}
STATEMENT:
super();

public static void main(String[] args) {
    System.out.println(new p587().run());
}

public String run() {
    double lSectionArea = 1 - Math.PI / 4;
    for (int i = 1; ; i++) {
        double slope = 1.0 / i;
        double a = slope * slope + 1;
        double b = -2 * (slope + 1);
        double c = 1;
        double x = (2 * c) / (-b + Math.sqrt(b * b - 4 * a * c));
        double concaveTriangleArea = x * (1 - Math.sqrt((-x + 2) * x)) / 2;
        concaveTriangleArea += integral(1) - integral(x);
        if (concaveTriangleArea / lSectionArea < 0.001) return Integer.toString(i);
        if (i == Integer.MAX_VALUE) throw new AssertionError();
    }
}

private static double integral(double x) {
    double t = x - 1;
    return t - (Math.sqrt(1 - t * t) * t + Math.asin(t)) / 2;
}

C:\Users\Oscar\Desktop\Oskar\Tesis\BigCodeProject\PhdPrototype>pause
Presione una tecla para continuar . . . 
